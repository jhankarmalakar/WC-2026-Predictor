<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>World Cup 2026 – Pools → Groups → Knockouts</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg:#0f1220;
      --panel:#151a2e;
      --panel-2:#111527;
      --text:#f5f7ff;
      --muted:#b9c0e6;
      --accent:#7aa2ff;
      --accent-2:#5ee6ff;
      --border:rgba(255,255,255,0.08);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;

      /* Rank highlights */
      --hl-strong-bg: rgba(94, 230, 168, 0.14);
      --hl-strong-br: rgba(94, 230, 168, 0.45);
      --hl-mild-bg:   rgba(122, 162, 255, 0.10);
      --hl-mild-br:   rgba(122, 162, 255, 0.35);

      /* Qualified styling */
      --qualified-br: rgba(94, 230, 168, 0.55);
      --qualified-glow: rgba(94, 230, 168, 0.18);

      /* Eliminated styling */
      --elim-bg: rgba(255, 107, 122, 0.08);
      --elim-br: rgba(255, 107, 122, 0.35);

      /* Click-swap armed styling (amber) */
      --swap-bg: rgba(255, 184, 107, 0.14);
      --swap-br: rgba(255, 184, 107, 0.55);

      /* Winner highlight */
      --win-bg: rgba(122, 255, 187, 0.18);
      --win-br: rgba(122, 255, 187, 0.70);
      --win-glow: rgba(122, 255, 187, 0.22);

      /* Orange action buttons */
      --orange-bg-1: rgba(255, 168, 64, 0.28);
      --orange-bg-2: rgba(255, 122, 64, 0.18);
      --orange-br:   rgba(255, 170, 90, 0.70);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: radial-gradient(1200px 800px at 10% 10%, #1c2342 0%, var(--bg) 40%, #070912 100%);
      min-height:100vh;
    }

    header{
      padding: 18px 20px 8px 20px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap: wrap;
    }
    header h1{
      font-size: 18px;
      font-weight: 650;
      margin:0 0 2px 0;
    }
    header .hint{
      color:var(--muted);
      font-size: 11.5px;
      max-width: 95ch;
    }

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
    }

    .stage-pill{
      font-size: 11.5px;
      color: var(--text);
      border: 1px solid var(--border);
      padding: 9px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.05);
      letter-spacing: 0.2px;
    }

    /* Base buttons */
    button{
      background: linear-gradient(135deg, rgba(122,162,255,0.22), rgba(94,230,255,0.12));
      color: var(--text);
      border: 1px solid rgba(122,162,255,0.55);
      padding: 11px 14px;
      border-radius: 12px;
      font-size: 12.5px;
      cursor: pointer;
      white-space: nowrap;
      box-shadow: 0 0 0 1px rgba(122,162,255,0.08) inset;
    }
    button:hover{
      background: linear-gradient(135deg, rgba(122,162,255,0.30), rgba(94,230,255,0.18));
    }
    button:disabled{ opacity: 0.55; cursor: not-allowed; }

    .btn-mini{
      padding: 8px 10px;
      font-size: 11px;
      border-radius: 10px;
    }

    /* Orange action buttons */
    .btn-orange{
      background: linear-gradient(135deg, var(--orange-bg-1), var(--orange-bg-2));
      border: 1px solid var(--orange-br);
      box-shadow:
        0 0 0 1px rgba(255,170,90,0.10) inset,
        0 6px 16px rgba(0,0,0,0.18);
    }
    .btn-orange:hover{
      background: linear-gradient(135deg, rgba(255, 180, 90, 0.35), rgba(255, 120, 70, 0.22));
    }

    /* ==========================
       R32 out-of-date badge
    ========================== */
    .outofdate-badge{
      display: inline-block;
      margin-left: 8px;
      padding: 2px 7px;
      font-size: 9px;
      font-weight: 800;
      letter-spacing: 0.25px;
      border-radius: 999px;
      border: 1px solid rgba(255, 184, 107, 0.70);
      background: rgba(255, 184, 107, 0.16);
      color: var(--text);
      vertical-align: middle;
      line-height: 1.1;

      /* Optional subtle pop */
      animation: badgeGlowPulse 1.8s ease-in-out infinite;
      transform-origin: left center;
    }
    @keyframes badgeGlowPulse{
      0%, 100%{
        box-shadow:
          0 0 0 0 rgba(255,184,107,0.00),
          0 0 0 0 rgba(255,184,107,0.00);
        filter: saturate(1);
        transform: scale(1);
      }
      50%{
        box-shadow:
          0 0 0 2px rgba(255,184,107,0.18),
          0 0 10px rgba(255,184,107,0.22);
        filter: saturate(1.08);
        transform: scale(1.03);
      }
    }
    @media (prefers-reduced-motion: reduce){
      .outofdate-badge{ animation: none; }
    }

    /* Board grid */
    .board{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
      padding: 8px 16px 30px 16px;
    }
    @media (min-width: 780px){
      .board{ grid-template-columns: 1fr 1fr; }
    }
    @media (min-width: 1100px){
      .board{ grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (min-width: 1400px){
      .board{ grid-template-columns: 1fr 1fr 1fr 1fr; }
    }

    /* Stage separators */
    .stage-separator{
      grid-column: 1 / -1;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 6px 2px 6px;
      flex-wrap: wrap;
    }
    .stage-left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
      flex: 1;
    }
    .stage-title{
      font-size: 11px;
      letter-spacing: 0.35px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.55);
      white-space: nowrap;
    }
    .stage-line{
      height: 1px;
      background: var(--border);
      flex: 1;
      min-width: 30px;
    }
    .stage-right{
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap: wrap;
    }

    /* Column */
    .column{
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      min-height: 160px;
      display:flex;
      flex-direction:column;
    }
    .column-header{
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid var(--border);
      gap: 10px;
    }
    .column-title{
      font-size: 12.2px;
      letter-spacing: 0.35px;
      text-transform: uppercase;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 80%;
    }
    .count{
      font-size: 10.5px;
      color: var(--muted);
      opacity: 0.9;
      white-space: nowrap;
    }

    .zone{
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
      flex: 1;
    }

    /* Card */
    .card{
      background: rgba(255,255,255,0.04);
      border:1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      user-select: none;
      cursor: pointer;
      transition: background 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
    }
    .card.locked{
      cursor: default;
      opacity: 0.9;
    }

    .name{
      font-size: 13.8px;
      font-weight: 560;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display:flex;
      align-items:center;
      gap: 0;
      min-width: 0;
    }
    .tag{
      font-size: 9.8px;
      color: var(--muted);
      border:1px solid var(--border);
      padding: 3px 7px;
      border-radius: 999px;
      white-space: nowrap;
    }

    /* Rank highlights */
    .rank-strong{
      background: var(--hl-strong-bg);
      border-color: var(--hl-strong-br);
    }
    .rank-mild{
      background: var(--hl-mild-bg);
      border-color: var(--hl-mild-br);
    }

    /* Qualified/Eliminated */
    .qualified{
      border-color: var(--qualified-br);
      box-shadow: 0 0 0 1px var(--qualified-glow) inset;
    }
    .eliminated{
      background: var(--elim-bg);
      border-color: var(--elim-br);
    }

    /* First-click armed swap */
    .swap-armed{
      background: var(--swap-bg);
      border-color: var(--swap-br);
      box-shadow: 0 0 0 1px rgba(255,184,107,0.18) inset;
    }

    .footer{
      padding: 0 16px 24px 16px;
      color: var(--muted);
      font-size: 11px;
    }

    .top8-summary{
      margin-top: 10px;
      padding: 10px 12px;
      font-size: 14px;
      font-weight: 800;
      color: var(--text);
      border: 1px dashed var(--border);
      border-radius: 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-align: center;
      background: rgba(255,255,255,0.03);
    }

    /* Flag images */
    .flag-img{
      width: 16px;
      height: 12px;
      object-fit: cover;
      border-radius: 2px;
      margin-right: 6px;
      vertical-align: -1px;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.08);
      flex: 0 0 auto;
    }

    /* ==========================
       Knockout layout (full width)
    ========================== */
    .ko-grid{
      grid-column: 1 / -1;
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 780px){
      .ko-grid{ grid-template-columns: 1fr 1fr; }
    }
    @media (min-width: 1100px){
      .ko-grid{ grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (min-width: 1400px){
      .ko-grid{ grid-template-columns: 1fr 1fr 1fr 1fr; }
    }

    /* Centered rounds (SF/3P/Final) */
    .ko-grid.centered{
      grid-template-columns: 1fr;
      justify-items: center;
    }
    .ko-grid.centered .match-card{
      width: min(760px, 100%);
    }

    .match-card{
      background: rgba(255,255,255,0.035);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px 12px 10px 12px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 10px 10px;
      align-items: center;
      position: relative;
      overflow: hidden;
    }

    /* Match index top-left */
    .match-index{
      position:absolute;
      top: 8px;
      left: 10px;
      font-size: 10px;
      font-weight: 800;
      letter-spacing: 0.4px;
      color: rgba(255,255,255,0.7);
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
    }

    /* Center label above the mid box */
    .match-vs{
      grid-column: 1 / -1;
      text-align: center;
      font-weight: 800;
      font-size: 12.2px;
      letter-spacing: 0.35px;
      color: rgba(255,255,255,0.9);
      margin-top: 2px;
      margin-bottom: 2px;
    }

    .match-team{
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      font-size: 12.8px;
      cursor: pointer;
      text-align: center;
      user-select: none;
      transition: background 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
    }
    .match-team.locked{
      cursor: default;
      opacity: 0.9;
    }

    .match-team.winning{
      background: var(--win-bg);
      border-color: var(--win-br);
      box-shadow:
        0 0 0 1px var(--win-glow) inset,
        0 0 14px rgba(122,255,187,0.12);
    }

    .match-mid{
      min-width: 56px;
      text-align: center;
      font-weight: 900;
      font-size: 12.5px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
      letter-spacing: 1px;
    }

    /* Bottom meta */
    .match-bottom{
      grid-column: 1 / -1;
      display:flex;
      justify-content: space-between;
      gap: 10px;
      margin-top: 2px;
      color: var(--muted);
      flex-wrap: wrap;
    }
    .match-bottom .chip{
      display:inline-block;
      padding: 3px 7px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: rgba(255,255,255,0.04);
      font-size: 10.8px;
      white-space: nowrap;
    }

    .r32-note{
      grid-column: 1 / -1;
      margin-top: 2px;
      font-size: 10.5px;
      color: var(--muted);
      opacity: 0.9;
    }
  </style>
</head>

<body>
  <header>
    <div>
      <h1>Qualifier Pools → Groups → Third Ranking → Knockouts</h1>
      <div class="hint">
        Click/tap two teams in the same editable zone to swap.
        Use “Place qualifiers to the groups” to copy pool winners into groups.
        R32 third-place assignments are frozen once generated — reordering the Third Ranking won’t change R32
        until you click “Regenerate R32”.
      </div>
    </div>

    <div class="actions">
      <span class="stage-pill" id="stagePill">Edit: Pools</span>
      <button id="reformPoolBtn" disabled>Reform Pool</button>
      <button id="resetBtn">Reset</button>
    </div>
  </header>

  <main class="board" id="board"></main>

  <div class="footer">
    Pools editable only in Pool mode. Groups + Third-place ranking editable only in Group mode.
  </div>

  <script>
    /* ==============================
       1) GROUPS + PATHS
    ============================== */
    const DEFAULT_GROUPS = {
      A: ["Mexico","South Africa","South Korea","UFEA Path D"],
      B: ["Canada","UFEA Path A","Qatar","Switzerland"],
      C: ["Brazil","Morocco","Haiti","Scotland"],
      D: ["United States","Paraguay","Australia","UFEA Path C"],
      E: ["Germany","Curaçao","Ivory Coast","Ecuador"],
      F: ["Netherlands","Japan","UFEA Path B","Tunisia"],
      G: ["Belgium","Egypt","Iran","New Zealand"],
      H: ["Spain","Cape Verde","Saudi Arabia","Uruguay"],
      I: ["France","Senegal","FIFA IC Path 2","Norway"],
      J: ["Argentina","Algeria","Austria","Jordan"],
      K: ["Portugal","FIFA IC Path 1","Uzbekistan","Colombia"],
      L: ["England","Croatia","Ghana","Panama"]
    };

    const PATHS = [
      { id: "ufeapath-a", label: "UFEA Path A",
        candidates: ["Wales", "Bosnia and Herzegovina", "Italy", "Northern Ireland"], group: "B" },
      { id: "ufeapath-b", label: "UFEA Path B",
        candidates: ["Ukraine", "Sweden", "Poland", "Albania"], group: "F" },
      { id: "ufeapath-c", label: "UFEA Path C",
        candidates: ["Slovakia", "Kosovo", "Turkey", "Romania"], group: "D" },
      { id: "ufeapath-d", label: "UFEA Path D",
        candidates: ["Czech Republic", "Republic of Ireland", "Denmark", "North Macedonia"], group: "A" },
      { id: "fifaicpath-1", label: "FIFA IC Path 1",
        candidates: ["New Caledonia", "Jamaica", "DR Congo"], group: "K" },
      { id: "fifaicpath-2", label: "FIFA IC Path 2",
        candidates: ["Bolivia", "Suriname", "Iraq"], group: "I" }
    ];

    const PATH_BY_ID = Object.fromEntries(PATHS.map(p => [p.id, p]));
    const PATH_ID_BY_LABEL = Object.fromEntries(PATHS.map(p => [p.label, p.id]));
    const GROUP_KEYS = Object.keys(DEFAULT_GROUPS);

    const toId = (name) =>
      String(name || "")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/(^-|-$)/g, "");

    /* ==============================
       2) Rank + odds models (AUTO)
    ============================== */
    const RANK_BY_NAME = {
      "Spain":1,
      "Argentina":2,
      "France":3,
      "England":4,
      "Brazil":5,
      "Portugal":6,
      "Netherlands":7,
      "Belgium":8,
      "Germany":9,
      "Croatia":10,
      "Morocco":11,
      "Italy":12,
      "Colombia":13,
      "United States":14,
      "USA":14,
      "Mexico":15,
      "Uruguay":16,
      "Switzerland":17,
      "Japan":18,
      "Senegal":19,
      "Iran":20,
      "Denmark":21,
      "South Korea":22,
      "Ecuador":23,
      "Austria":24,
      "Turkey":25,
      "Türkiye":25,
      "Australia":26,
      "Canada":27,
      "Ukraine":28,
      "Norway":29,
      "Panama":30,
      "Poland":31,
      "Wales":32,
      "Scotland":36,
      "Serbia":37,
      "Nigeria":38,
      "Czechia":39,
      "Czech Republic":39,
      "Tunisia":40,
      "Ivory Coast":42,
      "Côte d'Ivoire":42,
      "Sweden":43,
      "Slovakia":45,
      "Romania":47,
      "Uzbekistan":50,
      "Qatar":51,
      "Saudi Arabia":60,
      "South Africa":61,
      "Albania":63,
      "Jordan":64,
      "Cape Verde":68,
      "Cabo Verde":68,
      "Jamaica":70,
      "Kosovo":80,
      "Curaçao":82,
      "New Zealand":104
    };

    const ODDS_POSITIVE = {
      "Spain": 400,
      "England": 550,
      "France": 700,
      "Brazil": 750,
      "Argentina": 800,
      "Germany": 1200,
      "Portugal": 1200,
      "Netherlands": 1200
    };

    function rankOf(name){
      if(!name) return 999;
      return RANK_BY_NAME[name] ?? 999;
    }

    function impliedProbFromPositiveOdds(x){
      return 100 / (x + 100);
    }

    function pickWinnerNameAuto(a, b){
      const aOdds = ODDS_POSITIVE[a];
      const bOdds = ODDS_POSITIVE[b];

      if(aOdds && bOdds){
        const pa = impliedProbFromPositiveOdds(aOdds);
        const pb = impliedProbFromPositiveOdds(bOdds);
        const sum = pa + pb;
        const ra = pa / sum;
        return Math.random() < ra ? a : b;
      }

      const ra = rankOf(a);
      const rb = rankOf(b);
      if(ra === rb){
        return String(a).localeCompare(String(b)) <= 0 ? a : b;
      }
      return ra < rb ? a : b;
    }

    /* ==============================
       3) Flags (image-based)
    ============================== */
    const FLAG_CODE_BY_NAME = {
      "Mexico":"mx",
      "South Africa":"za",
      "South Korea":"kr",
      "Canada":"ca",
      "Qatar":"qa",
      "Switzerland":"ch",
      "Brazil":"br",
      "Morocco":"ma",
      "Haiti":"ht",
      "Scotland":"gb",
      "United States":"us",
      "United States of America":"us",
      "USA":"us",
      "Paraguay":"py",
      "Australia":"au",
      "Germany":"de",
      "Curaçao":"cw",
      "Ivory Coast":"ci",
      "Côte d'Ivoire":"ci",
      "Ecuador":"ec",
      "Netherlands":"nl",
      "Japan":"jp",
      "Tunisia":"tn",
      "Belgium":"be",
      "Egypt":"eg",
      "Iran":"ir",
      "New Zealand":"nz",
      "Spain":"es",
      "Cape Verde":"cv",
      "Cabo Verde":"cv",
      "Saudi Arabia":"sa",
      "Uruguay":"uy",
      "France":"fr",
      "Senegal":"sn",
      "Norway":"no",
      "Argentina":"ar",
      "Algeria":"dz",
      "Austria":"at",
      "Jordan":"jo",
      "Portugal":"pt",
      "Uzbekistan":"uz",
      "Colombia":"co",
      "England":"gb",
      "Croatia":"hr",
      "Ghana":"gh",
      "Panama":"pa",
      "Wales":"gb",
      "Bosnia and Herzegovina":"ba",
      "Italy":"it",
      "Northern Ireland":"gb",
      "Ukraine":"ua",
      "Sweden":"se",
      "Poland":"pl",
      "Albania":"al",
      "Slovakia":"sk",
      "Kosovo":"xk",
      "Turkey":"tr",
      "Türkiye":"tr",
      "Romania":"ro",
      "Czech Republic":"cz",
      "Czechia":"cz",
      "Republic of Ireland":"ie",
      "Denmark":"dk",
      "North Macedonia":"mk",
      "New Caledonia":"nc",
      "Jamaica":"jm",
      "DR Congo":"cd",
      "Bolivia":"bo",
      "Suriname":"sr",
      "Iraq":"iq",
      "Serbia":"rs",
      "Nigeria":"ng"
    };

    function flagHTML(name){
      if(!name) return "";
      if(
        name.startsWith("UEFA Path") ||
        name.startsWith("FIFA IC Path") ||
        name.includes("UFEA Path") ||
        name.includes("FIFA IC Path")
      ) return "";

      const code = FLAG_CODE_BY_NAME[name];
      if(!code) return "";
      return `<img class="flag-img" src="https://flagcdn.com/w20/${code}.png" alt="${code} flag" loading="lazy">`;
    }
    function nameWithFlagHTML(name){
      return `${flagHTML(name)}${name ?? ""}`;
    }

    /* ==============================
       4) Edit mode + click-swap state
    ============================== */
    let editMode = "pools";
    let swapSelection = null;

    let qualifiedThirdGroupLetters = "";
    let qualifiedThirdPlacedTeams = [];

    // NEW: R32 out-of-date tracking for third ranking reorder
    let thirdRankingDirty = false;

    /* ==============================
       5) Build state
    ============================== */
    function buildGroupsFromDefaults(){
      const groups = {};
      GROUP_KEYS.forEach(g => {
        groups[g] = DEFAULT_GROUPS[g].map(entryName => {
          const pathId = PATH_ID_BY_LABEL[entryName];
          if(pathId){
            return {
              id: `ph-${pathId}-${g}`,
              name: entryName,
              tag: "Placeholder",
              isPlaceholder: true,
              pathId
            };
          }
          return {
            id: toId(`${g}-${entryName}`),
            name: entryName,
            tag: `Group ${g}`,
            isPlaceholder: false
          };
        });
      });
      return groups;
    }

    function buildPaths(){
      const paths = {};
      PATHS.forEach(p => {
        paths[p.id] = p.candidates.map(name => ({
          id: toId(`${p.id}-${name}`),
          name,
          tag: p.label,
          originPathId: p.id,
          isQualified: false,
          isEliminated: false
        }));
      });
      return paths;
    }

    function fallbackPathNameForGroup(g){
      const p = PATHS.find(x => x.group === g);
      if(!p) return "TBD";

      if(p.id.startsWith("ufeapath-")){
        const letter = p.id.replace("ufeapath-","");
        const map = { a: 1, b: 2, c: 3, d: 4 };
        const n = map[letter] ?? letter.toUpperCase();
        return `UEFA Path ${n}`;
      }
      if(p.id.startsWith("fifaicpath-")){
        const n = p.id.replace("fifaicpath-","");
        return `FIFA IC Path ${n}`;
      }
      return p.label;
    }

    function buildThirdRankingFromGroups(groups){
      const base = [];
      GROUP_KEYS.forEach(g => {
        const third = groups[g]?.[2];
        base.push({
          id: toId(`third-${g}-${third?.name ?? "tbd"}`),
          groupKey: g,
          name: third?.name ?? fallbackPathNameForGroup(g)
        });
      });
      return base;
    }

    const initialState = () => {
      const groups = buildGroupsFromDefaults();
      const paths  = buildPaths();
      const qualifiedByPath = {};
      PATHS.forEach(p => qualifiedByPath[p.id] = false);

      return {
        paths,
        groups,
        qualifiedByPath,
        thirdRanking: buildThirdRankingFromGroups(groups),

        // Knockout
        r32Generated: false,

        // winners for ALL KO matches
        winners: {},

        // SNAPSHOTS for R32 third-place assignment
        r32ThirdSnapshot: null,   // { letters, top8, assignment }
      };
    };

    let state = initialState();

    /* ==============================
       6) Zones
    ============================== */
    const pathZones  = PATHS.map(p => `path-${p.id}`);
    const groupZones = GROUP_KEYS.map(g => `group-${g}`);

    const THIRD_RANK_ZONE = "third-ranking";
    const CHAMP_ZONE      = "champions-view";
    const RUNNERS_ZONE    = "runners-view";
    const TOP8_ZONE       = "top8-third-view";

    const zones = [
      ...pathZones,
      ...groupZones,
      THIRD_RANK_ZONE,
      CHAMP_ZONE,
      RUNNERS_ZONE,
      TOP8_ZONE
    ];

    const isPathZone = (z) => z.startsWith("path-");
    const isGroupZone = (z) => z.startsWith("group-");
    const pathIdFromZone = (z) => z.replace("path-","");
    const groupKeyFromZone = (z) => {
      const m = z.match(/^group-([A-L])$/);
      return m ? m[1] : null;
    };

    /* ==============================
       7) KO structure
    ============================== */
    // Store venue-time + offset so we can render LOCAL user time.
    // offsetHours example: -7 means venue time is UTC-7.
    const R32_INFO = {
      73: { date: "June 28, 2026", time: "12:00 p.m.", offsetHours:-7, stadium: "SoFi Stadium", city: "Inglewood" },
      74: { date: "June 29, 2026", time: "4:30 p.m.",  offsetHours:-4, stadium: "Gillette Stadium", city: "Foxborough" },
      75: { date: "June 29, 2026", time: "7:00 p.m.",  offsetHours:-6, stadium: "Estadio BBVA", city: "Guadalupe" },
      76: { date: "June 29, 2026", time: "12:00 p.m.", offsetHours:-5, stadium: "NRG Stadium", city: "Houston" },
      77: { date: "June 30, 2026", time: "5:00 p.m.",  offsetHours:-4, stadium: "MetLife Stadium", city: "East Rutherford" },
      78: { date: "June 30, 2026", time: "12:00 p.m.", offsetHours:-5, stadium: "AT&T Stadium", city: "Arlington" },
      79: { date: "June 30, 2026", time: "7:00 p.m.",  offsetHours:-6, stadium: "Estadio Azteca", city: "Mexico City" },
      80: { date: "July 1, 2026",  time: "12:00 p.m.", offsetHours:-4, stadium: "Mercedes-Benz Stadium", city: "Atlanta" },
      81: { date: "July 1, 2026",  time: "5:00 p.m.",  offsetHours:-7, stadium: "Levi's Stadium", city: "Santa Clara" },
      82: { date: "July 1, 2026",  time: "1:00 p.m.",  offsetHours:-7, stadium: "Lumen Field", city: "Seattle" },
      83: { date: "July 2, 2026",  time: "7:00 p.m.",  offsetHours:-4, stadium: "BMO Field", city: "Toronto" },
      84: { date: "July 2, 2026",  time: "12:00 p.m.", offsetHours:-7, stadium: "SoFi Stadium", city: "Inglewood" },
      85: { date: "July 2, 2026",  time: "8:00 p.m.",  offsetHours:-7, stadium: "BC Place", city: "Vancouver" },
      86: { date: "July 3, 2026",  time: "6:00 p.m.",  offsetHours:-4, stadium: "Hard Rock Stadium", city: "Miami Gardens" },
      87: { date: "July 3, 2026",  time: "8:30 p.m.",  offsetHours:-5, stadium: "Arrowhead Stadium", city: "Kansas City" },
      88: { date: "July 3, 2026",  time: "1:00 p.m.",  offsetHours:-5, stadium: "AT&T Stadium", city: "Arlington" }
    };

    const R16_INFO = {
      89: { date:"July 4, 2026", time:"5:00 p.m.",  offsetHours:-4, stadium:"Lincoln Financial Field", city:"Philadelphia" },
      90: { date:"July 4, 2026", time:"12:00 p.m.", offsetHours:-5, stadium:"NRG Stadium", city:"Houston" },
      91: { date:"July 5, 2026", time:"4:00 p.m.",  offsetHours:-4, stadium:"MetLife Stadium", city:"East Rutherford" },
      92: { date:"July 5, 2026", time:"6:00 p.m.",  offsetHours:-6, stadium:"Estadio Azteca", city:"Mexico City" },
      93: { date:"July 6, 2026", time:"2:00 p.m.",  offsetHours:-5, stadium:"AT&T Stadium", city:"Arlington" },
      94: { date:"July 6, 2026", time:"5:00 p.m.",  offsetHours:-7, stadium:"Lumen Field", city:"Seattle" },
      95: { date:"July 7, 2026", time:"12:00 p.m.", offsetHours:-4, stadium:"Mercedes-Benz Stadium", city:"Atlanta" },
      96: { date:"July 7, 2026", time:"1:00 p.m.",  offsetHours:-7, stadium:"BC Place", city:"Vancouver" }
    };

    const QF_INFO = {
      97: { date:"July 9, 2026",  time:"4:00 p.m.",  offsetHours:-4, stadium:"Gillette Stadium", city:"Foxborough" },
      98: { date:"July 10, 2026", time:"12:00 p.m.", offsetHours:-7, stadium:"SoFi Stadium", city:"Inglewood" },
      99: { date:"July 11, 2026", time:"5:00 p.m.",  offsetHours:-4, stadium:"Hard Rock Stadium", city:"Miami Gardens" },
      100:{ date:"July 11, 2026", time:"8:00 p.m.",  offsetHours:-5, stadium:"Arrowhead Stadium", city:"Kansas City" }
    };

    const SF_INFO = {
      101:{ date:"July 14, 2026", time:"2:00 p.m.", offsetHours:-5, stadium:"AT&T Stadium", city:"Arlington" },
      102:{ date:"July 15, 2026", time:"3:00 p.m.", offsetHours:-4, stadium:"Mercedes-Benz Stadium", city:"Atlanta" }
    };

    const THIRD_INFO = {
      103:{ date:"July 18, 2026", time:"5:00 p.m.", offsetHours:-4, stadium:"Hard Rock Stadium", city:"Miami Gardens" }
    };

    const FINAL_INFO = {
      104:{ date:"July 19, 2026", time:"3:00 p.m.", offsetHours:-4, stadium:"MetLife Stadium", city:"East Rutherford" }
    };

    const R32_MATCHES = [
      { id: 73, left: {type:"RU", g:"A"}, right:{type:"RU", g:"B"} },
      { id: 74, left: {type:"W",  g:"E"}, right:{type:"3SET", set:"A/B/C/D/F"} },
      { id: 75, left: {type:"W",  g:"F"}, right:{type:"RU", g:"C"} },
      { id: 76, left: {type:"W",  g:"C"}, right:{type:"RU", g:"F"} },
      { id: 77, left: {type:"W",  g:"I"}, right:{type:"3SET", set:"C/D/F/G/H"} },
      { id: 78, left: {type:"RU", g:"E"}, right:{type:"RU", g:"I"} },
      { id: 79, left: {type:"W",  g:"A"}, right:{type:"3SET", set:"C/E/F/H/I"} },
      { id: 80, left: {type:"W",  g:"L"}, right:{type:"3SET", set:"E/H/I/J/K"} },
      { id: 81, left: {type:"W",  g:"D"}, right:{type:"3SET", set:"B/E/F/I/J"} },
      { id: 82, left: {type:"W",  g:"G"}, right:{type:"3SET", set:"A/E/H/I/J"} },
      { id: 83, left: {type:"RU", g:"K"}, right:{type:"RU", g:"L"} },
      { id: 84, left: {type:"W",  g:"H"}, right:{type:"RU", g:"J"} },
      { id: 85, left: {type:"W",  g:"B"}, right:{type:"3SET", set:"E/F/G/I/J"} },
      { id: 86, left: {type:"W",  g:"J"}, right:{type:"RU", g:"H"} },
      { id: 87, left: {type:"W",  g:"K"}, right:{type:"3SET", set:"D/E/I/J/L"} },
      { id: 88, left: {type:"RU", g:"D"}, right:{type:"RU", g:"G"} }
    ];

    const R16_MATCHES = [
      { id: 90, left:{type:"WM", id:73}, right:{type:"WM", id:75} },
      { id: 89, left:{type:"WM", id:74}, right:{type:"WM", id:77} },
      { id: 91, left:{type:"WM", id:76}, right:{type:"WM", id:78} },
      { id: 92, left:{type:"WM", id:79}, right:{type:"WM", id:80} },
      { id: 93, left:{type:"WM", id:83}, right:{type:"WM", id:84} },
      { id: 94, left:{type:"WM", id:81}, right:{type:"WM", id:82} },
      { id: 95, left:{type:"WM", id:86}, right:{type:"WM", id:88} },
      { id: 96, left:{type:"WM", id:85}, right:{type:"WM", id:87} }
    ];

    const QF_MATCHES = [
      { id: 97, left:{type:"WM", id:89}, right:{type:"WM", id:90} },
      { id: 98, left:{type:"WM", id:93}, right:{type:"WM", id:94} },
      { id: 99, left:{type:"WM", id:91}, right:{type:"WM", id:92} },
      { id:100, left:{type:"WM", id:95}, right:{type:"WM", id:96} }
    ];

    const SF_MATCHES = [
      { id:101, left:{type:"WM", id:97}, right:{type:"WM", id:98} },
      { id:102, left:{type:"WM", id:99}, right:{type:"WM", id:100} }
    ];

    const THIRD_MATCH = [
      { id:103, left:{type:"LM", id:101}, right:{type:"LM", id:102} }
    ];

    const FINAL_MATCH = [
      { id:104, left:{type:"WM", id:101}, right:{type:"WM", id:102} }
    ];

    const ALL_ROUNDS = {
      r32: R32_MATCHES,
      r16: R16_MATCHES,
      qf:  QF_MATCHES,
      sf:  SF_MATCHES,
      third: THIRD_MATCH,
      final: FINAL_MATCH
    };

    const INFO_BY_MATCH = {
      ...R32_INFO, ...R16_INFO, ...QF_INFO, ...SF_INFO, ...THIRD_INFO, ...FINAL_INFO
    };

    /* ==============================
       8) Third-place mapping table
       - partial (your paste)
    ============================== */
    const THIRD_MATCH_ID_ORDER = [74, 77, 79, 80, 81, 82, 85, 87];

    const THIRD_TABLE_RAW = {
       "EFGHIJKL ": ["3E","3J","3I","3F","3H","3G","3L","3K"],
       "DFGHIJKL ": ["3H","3G","3I","3D","3J","3F","3L","3K"],

       // (keep as you had)
       "ABCDEFGJ": ["3C","3G","3B","3D","3A","3F","3E","3J"],
       "ABCDEFGI": ["3C","3G","3B","3D","3A","3F","3E","3I"],
       "ABCDEFGH": ["3H","3G","3B","3C","3A","3F","3D","3E"]
    };

    const THIRD_TABLE = Object.fromEntries(
      Object.entries(THIRD_TABLE_RAW).map(([key, arr]) => {
        const matchMap = {};
        THIRD_MATCH_ID_ORDER.forEach((mid, i) => {
          matchMap[mid] = arr[i];
        });
        return [key, matchMap];
      })
    );

    /* ==============================
       9) Third-place derived data
    ============================== */
    function getThirdTeamForGroup(g){
      const arr = state.groups[g] ?? [];
      const t = arr[2];
      return t && !t.isPlaceholder ? t : null;
    }

    function syncThirdRankingNames(){
      const existingByGroup = new Map(state.thirdRanking.map(x => [x.groupKey, x]));

      GROUP_KEYS.forEach(g => {
        if(!existingByGroup.has(g)){
          state.thirdRanking.push({
            id: toId(`third-${g}-tbd`),
            groupKey: g,
            name: fallbackPathNameForGroup(g)
          });
        }
      });

      state.thirdRanking = state.thirdRanking.filter(x => GROUP_KEYS.includes(x.groupKey));

      state.thirdRanking.forEach(item => {
        const third = getThirdTeamForGroup(item.groupKey);
        item.name = third ? third.name : fallbackPathNameForGroup(item.groupKey);
      });
    }

    function computeChampions(){
      return GROUP_KEYS.map(g => {
        const t = state.groups[g]?.[0];
        const name = (!t || t.isPlaceholder) ? fallbackPathNameForGroup(g) : t.name;
        return { id: toId(`champ-${g}-${name}`), name, groupKey: g };
      });
    }

    function computeRunners(){
      return GROUP_KEYS.map(g => {
        const t = state.groups[g]?.[1];
        const name = (!t || t.isPlaceholder) ? fallbackPathNameForGroup(g) : t.name;
        return { id: toId(`runner-${g}-${name}`), name, groupKey: g };
      });
    }

    function computeTop8ThirdPlaced(){
      syncThirdRankingNames();

      const top8Source = state.thirdRanking.slice(0, 8);

      qualifiedThirdPlacedTeams = top8Source.map(x => ({ groupKey: x.groupKey, name: x.name }));

      qualifiedThirdGroupLetters = top8Source
        .map(x => x.groupKey)
        .sort((a,b) => a.localeCompare(b))
        .join("");

      const top8 = top8Source.map((x, i) => ({
        id: toId(`top8-third-${i}-${x.groupKey}-${x.name}`),
        name: x.name,
        groupKey: x.groupKey
      }));

      top8.sort((a, b) => a.groupKey.localeCompare(b.groupKey));
      return top8;
    }

    function thirdPlaceholderName(setSpec){
      return setSpec
        .split("/")
        .map(s => s.trim())
        .filter(Boolean)
        .map(g => `3${g}`)
        .join("/");
    }

    function parseAllowedThird(spec){
      return spec.split("/").map(s => s.trim()).filter(Boolean);
    }

    /* ==============================
       10) Build R32 third snapshot
       - FREEZE until Regenerate
    ============================== */
    function buildR32ThirdSnapshot(){
      // Uses current thirdRanking order.
      const top8 = computeTop8ThirdPlaced(); // also fills qualifiedThirdGroupLetters / teams
      const letters = qualifiedThirdGroupLetters;

      const tableRow = THIRD_TABLE[letters];

      const assignment = {}; // matchId -> { groupKey, name, source }

      if(tableRow){
        // Use table mapping
        THIRD_MATCH_ID_ORDER.forEach(mid => {
          const tag = tableRow[mid]; // "3E"
          const g = tag.replace("3","");
          const found = state.thirdRanking.find(x => x.groupKey === g);
          assignment[mid] = {
            groupKey: g,
            name: found ? found.name : tag,
            source: "table"
          };
        });
      } else {
        // Greedy UNIQUE fallback using allowed sets
        const rankedTop8 = state.thirdRanking.slice(0,8);
        const used = new Set();

        function pickAllowedUnique(allowed){
          // 1) try highest ranked within allowed
          const cand1 = rankedTop8.find(x => allowed.includes(x.groupKey) && !used.has(x.groupKey));
          if(cand1) return cand1;
          // 2) else highest ranked unused overall
          const cand2 = rankedTop8.find(x => !used.has(x.groupKey));
          return cand2 || null;
        }

        // find matches that actually need 3SET in your R32 list
        const thirdMatches = R32_MATCHES.filter(m =>
          m.left.type === "3SET" || m.right.type === "3SET"
        );

        thirdMatches.forEach(m => {
          const slot = (m.left.type === "3SET") ? m.left : m.right;
          const allowed = parseAllowedThird(slot.set);
          const pick = pickAllowedUnique(allowed);

          if(pick){
            used.add(pick.groupKey);
            assignment[m.id] = {
              groupKey: pick.groupKey,
              name: pick.name,
              source: "greedy"
            };
          } else {
            assignment[m.id] = {
              groupKey: "?",
              name: "3rd TBD",
              source: "greedy"
            };
          }
        });
      }

      state.r32ThirdSnapshot = { letters, top8: qualifiedThirdPlacedTeams.slice(), assignment };
    }

    /* ==============================
       11) KO slot resolution
    ============================== */
    function getGroupPosTeam(g, idx){
      const t = state.groups[g]?.[idx];
      if(!t || t.isPlaceholder) return { name: fallbackPathNameForGroup(g), groupKey: g };
      return { name: t.name, groupKey: g };
    }

    function teamAbbrev(name){
      if(!name) return "---";
      const SPECIAL = {
        "United States": "USA",
        "United States of America": "USA",
        "South Korea": "KOR",
        "North Macedonia": "MKD",
        "Republic of Ireland": "IRL",
        "Czech Republic": "CZE",
        "Bosnia and Herzegovina": "BIH",
        "New Zealand": "NZL",
        "Cape Verde": "CPV",
        "Cabo Verde": "CPV",
        "Ivory Coast": "CIV",
        "Côte d'Ivoire":"CIV",
        "DR Congo": "COD",
        "Northern Ireland": "NIR"
      };
      if(SPECIAL[name]) return SPECIAL[name];

      if(name.startsWith("UEFA Path")) return "UEF";
      if(name.startsWith("FIFA IC Path")) return "FIC";

      const words = name.replace(/[().]/g,"").split(/\s+/).filter(Boolean);
      if(words.length >= 2){
        const init = words.map(w => w[0]).join("").toUpperCase();
        return init.slice(0,3).padEnd(3, init[0] ?? "X");
      }
      const s = words[0].toUpperCase();
      if(s.length <= 3) return s;
      return s.slice(0,3);
    }

    function resolveSlot(slot, matchId){
      if(slot.type === "W"){
        const t = getGroupPosTeam(slot.g, 0);
        return { name: t.name, label: `1${slot.g}`, placeholder:false };
      }
      if(slot.type === "RU"){
        const t = getGroupPosTeam(slot.g, 1);
        return { name: t.name, label: `2${slot.g}`, placeholder:false };
      }
      if(slot.type === "3SET"){
        const allowed = parseAllowedThird(slot.set);

        if(!state.r32Generated){
          const ph = thirdPlaceholderName(slot.set);
          return { name: ph, label: ph, placeholder:true, source:"placeholder", allowed };
        }

        // AFTER generation: USE SNAPSHOT ONLY
        const snap = state.r32ThirdSnapshot;
        const assign = snap?.assignment?.[matchId];

        if(assign){
          return {
            name: assign.name,
            label: `3${assign.groupKey}`,
            placeholder:false,
            source: assign.source
          };
        }

        // Safety fallback
        return { name:"3rd TBD", label:"3?", placeholder:true, source:"fallback", allowed };
      }
      if(slot.type === "WM"){
        const w = state.winners[slot.id];
        if(!w) return { name:`Winner ${slot.id}`, label:`W${slot.id}`, placeholder:true };
        return { name:w.name, label:`W${slot.id}`, placeholder:false };
      }
      if(slot.type === "LM"){
        const w = state.winners[slot.id];
        if(!w) return { name:`Loser ${slot.id}`, label:`L${slot.id}`, placeholder:true };

        const prev = findMatchById(slot.id);
        if(!prev) return { name:`Loser ${slot.id}`, label:`L${slot.id}`, placeholder:true };

        const p = resolveParticipants(prev);
        const loserName = (p.left.name === w.name) ? p.right.name : p.left.name;

        if(!loserName || p.left.placeholder || p.right.placeholder){
          return { name:`Loser ${slot.id}`, label:`L${slot.id}`, placeholder:true };
        }

        return { name: loserName, label:`L${slot.id}`, placeholder:false };
      }

      return { name:"TBD", label:"---", placeholder:true };
    }

    function findMatchById(id){
      for(const k of Object.keys(ALL_ROUNDS)){
        const m = ALL_ROUNDS[k].find(x => x.id === id);
        if(m) return m;
      }
      return null;
    }

    function resolveParticipants(match){
      const L = resolveSlot(match.left, match.id);
      const R = resolveSlot(match.right, match.id);
      return { left:L, right:R };
    }

    /* ==============================
       12) Winner validation (cascade)
    ============================== */
    function validateAllWinners(){
      const order = [
        ...R32_MATCHES.map(m=>m.id),
        ...R16_MATCHES.map(m=>m.id),
        ...QF_MATCHES.map(m=>m.id),
        ...SF_MATCHES.map(m=>m.id),
        103,
        104
      ];

      order.forEach(id => {
        const match = findMatchById(id);
        if(!match) return;

        const stored = state.winners[id];
        if(!stored) return;

        const p = resolveParticipants(match);

        if(p.left.placeholder || p.right.placeholder){
          delete state.winners[id];
          return;
        }

        const currentLeft = p.left.name;
        const currentRight = p.right.name;

        // Clear if matchup changed since pick
        if(stored.leftAtPick !== currentLeft || stored.rightAtPick !== currentRight){
          delete state.winners[id];
          return;
        }

        if(![currentLeft, currentRight].includes(stored.name)){
          delete state.winners[id];
          return;
        }
      });
    }

    function setWinner(matchId, side, name){
      const match = findMatchById(matchId);
      if(!match) return;

      const p = resolveParticipants(match);
      if(p.left.placeholder || p.right.placeholder) return;

      const ab = teamAbbrev(name);

      state.winners[matchId] = {
        side,
        name,
        abbrev: ab,
        leftAtPick: p.left.name,
        rightAtPick: p.right.name
      };

      validateAllWinners();
      render();
    }

    /* ==============================
       13) Edit rules
    ============================== */
    function isClickSwapEnabledForZone(zoneKey){
      if(editMode === "pools") return isPathZone(zoneKey);
      if(editMode === "groups"){
        return isGroupZone(zoneKey) || zoneKey === THIRD_RANK_ZONE;
      }
      return false;
    }

    /* ==============================
       14) Zone arrays
    ============================== */
    function getZoneArray(zoneKey){
      if(isPathZone(zoneKey)) return state.paths[pathIdFromZone(zoneKey)];
      if(isGroupZone(zoneKey)) return state.groups[groupKeyFromZone(zoneKey)];
      if(zoneKey === THIRD_RANK_ZONE){ syncThirdRankingNames(); return state.thirdRanking; }
      if(zoneKey === CHAMP_ZONE) return computeChampions();
      if(zoneKey === RUNNERS_ZONE) return computeRunners();
      if(zoneKey === TOP8_ZONE) return computeTop8ThirdPlaced();
      return null;
    }

    /* ==============================
       15) Pool status display
    ============================== */
    function clearPoolStatus(){
      PATHS.forEach(p => {
        const arr = state.paths[p.id];
        if(!arr) return;
        arr.forEach(t => { t.isQualified = false; t.isEliminated = false; });
        state.qualifiedByPath[p.id] = false;
      });
    }

    function markQualifiedAndEliminated(pathId){
      const pathArr = state.paths[pathId];
      if(!pathArr || pathArr.length === 0) return;
      pathArr.forEach((t, i) => {
        t.isQualified = (i === 0);
        t.isEliminated = (i !== 0);
      });
      state.qualifiedByPath[pathId] = true;
    }

    /* ==============================
       16) Click-to-swap logic
    ============================== */
    function swapTeamsInArray(arr, id1, id2){
      const i1 = arr.findIndex(t => t.id === id1);
      const i2 = arr.findIndex(t => t.id === id2);
      if(i1 === -1 || i2 === -1) return false;
      [arr[i1], arr[i2]] = [arr[i2], arr[i1]];
      return true;
    }

    function handleClickSwap(teamId, zone){
      if(!isClickSwapEnabledForZone(zone)) return;

      if(!swapSelection){
        swapSelection = { teamId, zone };
        render();
        return;
      }

      if(swapSelection.teamId === teamId && swapSelection.zone === zone){
        swapSelection = null;
        render();
        return;
      }

      if(swapSelection.zone !== zone){
        swapSelection = { teamId, zone };
        render();
        return;
      }

      const arr = getZoneArray(zone);
      if(!arr) return;

      const ok = swapTeamsInArray(arr, swapSelection.teamId, teamId);
      swapSelection = null;

      if(ok){
        // Group changes can affect KO immediately.
        // Third-order changes should NOT affect R32 until Regenerate.
        if(zone === THIRD_RANK_ZONE){
          thirdRankingDirty = true; // NEW
        }

        validateAllWinners();
      }

      render();
    }

    function attachClickSwap(card){
      card.addEventListener("click", () => {
        handleClickSwap(card.dataset.id, card.dataset.zone);
      });
    }

    /* ==============================
       17) Place qualifiers to groups
    ============================== */
    function upsertPathTeamInGroup(groupKey, pathId, chosenTeam){
      const arr = state.groups[groupKey];
      if(!arr) return;

      const phIndex = arr.findIndex(t => t.isPlaceholder && t.pathId === pathId);
      if(phIndex !== -1){
        arr.splice(phIndex, 1, {
          id: toId(`grp-${groupKey}-${pathId}-${chosenTeam.name}`),
          name: chosenTeam.name,
          tag: PATH_BY_ID[pathId].label,
          chosenFromPath: true,
          pathId
        });
        return;
      }

      const exIndex = arr.findIndex(t => t.chosenFromPath && t.pathId === pathId);
      if(exIndex !== -1){
        arr.splice(exIndex, 1, {
          id: toId(`grp-${groupKey}-${pathId}-${chosenTeam.name}`),
          name: chosenTeam.name,
          tag: PATH_BY_ID[pathId].label,
          chosenFromPath: true,
          pathId
        });
        return;
      }

      arr.push({
        id: toId(`grp-${groupKey}-${pathId}-${chosenTeam.name}`),
        name: chosenTeam.name,
        tag: PATH_BY_ID[pathId].label,
        chosenFromPath: true,
        pathId
      });
    }

    function placeQualifiersToGroups(){
      PATHS.forEach(p => {
        const pathArr = state.paths[p.id];
        if(!pathArr || pathArr.length === 0) return;
        const chosen = pathArr[0];
        upsertPathTeamInGroup(p.group, p.id, chosen);
        markQualifiedAndEliminated(p.id);
      });

      editMode = "groups";
      swapSelection = null;

      validateAllWinners();
      render();
    }

    function reformPoolMode(){
      editMode = "pools";
      swapSelection = null;
      clearPoolStatus();
      render();
    }

    /* ==============================
       18) AUTO select (partial fill)
    ============================== */
    function sortArrayByRank(arr){
      arr.sort((a,b) => {
        const ra = rankOf(a.name);
        const rb = rankOf(b.name);
        if(ra === rb) return String(a.name).localeCompare(String(b.name));
        return ra - rb;
      });
    }

    function autoPools(){
      PATHS.forEach(p => {
        const arr = state.paths[p.id];
        if(arr) sortArrayByRank(arr);
      });
      render();
    }

    function autoGroups(){
      GROUP_KEYS.forEach(g => {
        const arr = state.groups[g];
        if(!arr) return;
        const real = arr.filter(x => !x.isPlaceholder);
        const ph   = arr.filter(x => x.isPlaceholder);
        real.sort((a,b) => {
          const ra = rankOf(a.name);
          const rb = rankOf(b.name);
          if(ra === rb) return String(a.name).localeCompare(String(b.name));
          return ra - rb;
        });
        state.groups[g] = [...real, ...ph].slice(0,4);
      });

      validateAllWinners();
      render();
    }

    function autoThirdRanking(){
      syncThirdRankingNames();
      state.thirdRanking.sort((a,b) => {
        const ra = rankOf(a.name);
        const rb = rankOf(b.name);
        if(ra === rb) return a.groupKey.localeCompare(b.groupKey);
        return ra - rb;
      });

      // IMPORTANT: does NOT rebuild R32 assignment unless regenerate clicked.
      validateAllWinners();
      render();
    }

    function autoRound(matches){
      validateAllWinners();

      matches.forEach(m => {
        // Only fill UNFILLED matches
        if(state.winners[m.id]) return;

        const p = resolveParticipants(m);
        if(p.left.placeholder || p.right.placeholder) return;

        const winnerName = pickWinnerNameAuto(p.left.name, p.right.name);
        const side = (winnerName === p.left.name) ? "L" : "R";

        state.winners[m.id] = {
          side,
          name: winnerName,
          abbrev: teamAbbrev(winnerName),
          leftAtPick: p.left.name,
          rightAtPick: p.right.name
        };
      });

      validateAllWinners();
      render();
    }

    /* ==============================
       19) Regenerate R32
    ============================== */
    function regenerateR32(){
      // Clear ALL knockout winners for clean consistency
      state.winners = {};

      state.r32Generated = true;

      // Build frozen third assignment snapshot
      buildR32ThirdSnapshot();

      // NEW: R32 now synced with third ranking
      thirdRankingDirty = false;

      validateAllWinners();
      render();
    }

    /* ==============================
       20) UI build
    ============================== */
    function makeSeparator(text, buttonOptions=null){
      const sep = document.createElement("div");
      sep.className = "stage-separator";

      const left = document.createElement("div");
      left.className = "stage-left";
      left.innerHTML = `
        <span class="stage-title">${text}</span>
        <span class="stage-line"></span>
      `;
      sep.appendChild(left);

      if(buttonOptions){
        const right = document.createElement("div");
        right.className = "stage-right";

        const btns = Array.isArray(buttonOptions) ? buttonOptions : [buttonOptions];
        btns.forEach(opt => {
          const btn = document.createElement("button");
          btn.id = opt.id;
          btn.textContent = opt.text;
          if(opt.mini) btn.classList.add("btn-mini");
          if(opt.orange) btn.classList.add("btn-orange");
          right.appendChild(btn);
        });

        sep.appendChild(right);
      }

      return sep;
    }

    function makeColumn(title, zoneKey, subtitle = ""){
      const col = document.createElement("section");
      col.className = "column";
      col.innerHTML = `
        <div class="column-header">
          <div class="column-title">${title}${subtitle ? ` • ${subtitle}` : ""}</div>
          <div class="count" data-count-for="${zoneKey}"></div>
        </div>
        <div class="zone" data-zone="${zoneKey}"></div>
      `;
      return col;
    }

    function makeKoGrid(roundKey, className=""){
      const grid = document.createElement("div");
      grid.className = `ko-grid ${className}`.trim();
      grid.dataset.koRound = roundKey;
      return grid;
    }

    function buildBoard(){
      const board = document.getElementById("board");
      board.innerHTML = "";

      // Pools
      board.appendChild(
        makeSeparator(
          "Qualifier Pools",
          [
            { id:"autoPoolsBtn", text:"Auto Select Pool positions", orange:true },
          ]
        )
      );
      PATHS.forEach(p => {
        board.appendChild(makeColumn(p.label, `path-${p.id}`, `feeds Group ${p.group}`));
      });

      // Groups
      board.appendChild(
        makeSeparator(
          "Groups",
          [
            { id:"placeQualifiersBtn", text:"Place qualifiers to the groups" },
            { id:"autoGroupsBtn", text:"Auto Select Group positions", orange:true }
          ]
        )
      );
      GROUP_KEYS.forEach(g => {
        board.appendChild(makeColumn(`Group ${g}`, `group-${g}`));
      });

      // Tools
      board.appendChild(
        makeSeparator(
          "Group Tools & Third-Place Ordering",
          [
            { id:"autoThirdBtn", text:"Auto Select 3rd place positions", orange:true }
          ]
        )
      );
      board.appendChild(makeColumn("Third Place Team Ranking", THIRD_RANK_ZONE, "A3 → L3"));
      board.appendChild(makeColumn("Group Champions", CHAMP_ZONE, "A1 → L1"));
      board.appendChild(makeColumn("Group Runners", RUNNERS_ZONE, "A2 → L2"));
      board.appendChild(makeColumn("Top-8 Third Placed Teams", TOP8_ZONE, "auto"));

      // R32
      board.appendChild(
        makeSeparator(
          "Round of 32",
          [
            { id:"regenerateR32Btn", text:"Regenerate R32", orange:true },
            { id:"autoR32Btn", text:"Auto Select R32 winners", orange:true }
          ]
        )
      );
      board.appendChild(makeKoGrid("r32"));

      // R16
      board.appendChild(
        makeSeparator(
          "Round of 16",
          [
            { id:"autoR16Btn", text:"Auto Select R16 winners", orange:true }
          ]
        )
      );
      board.appendChild(makeKoGrid("r16"));

      // QF
      board.appendChild(
        makeSeparator(
          "Quarterfinals",
          [
            { id:"autoQFBtn", text:"Auto Select QF winners", orange:true }
          ]
        )
      );
      board.appendChild(makeKoGrid("qf"));

      // SF (centered)
      board.appendChild(
        makeSeparator(
          "Semifinals",
          [
            { id:"autoSFBtn", text:"Auto Select SF winners", orange:true }
          ]
        )
      );
      board.appendChild(makeKoGrid("sf", "centered"));

      // Third place (centered)
      board.appendChild(
        makeSeparator(
          "Third Place",
          [
            { id:"autoThirdMatchBtn", text:"Auto Select 3rd Place winner", orange:true }
          ]
        )
      );
      board.appendChild(makeKoGrid("third", "centered"));

      // Final (centered)
      board.appendChild(
        makeSeparator(
          "Final",
          [
            { id:"autoFinalBtn", text:"Auto Select Final winner", orange:true }
          ]
        )
      );
      board.appendChild(makeKoGrid("final", "centered"));
    }

    /* ==============================
       21) Render standard zones
    ============================== */
    function applyRankHighlight(cardEl, zone, idx, team){
      cardEl.classList.remove("rank-strong", "rank-mild", "qualified", "eliminated");

      if(isPathZone(zone)){
        if(idx === 0) cardEl.classList.add("rank-strong");
        if(editMode === "groups"){
          if(team.isQualified) cardEl.classList.add("qualified");
          if(team.isEliminated) cardEl.classList.add("eliminated");
        }
        return;
      }

      if(isGroupZone(zone)){
        if(idx === 0 || idx === 1) cardEl.classList.add("rank-strong");
        else if(idx === 2) cardEl.classList.add("rank-mild");
        return;
      }

      if(zone === THIRD_RANK_ZONE){
        if(idx < 8) cardEl.classList.add("rank-strong");
        return;
      }

      if(zone === TOP8_ZONE){
        cardEl.classList.add("rank-strong");
      }
    }

    function renderStandardZones(){
      syncThirdRankingNames();

      zones.forEach(zone => {
        const dz = document.querySelector(`.zone[data-zone="${zone}"]`);
        if(!dz) return;

        dz.innerHTML = "";
        const arr = getZoneArray(zone) ?? [];
        const gKey = isGroupZone(zone) ? groupKeyFromZone(zone) : null;

        arr.forEach((team, idx) => {
          const card = document.createElement("div");
          card.className = "card";
          card.dataset.id = team.id;
          card.dataset.zone = zone;

          const editable =
            isClickSwapEnabledForZone(zone) &&
            !team.isPlaceholder &&
            zone !== CHAMP_ZONE &&
            zone !== RUNNERS_ZONE &&
            zone !== TOP8_ZONE;

          if(!editable) card.classList.add("locked");

          applyRankHighlight(card, zone, idx, team);

          if(swapSelection && swapSelection.teamId === team.id && swapSelection.zone === zone){
            card.classList.add("swap-armed");
          }

          let tagText = "";
          if(isPathZone(zone)){
            tagText = (editMode === "groups")
              ? (team.isQualified ? "Qualified" : "Eliminated")
              : (team.tag ?? PATH_BY_ID[pathIdFromZone(zone)]?.label ?? "");
          }
          else if(isGroupZone(zone)){
            tagText = team.isPlaceholder ? "Placeholder" : `${gKey}${idx + 1}`;
          }
          else if(zone === THIRD_RANK_ZONE){
            tagText = `${team.groupKey}3`;
          }
          else if(zone === CHAMP_ZONE){
            tagText = `${team.groupKey}1`;
          }
          else if(zone === RUNNERS_ZONE){
            tagText = `${team.groupKey}2`;
          }
          else if(zone === TOP8_ZONE){
            tagText = `${team.groupKey}3`;
          }

          card.innerHTML = `
            <span class="name">${nameWithFlagHTML(team.name)}</span>
            <span class="tag">${tagText}</span>
          `;

          if(!team.isPlaceholder && ![CHAMP_ZONE, RUNNERS_ZONE, TOP8_ZONE].includes(zone)){
            attachClickSwap(card);
          }

          dz.appendChild(card);
        });

        if(zone === TOP8_ZONE){
          const summary = document.createElement("div");
          summary.className = "top8-summary";
          summary.textContent = qualifiedThirdGroupLetters || "—";
          dz.appendChild(summary);
        }

        const countEl = document.querySelector(`[data-count-for="${zone}"]`);
        if(countEl){
          countEl.textContent = `${arr.length} team${arr.length !== 1 ? "s" : ""}`;
        }
      });
    }

    /* ==============================
       22) Local time rendering helpers
    ============================== */
    const MONTHS = {
      january:0, february:1, march:2, april:3, may:4, june:5,
      july:6, august:7, september:8, october:9, november:10, december:11
    };

    function parseDateStr(dateStr){
      // "June 28, 2026"
      const m = String(dateStr).match(/^([A-Za-z]+)\s+(\d{1,2}),\s+(\d{4})$/);
      if(!m) return null;
      const month = MONTHS[m[1].toLowerCase()];
      const day = Number(m[2]);
      const year = Number(m[3]);
      if(month == null) return null;
      return { year, month, day };
    }

    function parseTime12h(timeStr){
      // "4:30 p.m." or "12:00 p.m."
      const s = String(timeStr).toLowerCase().replace(/\s+/g," ").trim();
      const m = s.match(/^(\d{1,2}):(\d{2})\s*(a\.m\.|p\.m\.)$/);
      if(!m) return null;
      let h = Number(m[1]);
      const min = Number(m[2]);
      const ampm = m[3];
      if(ampm.startsWith("p") && h !== 12) h += 12;
      if(ampm.startsWith("a") && h === 12) h = 0;
      return { h, min };
    }

    function utcMillisFromVenueInfo(info){
      if(!info || info.offsetHours == null) return null;
      const d = parseDateStr(info.date);
      const t = parseTime12h(info.time);
      if(!d || !t) return null;

      // venue local time = UTC + offsetHours
      // => UTC = venueLocal - offsetHours
      const utcHour = t.h - info.offsetHours;

      return Date.UTC(d.year, d.month, d.day, utcHour, t.min, 0);
    }

    function formatLocalKickoff(info){
      const ms = utcMillisFromVenueInfo(info);
      if(ms == null) return info?.time ? info.time : "Time TBD";

      const dt = new Date(ms);

      // Display in viewer's local timezone
      const fmt = new Intl.DateTimeFormat(undefined, {
        dateStyle: "medium",
        timeStyle: "short"
      });
      return fmt.format(dt);
    }

    /* ==============================
       23) Render KO rounds
    ============================== */
    function buildMatchCard(match){
      const p = resolveParticipants(match);
      const L = p.left;
      const R = p.right;

      const winner = state.winners[match.id];
      const info = INFO_BY_MATCH[match.id];

      const card = document.createElement("div");
      card.className = "match-card";
      card.dataset.matchId = match.id;

      // Match index top-left
      const idx = document.createElement("div");
      idx.className = "match-index";
      idx.textContent = `Match ${match.id}`;
      card.appendChild(idx);

      // Center "XX vs XX" label above mid box (uses slot labels)
      const vs = document.createElement("div");
      vs.className = "match-vs";
      vs.textContent = `${L.label} vs ${R.label}`;
      card.appendChild(vs);

      // Left team
      const leftBtn = document.createElement("div");
      leftBtn.className = "match-team";
      leftBtn.innerHTML = nameWithFlagHTML(L.name);

      // Mid abbrev
      const mid = document.createElement("div");
      mid.className = "match-mid";

      // Right team
      const rightBtn = document.createElement("div");
      rightBtn.className = "match-team";
      rightBtn.innerHTML = nameWithFlagHTML(R.name);

      const inR32Range = (match.id >= 73 && match.id <= 88);

      const canPick =
        (!inR32Range || state.r32Generated) &&
        !L.placeholder && !R.placeholder;

      if(!canPick){
        leftBtn.classList.add("locked");
        rightBtn.classList.add("locked");
        mid.textContent = "---";
      } else {
        leftBtn.addEventListener("click", () => setWinner(match.id, "L", L.name));
        rightBtn.addEventListener("click", () => setWinner(match.id, "R", R.name));
        mid.textContent = winner ? winner.abbrev : "---";
      }

      if(winner && canPick){
        if(winner.name === L.name) leftBtn.classList.add("winning");
        if(winner.name === R.name) rightBtn.classList.add("winning");
      }

      card.appendChild(leftBtn);
      card.appendChild(mid);
      card.appendChild(rightBtn);

      // Bottom meta
      const bottom = document.createElement("div");
      bottom.className = "match-bottom";

      const leftMeta = document.createElement("span");
      const rightMeta = document.createElement("span");

      if(info){
        leftMeta.innerHTML = `
          <span class="chip">${info.date}</span>
          <span class="chip">Local time: ${formatLocalKickoff(info)}</span>
        `;
        rightMeta.innerHTML = `
          <span class="chip">${info.stadium}</span>
          <span class="chip">${info.city}</span>
        `;
      } else {
        leftMeta.innerHTML = `<span class="chip">Date/Time TBD</span>`;
        rightMeta.innerHTML = `<span class="chip">Venue TBD</span>`;
      }

      bottom.appendChild(leftMeta);
      bottom.appendChild(rightMeta);

      card.appendChild(bottom);

      return card;
    }

    function renderKoRound(roundKey){
      const grid = document.querySelector(`.ko-grid[data-ko-round="${roundKey}"]`);
      if(!grid) return;

      grid.innerHTML = "";

      const matches = ALL_ROUNDS[roundKey] ?? [];

      matches.forEach(m => {
        grid.appendChild(buildMatchCard(m));
      });

      if(roundKey === "r32"){
        const note = document.createElement("div");
        note.className = "r32-note";

        if(!state.r32Generated){
          note.textContent =
            "R32 not generated yet. Third-place slots are placeholders from the mapping sets.";
        } else {
          note.textContent =
            "R32 3rd-place teams are frozen from your last Regenerate click.";
        }

        grid.appendChild(note);
      }
    }

    function renderAllKo(){
      validateAllWinners();

      renderKoRound("r32");
      renderKoRound("r16");
      renderKoRound("qf");
      renderKoRound("sf");
      renderKoRound("third");
      renderKoRound("final");
    }

    /* ==============================
       24) R32 badge updater
    ============================== */
    function updateRegenerateR32Badge(){
      const btn = document.getElementById("regenerateR32Btn");
      if(!btn) return;

      const base = "Regenerate R32";

      if(thirdRankingDirty){
        btn.innerHTML = `${base}<span class="outofdate-badge">R32 out-of-date</span>`;
      } else {
        btn.textContent = base;
      }
    }

    /* ==============================
       25) Stage pill + buttons
    ============================== */
    function updateStagePillAndButtons(){
      const pill = document.getElementById("stagePill");
      const reformBtn = document.getElementById("reformPoolBtn");
      const placeBtn = document.getElementById("placeQualifiersBtn");

      if(pill){
        pill.textContent = editMode === "pools" ? "Edit: Pools" : "Edit: Groups";
      }
      if(reformBtn){
        reformBtn.disabled = (editMode === "pools");
      }
      if(placeBtn){
        placeBtn.disabled = (editMode !== "pools");
      }

      // NEW
      updateRegenerateR32Badge();
    }

    function wireButtons(){
      const resetBtn = document.getElementById("resetBtn");
      const reformBtn = document.getElementById("reformPoolBtn");

      const placeBtn = document.getElementById("placeQualifiersBtn");
      const autoPoolsBtn = document.getElementById("autoPoolsBtn");
      const autoGroupsBtn = document.getElementById("autoGroupsBtn");
      const autoThirdBtn = document.getElementById("autoThirdBtn");

      const regenerateR32Btn = document.getElementById("regenerateR32Btn");
      const autoR32Btn = document.getElementById("autoR32Btn");
      const autoR16Btn = document.getElementById("autoR16Btn");
      const autoQFBtn = document.getElementById("autoQFBtn");
      const autoSFBtn = document.getElementById("autoSFBtn");
      const autoThirdMatchBtn = document.getElementById("autoThirdMatchBtn");
      const autoFinalBtn = document.getElementById("autoFinalBtn");

      if(placeBtn){
        placeBtn.addEventListener("click", () => {
          if(editMode !== "pools") return;
          placeQualifiersToGroups();
        });
      }

      if(reformBtn){
        reformBtn.addEventListener("click", () => reformPoolMode());
      }

      if(resetBtn){
        resetBtn.addEventListener("click", () => {
          state = initialState();
          editMode = "pools";
          swapSelection = null;

          // NEW
          thirdRankingDirty = false;

          buildBoard();
          render();
          wireButtons();
        });
      }

      if(autoPoolsBtn) autoPoolsBtn.addEventListener("click", autoPools);
      if(autoGroupsBtn) autoGroupsBtn.addEventListener("click", autoGroups);
      if(autoThirdBtn) autoThirdBtn.addEventListener("click", autoThirdRanking);

      if(regenerateR32Btn){
        regenerateR32Btn.addEventListener("click", () => {
          regenerateR32();
        });
      }

      if(autoR32Btn){
        autoR32Btn.addEventListener("click", () => {
          if(!state.r32Generated) regenerateR32();
          autoRound(R32_MATCHES);
        });
      }

      if(autoR16Btn) autoR16Btn.addEventListener("click", () => autoRound(R16_MATCHES));
      if(autoQFBtn)  autoQFBtn.addEventListener("click", () => autoRound(QF_MATCHES));
      if(autoSFBtn)  autoSFBtn.addEventListener("click", () => autoRound(SF_MATCHES));
      if(autoThirdMatchBtn) autoThirdMatchBtn.addEventListener("click", () => autoRound(THIRD_MATCH));
      if(autoFinalBtn) autoFinalBtn.addEventListener("click", () => autoRound(FINAL_MATCH));
    }

    /* ==============================
       26) Render orchestrator
    ============================== */
    function render(){
      syncThirdRankingNames();
      renderStandardZones();
      renderAllKo();
      updateStagePillAndButtons();
    }

    /* ==============================
       27) Boot
    ============================== */
    document.addEventListener("DOMContentLoaded", () => {
      buildBoard();
      render();
      wireButtons();
    });
  </script>
</body>
</html>
