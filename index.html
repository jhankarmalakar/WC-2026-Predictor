<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>World Cup 2026 – Qualifier Pools → Form Groups</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg:#0f1220;
      --panel:#151a2e;
      --panel-2:#111527;
      --text:#f5f7ff;
      --muted:#b9c0e6;
      --accent:#7aa2ff;
      --border:rgba(255,255,255,0.08);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;

      /* Rank highlights */
      --hl-strong-bg: rgba(94, 230, 168, 0.14);
      --hl-strong-br: rgba(94, 230, 168, 0.45);
      --hl-mild-bg:   rgba(122, 162, 255, 0.10);
      --hl-mild-br:   rgba(122, 162, 255, 0.35);

      /* Qualified styling */
      --qualified-br: rgba(94, 230, 168, 0.55);
      --qualified-glow: rgba(94, 230, 168, 0.18);

      /* Eliminated styling */
      --elim-bg: rgba(255, 107, 122, 0.08);
      --elim-br: rgba(255, 107, 122, 0.35);

      /* Swap/preview styling (amber) */
      --swap-bg: rgba(255, 184, 107, 0.14);
      --swap-br: rgba(255, 184, 107, 0.55);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: radial-gradient(1200px 800px at 10% 10%, #1c2342 0%, var(--bg) 40%, #070912 100%);
      min-height:100vh;
    }

    header{
      padding: 18px 20px 8px 20px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap: wrap;
    }
    header h1{
      font-size: 18px;
      font-weight: 650;
      margin:0 0 2px 0;
      letter-spacing:0.2px;
    }
    header .hint{
      color:var(--muted);
      font-size: 11.5px;
    }

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
    }

    /* Bigger stage pill */
    .stage-pill{
      font-size: 11.5px;
      color: var(--text);
      border: 1px solid var(--border);
      padding: 9px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.05);
      letter-spacing: 0.2px;
    }

    /* Bigger buttons */
    button{
      background: rgba(122,162,255,0.12);
      color: var(--text);
      border: 1px solid rgba(122,162,255,0.35);
      padding: 11px 14px;
      border-radius: 12px;
      font-size: 12.5px;
      cursor: pointer;
      white-space: nowrap;
    }
    button:hover{ background: rgba(122,162,255,0.18); }
    button:disabled{ opacity: 0.6; cursor: not-allowed; }

    /* Board grid */
    .board{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
      padding: 8px 16px 30px 16px;
    }
    @media (min-width: 780px){
      .board{ grid-template-columns: 1fr 1fr; }
    }
    @media (min-width: 1100px){
      .board{ grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (min-width: 1400px){
      .board{ grid-template-columns: 1fr 1fr 1fr 1fr; }
    }

    /* Stage separators */
    .stage-separator{
      grid-column: 1 / -1;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 6px 2px 6px;
    }
    .stage-left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
      flex: 1;
    }
    .stage-title{
      font-size: 11px;
      letter-spacing: 0.35px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.55);
      white-space: nowrap;
    }
    .stage-line{
      height: 1px;
      background: var(--border);
      flex: 1;
      min-width: 30px;
    }

    /* Column */
    .column{
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      min-height: 160px;
      display:flex;
      flex-direction:column;
    }
    .column-header{
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid var(--border);
      gap: 10px;
    }
    .column-title{
      font-size: 12.2px;
      letter-spacing: 0.35px;
      text-transform: uppercase;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 75%;
    }
    .count{
      font-size: 10.5px;
      color: var(--muted);
      opacity: 0.9;
      white-space: nowrap;
    }

    .dropzone{
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
      flex: 1;
      transition: background 120ms ease, outline 120ms ease;
    }
    .dropzone.over{
      background: rgba(122,162,255,0.08);
      outline: 1px dashed rgba(122,162,255,0.5);
      outline-offset: -6px;
    }

    /* Card */
    .card{
      background: rgba(255,255,255,0.04);
      border:1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      cursor: grab;
      user-select: none;

      /* Mobile drag fix */
      touch-action: none;

      transition: background 120ms ease, border-color 120ms ease, transform 80ms ease, box-shadow 120ms ease;
    }
    .card:active{ cursor: grabbing; }

    .name{
      font-size: 13.8px;
      font-weight: 560;
      letter-spacing: 0.1px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .tag{
      font-size: 9.8px;
      color: var(--muted);
      border:1px solid var(--border);
      padding: 3px 7px;
      border-radius: 999px;
      white-space: nowrap;
    }

    .dragging{ opacity: 0.35; }

    .drag-clone{
      position: fixed;
      z-index: 9999;
      pointer-events: none;
      width: min(340px, 88vw);
      transform: translate(-50%, -50%);
      box-shadow: 0 18px 45px rgba(0,0,0,0.5);
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(8px);
    }

    /* Rank highlights */
    .rank-strong{
      background: var(--hl-strong-bg);
      border-color: var(--hl-strong-br);
    }
    .rank-mild{
      background: var(--hl-mild-bg);
      border-color: var(--hl-mild-br);
    }

    /* Qualified: doesn't override strong bg */
    .qualified{
      border-color: var(--qualified-br);
      box-shadow: 0 0 0 1px var(--qualified-glow) inset;
    }

    /* Eliminated */
    .eliminated{
      background: var(--elim-bg);
      border-color: var(--elim-br);
    }

    /* First-click armed swap */
    .swap-armed{
      background: var(--swap-bg);
      border-color: var(--swap-br);
      box-shadow: 0 0 0 1px rgba(255,184,107,0.18) inset;
    }

    /* Live drag target preview */
    .drag-target{
      background: var(--swap-bg);
      border-color: var(--swap-br);
      box-shadow: 0 0 0 1px rgba(255,184,107,0.18) inset;
    }

    .footer{
      padding: 0 16px 24px 16px;
      color: var(--muted);
      font-size: 11px;
    }
  </style>
</head>

<body>
  <header>
    <div>
      <h1>Qualifier Pools → Form Groups → Group Stage</h1>
      <div class="hint">
        Rank teams inside pools first. “Form Groups” copies the #1 from each path into the linked group.
        The qualified team stays in the pool.
      </div>
    </div>

    <div class="actions">
      <span class="stage-pill" id="stagePill">Stage: Pools</span>
      <button id="resetBtn">Reset</button>
    </div>
  </header>

  <main class="board" id="board"></main>

  <div class="footer">
    Drag preview and drop use the same symmetric midpoint logic. Tap/click two teams in the same zone to swap.
  </div>

  <script>
    /* ==============================
       1) GROUPS
    ============================== */
    const DEFAULT_GROUPS = {
      A: ["Mexico","South Africa","South Korea","UFEA Path D"],
      B: ["Canada","UFEA Path A","Qatar","Switzerland"],
      C: ["Brazil","Morocco","Haiti","Scotland"],
      D: ["United States","Paraguay","Australia","UFEA Path C"],
      E: ["Germany","Curaçao","Ivory Coast","Ecuador"],
      F: ["Netherlands","Japan","UFEA Path B","Tunisia"],
      G: ["Belgium","Egypt","Iran","New Zealand"],
      H: ["Spain","Cape Verde","Saudi Arabia","Uruguay"],
      I: ["France","Senegal","FIFA IC Path 2","Norway"],
      J: ["Argentina","Algeria","Austria","Jordan"],
      K: ["Portugal","FIFA IC Path 1","Uzbekistan","Colombia"],
      L: ["England","Croatia","Ghana","Panama"]
    };

    /* ==============================
       2) PATHS (Pools)
    ============================== */
    const PATHS = [
      { id: "ufeapath-a", label: "UFEA Path A",
        candidates: ["Wales", "Bosnia and Herzegovina", "Italy", "Northern Ireland"], group: "B" },
      { id: "ufeapath-b", label: "UFEA Path B",
        candidates: ["Ukraine", "Sweden", "Poland", "Albania"], group: "F" },
      { id: "ufeapath-c", label: "UFEA Path C",
        candidates: ["Slovakia", "Kosovo", "Turkey", "Romania"], group: "D" },
      { id: "ufeapath-d", label: "UFEA Path D",
        candidates: ["Czech Republic", "Republic of Ireland", "Denmark", "North Macedonia"], group: "A" },
      { id: "fifaicpath-1", label: "FIFA IC Path 1",
        candidates: ["New Caledonia", "Jamaica", "DR Congo"], group: "K" },
      { id: "fifaicpath-2", label: "FIFA IC Path 2",
        candidates: ["Bolivia", "Suriname", "Iraq"], group: "I" }
    ];

    const PATH_BY_ID = Object.fromEntries(PATHS.map(p => [p.id, p]));
    const PATH_ID_BY_LABEL = Object.fromEntries(PATHS.map(p => [p.label, p.id]));
    const GROUP_KEYS = Object.keys(DEFAULT_GROUPS);

    const toId = (name) =>
      name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");

    /* ==============================
       3) Stage + swap state
    ============================== */
    let stage = "pools"; // "pools" -> "groups"
    let swapSelection = null; // { teamId, zone }

    /* ==============================
       4) State
    ============================== */
    const initialState = () => {
      const paths = {};
      PATHS.forEach(p => {
        paths[p.id] = p.candidates.map(name => ({
          id: toId(`${p.id}-${name}`),
          name,
          tag: p.label,
          originPathId: p.id,
          isQualified: false,
          isEliminated: false
        }));
      });

      const groups = {};
      GROUP_KEYS.forEach(g => {
        groups[g] = DEFAULT_GROUPS[g].map(entryName => {
          const pathId = PATH_ID_BY_LABEL[entryName];
          if(pathId){
            return {
              id: `ph-${pathId}-${g}`,
              name: entryName,
              tag: "Placeholder",
              isPlaceholder: true,
              pathId
            };
          }
          return {
            id: toId(`${g}-${entryName}`),
            name: entryName,
            tag: `Group ${g}`
          };
        });
      });

      const qualifiedByPath = {};
      PATHS.forEach(p => { qualifiedByPath[p.id] = false; });

      return { paths, groups, qualifiedByPath };
    };

    let state = initialState();

    /* ==============================
       5) Zones
    ============================== */
    const pathZones = PATHS.map(p => `path-${p.id}`);
    const groupZones = GROUP_KEYS.map(g => `group-${g}`);
    const zones = [...pathZones, ...groupZones];

    const isPathZone = (z) => z.startsWith("path-");
    const isGroupZone = (z) => z.startsWith("group-");
    const pathIdFromZone = (z) => z.replace("path-","");
    const groupKeyFromZone = (z) => {
      const m = z.match(/^group-([A-L])$/);
      return m ? m[1] : null;
    };

    /* ==============================
       6) UI build
    ============================== */
    function makeSeparator(text, withFormButton=false){
      const sep = document.createElement("div");
      sep.className = "stage-separator";

      const left = document.createElement("div");
      left.className = "stage-left";
      left.innerHTML = `
        <span class="stage-title">${text}</span>
        <span class="stage-line"></span>
      `;
      sep.appendChild(left);

      if(withFormButton){
        const btn = document.createElement("button");
        btn.id = "formGroupsBtn";
        btn.textContent = "Form Groups";
        sep.appendChild(btn);
      }
      return sep;
    }

    function makeColumn(title, zoneKey, subtitle = ""){
      const col = document.createElement("section");
      col.className = "column";
      col.innerHTML = `
        <div class="column-header">
          <div class="column-title">${title}${subtitle ? ` • ${subtitle}` : ""}</div>
          <div class="count" data-count-for="${zoneKey}"></div>
        </div>
        <div class="dropzone" data-zone="${zoneKey}"></div>
      `;
      return col;
    }

    function buildBoard(){
      const board = document.getElementById("board");
      board.innerHTML = "";

      board.appendChild(makeSeparator("Qualifier Pools (rank by dragging)"));
      PATHS.forEach(p => {
        board.appendChild(makeColumn(p.label, `path-${p.id}`, `feeds Group ${p.group}`));
      });

      board.appendChild(makeSeparator("Groups (unlock after Form Groups)", true));
      GROUP_KEYS.forEach(g => {
        board.appendChild(makeColumn(`Group ${g}`, `group-${g}`));
      });
    }

    /* ==============================
       7) Data access
    ============================== */
    function getZoneArray(zoneKey){
      if(isPathZone(zoneKey)){
        return state.paths[pathIdFromZone(zoneKey)];
      }
      if(isGroupZone(zoneKey)){
        return state.groups[groupKeyFromZone(zoneKey)];
      }
      return null;
    }

    function isDragEnabledForZone(zoneKey){
      if(stage === "pools") return isPathZone(zoneKey);
      if(stage === "groups") return isGroupZone(zoneKey);
      return false;
    }

    function updateStagePill(){
      const pill = document.getElementById("stagePill");
      if(!pill) return;
      pill.textContent = stage === "pools" ? "Stage: Pools" : "Stage: Groups";
    }

    /* ==============================
       8) Render
    ============================== */
    function render(){
      zones.forEach(zone => {
        const dz = document.querySelector(`.dropzone[data-zone="${zone}"]`);
        if(!dz) return;

        dz.innerHTML = "";
        const arr = getZoneArray(zone) ?? [];
        const gKey = isGroupZone(zone) ? groupKeyFromZone(zone) : null;

        arr.forEach((team, idx) => {
          const card = document.createElement("div");
          card.className = "card";
          card.dataset.id = team.id;
          card.dataset.zone = zone;

          applyRankHighlight(card, zone, idx, team);

          if(swapSelection && swapSelection.teamId === team.id && swapSelection.zone === zone){
            card.classList.add("swap-armed");
          }

          let tagText = team.tag ?? "";

          if(isPathZone(zone)){
            if(stage === "groups"){
              tagText = team.isQualified ? "Qualified" : "Eliminated";
            } else {
              tagText = team.tag ?? "";
            }
          }

          if(isGroupZone(zone)){
            if(team.isPlaceholder){
              tagText = "Placeholder";
            } else {
              tagText = `${gKey}${idx + 1}`;
            }
          }

          card.innerHTML = `
            <span class="name">${team.name}</span>
            <span class="tag">${tagText}</span>
          `;

          const canDrag = !team.isPlaceholder && isDragEnabledForZone(zone);

          if(canDrag){
            attachPointerDrag(card);
          } else if(!team.isPlaceholder) {
            attachTapOnly(card);
          }

          dz.appendChild(card);
        });

        const countEl = document.querySelector(`[data-count-for="${zone}"]`);
        if(countEl){
          countEl.textContent = `${arr.length} team${arr.length !== 1 ? "s" : ""}`;
        }
      });

      const formBtn = document.getElementById("formGroupsBtn");
      if(formBtn){
        formBtn.disabled = (stage === "groups");
      }

      updateStagePill();
    }

    function applyRankHighlight(cardEl, zone, idx, team){
      cardEl.classList.remove("rank-strong", "rank-mild", "qualified", "eliminated");

      if(isPathZone(zone)){
        if(idx === 0) cardEl.classList.add("rank-strong");

        if(stage === "groups"){
          if(team.isQualified) cardEl.classList.add("qualified");
          if(team.isEliminated) cardEl.classList.add("eliminated");
        }
        return;
      }

      if(isGroupZone(zone)){
        if(idx === 0 || idx === 1) cardEl.classList.add("rank-strong");
        else if(idx === 2) cardEl.classList.add("rank-mild");
      }
    }

    /* ==============================
       9) Tap-to-swap logic
    ============================== */
    function handleTapSwap(teamId, zone){
      if(!swapSelection){
        swapSelection = { teamId, zone };
        render();
        return;
      }

      if(swapSelection.teamId === teamId && swapSelection.zone === zone){
        swapSelection = null;
        render();
        return;
      }

      if(swapSelection.zone !== zone){
        swapSelection = { teamId, zone };
        render();
        return;
      }

      swapTeamsInZone(zone, swapSelection.teamId, teamId);
      swapSelection = null;
      render();
    }

    function swapTeamsInZone(zoneKey, id1, id2){
      const arr = getZoneArray(zoneKey);
      if(!arr) return;

      const i1 = arr.findIndex(t => t.id === id1);
      const i2 = arr.findIndex(t => t.id === id2);
      if(i1 === -1 || i2 === -1) return;

      [arr[i1], arr[i2]] = [arr[i2], arr[i1]];
    }

    function attachTapOnly(card){
      card.addEventListener("click", () => {
        handleTapSwap(card.dataset.id, card.dataset.zone);
      });
    }

    /* ==============================
       10) Find team helper
    ============================== */
    function findTeamAndZone(teamId){
      for(const z of zones){
        const arr = getZoneArray(z);
        if(!arr) continue;
        const idx = arr.findIndex(t => t.id === teamId);
        if(idx !== -1) return { zone: z, index: idx, team: arr[idx] };
      }
      return null;
    }

    /* ==============================
       11) Symmetric insertion computation
       - SINGLE source of truth for:
         * preview highlight
         * reorder index
       - Uses midpoint rule only (no "inside-rect" bias)
    ============================== */
    function computeInsertion(zoneEl, clientY, draggedId){
      const cards = [...zoneEl.querySelectorAll(".card")]
        .filter(c => c.dataset.id && c.dataset.id !== draggedId);

      // Index in "remaining list" space
      let insertIndex = cards.length;
      let targetCard = null;

      for(let i = 0; i < cards.length; i++){
        const r = cards[i].getBoundingClientRect();
        const mid = r.top + r.height / 2;

        if(clientY < mid){
          insertIndex = i;
          targetCard = cards[i];
          break;
        }
      }

      // If inserting at end, highlight last card as reference (optional but clearer)
      if(!targetCard && cards.length){
        targetCard = cards[cards.length - 1];
      }

      return { insertIndex, targetCard };
    }

    function reorderWithinZone(teamId, zoneEl, clientY){
      const zoneKey = zoneEl.dataset.zone;
      const arr = getZoneArray(zoneKey);
      if(!arr) return;

      const found = findTeamAndZone(teamId);
      if(!found || found.zone !== zoneKey) return;

      const fromIndex = found.index;
      const { insertIndex } = computeInsertion(zoneEl, clientY, teamId);

      // Remove then insert using index relative to remaining list
      const [team] = arr.splice(fromIndex, 1);
      arr.splice(insertIndex, 0, team);
    }

    /* ==============================
       12) Drag target preview helpers
    ============================== */
    function clearDragTargets(){
      document.querySelectorAll(".drag-target")
        .forEach(el => el.classList.remove("drag-target"));
    }

    function updateDragPreview(zoneEl, clientY, draggedId){
      clearDragTargets();
      const { targetCard } = computeInsertion(zoneEl, clientY, draggedId);
      if(targetCard) targetCard.classList.add("drag-target");
    }

    /* ==============================
       13) Form Groups (COPY, don't move)
    ============================== */
    function groupHasPlaceholder(groupKey, pathId){
      return state.groups[groupKey].some(t => t.isPlaceholder && t.pathId === pathId);
    }

    function replacePlaceholderWithTeam(groupKey, pathId, chosenTeam){
      const arr = state.groups[groupKey];

      const idx = arr.findIndex(t => t.isPlaceholder && t.pathId === pathId);
      const insertionIndex = (idx === -1) ? arr.length : idx;

      if(idx !== -1) arr.splice(idx, 1);

      arr.splice(insertionIndex, 0, {
        id: toId(`grp-${groupKey}-${pathId}-${chosenTeam.name}`),
        name: chosenTeam.name,
        tag: PATH_BY_ID[pathId].label,
        chosenFromPath: true
      });
    }

    function markQualifiedAndEliminated(pathId){
      const pathArr = state.paths[pathId];
      if(!pathArr || pathArr.length === 0) return;

      pathArr.forEach((t, i) => {
        t.isQualified = (i === 0);
        t.isEliminated = (i !== 0);
      });

      state.qualifiedByPath[pathId] = true;
    }

    function formGroupsFromPools(){
      PATHS.forEach(p => {
        const pathArr = state.paths[p.id];
        if(!pathArr || pathArr.length === 0) return;

        const chosen = pathArr[0];
        if(!groupHasPlaceholder(p.group, p.id)) return;

        replacePlaceholderWithTeam(p.group, p.id, chosen);
        markQualifiedAndEliminated(p.id);
      });

      stage = "groups";
      swapSelection = null;
      render();
    }

    /* ==============================
       14) Pointer drag engine with tap detection
    ============================== */
    function zoneFromPoint(x, y){
      const all = [...document.querySelectorAll(".dropzone")];
      return all.find(dz => {
        const r = dz.getBoundingClientRect();
        return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
      });
    }

    let dragging = null;
    const TAP_MOVE_PX = 6;

    function attachPointerDrag(card){
      card.addEventListener("pointerdown", (e) => {
        if(e.button !== undefined && e.button !== 0) return;
        e.preventDefault();

        const teamId = card.dataset.id;
        const fromZone = card.dataset.zone;

        if(!isDragEnabledForZone(fromZone)) return;

        const rect = card.getBoundingClientRect();

        const clone = card.cloneNode(true);
        clone.classList.add("drag-clone");
        document.body.appendChild(clone);

        card.classList.add("dragging");

        dragging = {
          teamId,
          originCard: card,
          clone,
          pointerId: e.pointerId,
          fromZone,
          offsetX: e.clientX - (rect.left + rect.width / 2),
          offsetY: e.clientY - (rect.top + rect.height / 2),
          startX: e.clientX,
          startY: e.clientY,
          moved: false
        };

        card.setPointerCapture(e.pointerId);
        positionClone(e.clientX, e.clientY);
      });

      card.addEventListener("pointermove", (e) => {
        if(!dragging || dragging.pointerId !== e.pointerId) return;
        e.preventDefault();

        positionClone(e.clientX, e.clientY);

        const dx = Math.abs(e.clientX - dragging.startX);
        const dy = Math.abs(e.clientY - dragging.startY);
        if(dx > TAP_MOVE_PX || dy > TAP_MOVE_PX){
          dragging.moved = true;
        }

        if(dragging.moved){
          const zoneEl = zoneFromPoint(e.clientX, e.clientY);

          document.querySelectorAll(".dropzone")
            .forEach(z => z.classList.remove("over"));

          if(zoneEl && zoneEl.dataset.zone === dragging.fromZone){
            zoneEl.classList.add("over");
            updateDragPreview(zoneEl, e.clientY, dragging.teamId);
          } else {
            clearDragTargets();
          }
        }
      });

      card.addEventListener("pointerup", (e) => {
        if(!dragging || dragging.pointerId !== e.pointerId) return;
        e.preventDefault();
        finishDrag(e.clientX, e.clientY);
      });

      card.addEventListener("pointercancel", (e) => {
        if(!dragging || dragging.pointerId !== e.pointerId) return;
        finishDrag(null, null, true);
      });
    }

    function positionClone(x, y){
      if(!dragging) return;
      dragging.clone.style.left = `${x - dragging.offsetX}px`;
      dragging.clone.style.top  = `${y - dragging.offsetY}px`;
    }

    function finishDrag(x, y, cancelled=false){
      const { teamId, originCard, clone, fromZone, moved } = dragging;

      clearDragTargets();
      document.querySelectorAll(".dropzone")
        .forEach(z => z.classList.remove("over"));

      originCard.classList.remove("dragging");
      clone.remove();

      if(!cancelled){
        // Tap without movement = swap selection
        if(!moved){
          handleTapSwap(teamId, fromZone);
          dragging = null;
          return;
        }

        if(x !== null && y !== null){
          const zoneEl = zoneFromPoint(x, y);
          if(zoneEl){
            const toZone = zoneEl.dataset.zone;

            if(toZone === fromZone){
              reorderWithinZone(teamId, zoneEl, y);
              render();
            }
          }
        }
      }

      dragging = null;
    }

    /* ==============================
       15) Buttons + boot
    ============================== */
    function wireButtons(){
      const formBtn = document.getElementById("formGroupsBtn");
      if(formBtn){
        formBtn.addEventListener("click", () => {
          if(stage === "groups") return;
          formGroupsFromPools();
        });
      }

      const resetBtn = document.getElementById("resetBtn");
      if(resetBtn){
        resetBtn.addEventListener("click", () => {
          state = initialState();
          stage = "pools";
          swapSelection = null;
          buildBoard();
          render();
          wireButtons();
        });
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      buildBoard();
      render();
      wireButtons();
    });
  </script>
</body>
</html>
