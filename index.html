<!doctype html>
<html lang="en">
<head>
  <!-- =========================================================
       HEAD
       - Meta
       - Title
       - Viewport
       - Styles (theme + layout + drag UX)
  ========================================================== -->
  <meta charset="utf-8" />
  <title>World Cup 2026 Groups Drag-Drop (Mobile Safe Base)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    /* =========================================================
       CSS MAP
       1) Theme variables
       2) Global/base
       3) Header
       4) Board grid
       5) Column + dropzone
       6) Cards
       7) Drag states
       8) Buttons + footer
    ========================================================== */

    /* 1) Theme variables */
    :root{
      --bg:#0f1220;
      --panel:#151a2e;
      --panel-2:#111527;
      --text:#f5f7ff;
      --muted:#b9c0e6;
      --accent:#7aa2ff;
      --border:rgba(255,255,255,0.08);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;
    }

    /* 2) Global/base */
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: radial-gradient(1200px 800px at 10% 10%, #1c2342 0%, var(--bg) 40%, #070912 100%);
      min-height:100vh;
    }

    /* 3) Header */
    header{
      padding: 18px 20px 0 20px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap: wrap;
    }
    header h1{
      font-size: 18px;
      font-weight: 650;
      margin:0 0 2px 0;
      letter-spacing:0.2px;
    }
    header .hint{
      color:var(--muted);
      font-size: 11.5px;
    }
    .actions{
      display:flex;
      gap:8px;
      align-items:center;
    }

    /* 4) Board grid */
    .board{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
      padding: 14px 16px 30px 16px;
    }
    @media (min-width: 780px){
      .board{ grid-template-columns: 1fr 1fr; }
    }
    @media (min-width: 1100px){
      .board{ grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (min-width: 1400px){
      .board{ grid-template-columns: 1fr 1fr 1fr 1fr; }
    }

    /* 5) Column + dropzone */
    .column{
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      min-height: 180px;
      display:flex;
      flex-direction:column;
    }
    .column-header{
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid var(--border);
      gap: 10px;
    }
    .column-title{
      font-size: 12.5px;
      letter-spacing: 0.35px;
      text-transform: uppercase;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 70%;
    }
    .count{
      font-size: 10.5px;
      color: var(--muted);
      opacity: 0.9;
      white-space: nowrap;
    }

    .dropzone{
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
      flex: 1;
      transition: background 120ms ease, outline 120ms ease;
    }
    .dropzone.over{
      background: rgba(122,162,255,0.08);
      outline: 1px dashed rgba(122,162,255,0.5);
      outline-offset: -6px;
    }

    /* 6) Cards */
    .card{
      background: rgba(255,255,255,0.04);
      border:1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      cursor: grab;
      user-select: none;

      /* ✅ Critical mobile fix */
      touch-action: none;

      transition: transform 80ms ease, background 120ms ease, border-color 120ms ease;
    }
    .card:active{ cursor: grabbing; }

    .name{
      font-size: 13.8px;
      font-weight: 560;
      letter-spacing: 0.1px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .tag{
      font-size: 9.5px;
      color: var(--muted);
      border:1px solid var(--border);
      padding: 3px 6px;
      border-radius: 999px;
      white-space: nowrap;
    }

    /* 7) Drag states */
    .dragging{ opacity: 0.35; }

    .drag-clone{
      position: fixed;
      z-index: 9999;
      pointer-events: none;
      width: min(340px, 88vw);
      transform: translate(-50%, -50%);
      box-shadow: 0 18px 45px rgba(0,0,0,0.5);
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(8px);
    }

    /* 8) Buttons + footer */
    button{
      background: rgba(122,162,255,0.12);
      color: var(--text);
      border: 1px solid rgba(122,162,255,0.35);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 11px;
      cursor: pointer;
    }
    button:hover{
      background: rgba(122,162,255,0.18);
    }
    .footer{
      padding: 0 16px 24px 16px;
      color: var(--muted);
      font-size: 11px;
    }
  </style>
</head>

<body>
  <!-- =========================================================
       BODY / HTML STRUCTURE
       1) Header + actions
       2) Dynamic board container
       3) Footer
  ========================================================== -->

  <header>
    <div>
      <h1>World Cup 2026 Groups – Drag & Drop Base</h1>
      <div class="hint">Uses Pointer Events for reliable mobile dragging.</div>
    </div>
    <div class="actions">
      <button id="resetBtn">Reset Groups</button>
      <button id="clearPoolBtn">Clear Pool</button>
    </div>
  </header>

  <!-- Board will be built dynamically from DEFAULT_GROUPS -->
  <main class="board" id="board"></main>

  <div class="footer">
    This is a stable foundation. Next upgrades: group capacity rules (max 4), pool auto-fill, standings, and 3rd-place ranking.
  </div>

  <script>
  /* =========================================================
   World Cup 2026 Groups Drag/Drop
   + Playoff Pools (Paths) BEFORE group stage
   + Placeholder rename rules:
       "European Playoff X" -> "UFEA Path X"
       "FIFA Intercontinental Playoff Tournament X" -> "FIFA IC Path X"
   + One team can be chosen from each path:
       Drag a candidate from a Path column into its assigned Group.
       The placeholder in that Group is replaced by the chosen team.

   Assumes your HTML has:
     <main class="board" id="board"></main>

   Optional:
     <button id="resetBtn">Reset</button>

   CSS expectation (already in your base):
     .card { touch-action: none; }  // critical for mobile drag

========================================================= */


/* ---------------------------------------------------------
   1) GROUPS with UPDATED placeholder names
--------------------------------------------------------- */
const DEFAULT_GROUPS = {
  A: ["Mexico","South Africa","South Korea","UFEA Path D"],
  B: ["Canada","UFEA Path A","Qatar","Switzerland"],
  C: ["Brazil","Morocco","Haiti","Scotland"],
  D: ["United States","Paraguay","Australia","UFEA Path C"],
  E: ["Germany","Curaçao","Ivory Coast","Ecuador"],
  F: ["Netherlands","Japan","UFEA Path B","Tunisia"],
  G: ["Belgium","Egypt","Iran","New Zealand"],
  H: ["Spain","Cape Verde","Saudi Arabia","Uruguay"],
  I: ["France","Senegal","FIFA IC Path 2","Norway"],
  J: ["Argentina","Algeria","Austria","Jordan"],
  K: ["Portugal","FIFA IC Path 1","Uzbekistan","Colombia"],
  L: ["England","Croatia","Ghana","Panama"]
};


/* ---------------------------------------------------------
   2) PATH POOLS (your data) + where they feed into groups
--------------------------------------------------------- */
const PATHS = [
  {
    id: "ufeapath-a",
    label: "UFEA Path A",
    candidates: ["Wales", "Bosnia and Herzegovina", "Italy", "Northern Ireland"],
    group: "B"
  },
  {
    id: "ufeapath-b",
    label: "UFEA Path B",
    candidates: ["Ukraine", "Sweden", "Poland", "Albania"],
    group: "F"
  },
  {
    id: "ufeapath-c",
    label: "UFEA Path C",
    candidates: ["Slovakia", "Kosovo", "Turkey", "Romania"],
    group: "D"
  },
  {
    id: "ufeapath-d",
    label: "UFEA Path D",
    candidates: ["Czech Republic", "Republic of Ireland", "Denmark", "North Macedonia"],
    group: "A"
  },
  {
    id: "fifaicpath-1",
    label: "FIFA IC Path 1",
    candidates: ["New Caledonia", "Jamaica", "DR Congo"],
    group: "K"
  },
  {
    id: "fifaicpath-2",
    label: "FIFA IC Path 2",
    candidates: ["Bolivia", "Suriname", "Iraq"],
    group: "I"
  }
];

const PATH_BY_ID = Object.fromEntries(PATHS.map(p => [p.id, p]));
const PATH_ID_BY_LABEL = Object.fromEntries(PATHS.map(p => [p.label, p.id]));


/* ---------------------------------------------------------
   3) Helpers
--------------------------------------------------------- */
const GROUP_KEYS = Object.keys(DEFAULT_GROUPS);

const toId = (name) =>
  name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");


/* ---------------------------------------------------------
   4) State construction
     - state.paths[pathId] = candidate team objects
     - state.groups[groupLetter] = group teams with placeholders
--------------------------------------------------------- */
const initialState = () => {
  const paths = {};
  PATHS.forEach(p => {
    paths[p.id] = p.candidates.map(name => ({
      id: toId(`${p.id}-${name}`),
      name,
      tag: p.label,
      originPathId: p.id
    }));
  });

  const groups = {};
  GROUP_KEYS.forEach(g => {
    groups[g] = DEFAULT_GROUPS[g].map(entryName => {
      const pathId = PATH_ID_BY_LABEL[entryName];

      // If this entry is a placeholder label, store as placeholder object
      if (pathId) {
        return {
          id: `ph-${pathId}-${g}`,
          name: entryName,
          tag: "Placeholder",
          isPlaceholder: true,
          pathId
        };
      }

      // Normal fixed team
      return {
        id: toId(`${g}-${entryName}`),
        name: entryName,
        tag: `Group ${g}`
      };
    });
  });

  return { paths, groups };
};

let state = initialState();


/* ---------------------------------------------------------
   5) Zones
     - Path zones appear first
     - Then group zones A–L
--------------------------------------------------------- */
const pathZones = PATHS.map(p => `path-${p.id}`);
const groupZones = GROUP_KEYS.map(g => `group-${g}`);
const zones = [...pathZones, ...groupZones];


/* ---------------------------------------------------------
   6) Board builder (dynamic columns)
--------------------------------------------------------- */
function makeColumn(title, zoneKey, subtitle = ""){
  const col = document.createElement("section");
  col.className = "column";

  col.innerHTML = `
    <div class="column-header">
      <div class="column-title">${title}${subtitle ? ` • ${subtitle}` : ""}</div>
      <div class="count" data-count-for="${zoneKey}"></div>
    </div>
    <div class="dropzone" data-zone="${zoneKey}"></div>
  `;

  return col;
}

function buildBoard(){
  const board = document.getElementById("board");
  if(!board) return;

  board.innerHTML = "";

  // ---- Paths first (pooling stage) ----
  PATHS.forEach(p => {
    board.appendChild(makeColumn(p.label, `path-${p.id}`, `feeds Group ${p.group}`));
  });

  // ---- Groups next ----
  GROUP_KEYS.forEach(g => {
    board.appendChild(makeColumn(`Group ${g}`, `group-${g}`));
  });
}


/* ---------------------------------------------------------
   7) Zone access
--------------------------------------------------------- */
function getZoneArray(zoneKey){
  // Path zone
  if(zoneKey.startsWith("path-")){
    const id = zoneKey.replace("path-", "");
    return state.paths[id];
  }

  // Group zone
  const gm = zoneKey.match(/^group-([A-L])$/);
  if(gm){
    return state.groups[gm[1]];
  }

  return null;
}

function isPathZone(zoneKey){
  return zoneKey.startsWith("path-");
}
function isGroupZone(zoneKey){
  return zoneKey.startsWith("group-");
}
function pathIdFromZone(zoneKey){
  return zoneKey.replace("path-", "");
}
function groupKeyFromZone(zoneKey){
  const m = zoneKey.match(/^group-([A-L])$/);
  return m ? m[1] : null;
}


/* ---------------------------------------------------------
   8) Render
--------------------------------------------------------- */
function render(){
  zones.forEach(zone => {
    const dz = document.querySelector(`.dropzone[data-zone="${zone}"]`);
    if(!dz) return;

    dz.innerHTML = "";

    const arr = getZoneArray(zone) ?? [];

    arr.forEach(team => {
      const card = document.createElement("div");
      card.className = "card";
      card.dataset.id = team.id;
      card.dataset.zone = zone;

      card.innerHTML = `
        <span class="name">${team.name}</span>
        <span class="tag">${team.tag ?? ""}</span>
      `;

      // Do NOT make placeholders draggable
      if(!team.isPlaceholder){
        attachPointerDrag(card);
      }

      dz.appendChild(card);
    });

    const countEl = document.querySelector(`[data-count-for="${zone}"]`);
    if(countEl){
      countEl.textContent = `${arr.length} item${arr.length !== 1 ? "s" : ""}`;
    }
  });
}


/* ---------------------------------------------------------
   9) Find + move logic
     Key rule enforcement:
     - Only ONE selection from each Path
     - Selection is done by dragging a candidate
       from Path zone into its assigned Group zone.
     - On selection:
         * remove placeholder in that group
         * remove chosen team from path candidates
         * add chosen team into group
     - If placeholder already gone, further drops
       from same path into the group are rejected.
--------------------------------------------------------- */
function findTeamAndZone(teamId){
  for(const z of zones){
    const arr = getZoneArray(z);
    if(!arr) continue;

    const idx = arr.findIndex(t => t.id === teamId);
    if(idx !== -1) return { zone: z, index: idx, team: arr[idx] };
  }
  return null;
}

function groupHasPlaceholder(groupKey, pathId){
  return state.groups[groupKey].some(t => t.isPlaceholder && t.pathId === pathId);
}

function removePlaceholder(groupKey, pathId){
  const arr = state.groups[groupKey];
  const idx = arr.findIndex(t => t.isPlaceholder && t.pathId === pathId);
  if(idx !== -1) arr.splice(idx, 1);
}

/**
 * Core move function with path-selection rules.
 */
function moveTeam(teamId, toZone){
  const found = findTeamAndZone(teamId);
  if(!found) return;

  const fromZone = found.zone;
  if(fromZone === toZone) return;

  const fromArr = getZoneArray(fromZone);
  const toArr = getZoneArray(toZone);
  if(!fromArr || !toArr) return;

  // ---------------------------
  // Case 1: Selecting from a Path into a Group
  // ---------------------------
  if(isPathZone(fromZone) && isGroupZone(toZone)){
    const pathId = pathIdFromZone(fromZone);
    const path = PATH_BY_ID[pathId];
    const targetGroup = groupKeyFromZone(toZone);

    // Only allow drop into the correct assigned group
    if(!path || targetGroup !== path.group){
      return; // reject
    }

    // Only allow ONE selection (placeholder must exist)
    if(!groupHasPlaceholder(targetGroup, pathId)){
      return; // already selected; reject
    }

    // Execute selection:
    // 1) remove team from path
    const [team] = fromArr.splice(found.index, 1);

    // 2) remove placeholder in group
    removePlaceholder(targetGroup, pathId);

    // 3) add chosen team to group with a clear tag
    toArr.push({
      ...team,
      tag: path.label,
      chosenFromPath: true
    });

    render();
    return;
  }

  // ---------------------------
  // Case 2: Normal moves between groups
  // (Allowed: you can reorder by moving across groups)
  // ---------------------------
  if(isGroupZone(fromZone) && isGroupZone(toZone)){
    const [team] = fromArr.splice(found.index, 1);
    toArr.push(team);
    render();
    return;
  }

  // ---------------------------
  // Case 3: Disallow dropping group teams into path columns
  // (Keeps the "pooling stage" clean)
  // ---------------------------
  if(isGroupZone(fromZone) && isPathZone(toZone)){
    return;
  }

  // Default safe behavior
}


/* ---------------------------------------------------------
   10) Hit-testing dropzones
--------------------------------------------------------- */
function zoneFromPoint(x, y){
  const all = [...document.querySelectorAll(".dropzone")];
  return all.find(dz => {
    const r = dz.getBoundingClientRect();
    return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
  });
}


/* ---------------------------------------------------------
   11) Pointer drag engine (mobile-safe)
--------------------------------------------------------- */
let dragging = null;

function attachPointerDrag(card){
  // Start drag
  card.addEventListener("pointerdown", (e) => {
    if(e.button !== undefined && e.button !== 0) return;

    e.preventDefault();

    const teamId = card.dataset.id;
    const rect = card.getBoundingClientRect();

    const clone = card.cloneNode(true);
    clone.classList.add("drag-clone");
    document.body.appendChild(clone);

    card.classList.add("dragging");

    dragging = {
      teamId,
      originCard: card,
      clone,
      pointerId: e.pointerId,
      offsetX: e.clientX - (rect.left + rect.width / 2),
      offsetY: e.clientY - (rect.top + rect.height / 2),
      lastZoneEl: null
    };

    card.setPointerCapture(e.pointerId);
    positionClone(e.clientX, e.clientY);
  });

  // Move drag
  card.addEventListener("pointermove", (e) => {
    if(!dragging || dragging.pointerId !== e.pointerId) return;

    e.preventDefault();

    positionClone(e.clientX, e.clientY);

    const zoneEl = zoneFromPoint(e.clientX, e.clientY);

    if(zoneEl !== dragging.lastZoneEl){
      document.querySelectorAll(".dropzone")
        .forEach(z => z.classList.remove("over"));

      if(zoneEl) zoneEl.classList.add("over");

      dragging.lastZoneEl = zoneEl;
    }
  });

  // End drag
  card.addEventListener("pointerup", (e) => {
    if(!dragging || dragging.pointerId !== e.pointerId) return;
    e.preventDefault();
    finishDrag(e.clientX, e.clientY);
  });

  // Cancel drag
  card.addEventListener("pointercancel", (e) => {
    if(!dragging || dragging.pointerId !== e.pointerId) return;
    finishDrag(null, null, true);
  });
}

function positionClone(x, y){
  if(!dragging) return;
  dragging.clone.style.left = `${x - dragging.offsetX}px`;
  dragging.clone.style.top  = `${y - dragging.offsetY}px`;
}

function finishDrag(x, y, cancelled=false){
  const { teamId, originCard, clone } = dragging;

  document.querySelectorAll(".dropzone")
    .forEach(z => z.classList.remove("over"));

  originCard.classList.remove("dragging");
  clone.remove();

  if(!cancelled && x !== null && y !== null){
    const zoneEl = zoneFromPoint(x, y);
    if(zoneEl){
      moveTeam(teamId, zoneEl.dataset.zone);
    }
  }

  dragging = null;
}


/* ---------------------------------------------------------
   12) Reset wiring (optional)
--------------------------------------------------------- */
function wireReset(){
  const btn = document.getElementById("resetBtn");
  if(!btn) return;

  btn.addEventListener("click", () => {
    state = initialState();
    buildBoard();
    render();
  });
}


/* ---------------------------------------------------------
   13) Boot
--------------------------------------------------------- */
document.addEventListener("DOMContentLoaded", () => {
  buildBoard();
  render();
  wireReset();
});



  </script>
</body>
</html>
