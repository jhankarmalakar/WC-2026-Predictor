<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>World Cup 2026 – Pools → Groups → Knockouts</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg:#0f1220;
      --panel:#151a2e;
      --panel-2:#111527;
      --text:#f5f7ff;
      --muted:#b9c0e6;
      --accent:#7aa2ff;
      --accent-2:#5ee6ff;
      --border:rgba(255,255,255,0.08);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;

      /* Rank highlights */
      --hl-strong-bg: rgba(94, 230, 168, 0.14);
      --hl-strong-br: rgba(94, 230, 168, 0.45);
      --hl-mild-bg:   rgba(122, 162, 255, 0.10);
      --hl-mild-br:   rgba(122, 162, 255, 0.35);

      /* Qualified styling */
      --qualified-br: rgba(94, 230, 168, 0.55);
      --qualified-glow: rgba(94, 230, 168, 0.18);

      /* Eliminated styling */
      --elim-bg: rgba(255, 107, 122, 0.08);
      --elim-br: rgba(255, 107, 122, 0.35);

      /* Click-swap armed styling (amber) */
      --swap-bg: rgba(255, 184, 107, 0.14);
      --swap-br: rgba(255, 184, 107, 0.55);

      /* Winner highlight */
      --win-bg: rgba(122, 255, 187, 0.18);
      --win-br: rgba(122, 255, 187, 0.70);
      --win-glow: rgba(122, 255, 187, 0.22);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: radial-gradient(1200px 800px at 10% 10%, #1c2342 0%, var(--bg) 40%, #070912 100%);
      min-height:100vh;
    }

    header{
      padding: 18px 20px 8px 20px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap: wrap;
    }
    header h1{
      font-size: 18px;
      font-weight: 650;
      margin:0 0 2px 0;
    }
    header .hint{
      color:var(--muted);
      font-size: 11.5px;
      max-width: 80ch;
    }

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
    }

    .stage-pill{
      font-size: 11.5px;
      color: var(--text);
      border: 1px solid var(--border);
      padding: 9px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.05);
      letter-spacing: 0.2px;
    }

    /* Bright buttons */
    button{
      background: linear-gradient(135deg, rgba(122,162,255,0.22), rgba(94,230,255,0.12));
      color: var(--text);
      border: 1px solid rgba(122,162,255,0.55);
      padding: 11px 14px;
      border-radius: 12px;
      font-size: 12.5px;
      cursor: pointer;
      white-space: nowrap;
      box-shadow: 0 0 0 1px rgba(122,162,255,0.08) inset;
    }
    button:hover{ background: linear-gradient(135deg, rgba(122,162,255,0.30), rgba(94,230,255,0.18)); }
    button:disabled{ opacity: 0.55; cursor: not-allowed; }

    .btn-mini{
      padding: 8px 10px;
      font-size: 11px;
      border-radius: 10px;
    }

    /* Board grid */
    .board{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
      padding: 8px 16px 30px 16px;
    }
    @media (min-width: 780px){
      .board{ grid-template-columns: 1fr 1fr; }
    }
    @media (min-width: 1100px){
      .board{ grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (min-width: 1400px){
      .board{ grid-template-columns: 1fr 1fr 1fr 1fr; }
    }

    /* Stage separators */
    .stage-separator{
      grid-column: 1 / -1;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 6px 2px 6px;
      flex-wrap: wrap;
    }
    .stage-left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
      flex: 1;
    }
    .stage-title{
      font-size: 11px;
      letter-spacing: 0.35px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.55);
      white-space: nowrap;
    }
    .stage-line{
      height: 1px;
      background: var(--border);
      flex: 1;
      min-width: 30px;
    }
    .stage-right{
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap: wrap;
    }

    /* Column */
    .column{
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      min-height: 160px;
      display:flex;
      flex-direction:column;
    }
    .column-header{
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid var(--border);
      gap: 10px;
    }
    .column-title{
      font-size: 12.2px;
      letter-spacing: 0.35px;
      text-transform: uppercase;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 80%;
    }
    .count{
      font-size: 10.5px;
      color: var(--muted);
      opacity: 0.9;
      white-space: nowrap;
    }

    .zone{
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
      flex: 1;
    }

    /* Card */
    .card{
      background: rgba(255,255,255,0.04);
      border:1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      user-select: none;
      cursor: pointer;
      transition: background 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
    }
    .card.locked{
      cursor: default;
      opacity: 0.9;
    }

    .name{
      font-size: 13.8px;
      font-weight: 560;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display:flex;
      align-items:center;
      gap: 0;
      min-width: 0;
    }
    .tag{
      font-size: 9.8px;
      color: var(--muted);
      border:1px solid var(--border);
      padding: 3px 7px;
      border-radius: 999px;
      white-space: nowrap;
    }

    /* Rank highlights */
    .rank-strong{
      background: var(--hl-strong-bg);
      border-color: var(--hl-strong-br);
    }
    .rank-mild{
      background: var(--hl-mild-bg);
      border-color: var(--hl-mild-br);
    }

    /* Qualified/Eliminated */
    .qualified{
      border-color: var(--qualified-br);
      box-shadow: 0 0 0 1px var(--qualified-glow) inset;
    }
    .eliminated{
      background: var(--elim-bg);
      border-color: var(--elim-br);
    }

    /* First-click armed swap */
    .swap-armed{
      background: var(--swap-bg);
      border-color: var(--swap-br);
      box-shadow: 0 0 0 1px rgba(255,184,107,0.18) inset;
    }

    .footer{
      padding: 0 16px 24px 16px;
      color: var(--muted);
      font-size: 11px;
    }

    .top8-summary{
      margin-top: 10px;
      padding: 10px 12px;
      font-size: 14px;
      font-weight: 800;
      color: var(--text);
      border: 1px dashed var(--border);
      border-radius: 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-align: center;
      background: rgba(255,255,255,0.03);
    }

    /* Flag images */
    .flag-img{
      width: 16px;
      height: 12px;
      object-fit: cover;
      border-radius: 2px;
      margin-right: 6px;
      vertical-align: -1px;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.08);
      flex: 0 0 auto;
    }

    /* ==========================
       Knockout layout (full width)
    ========================== */
    .ko-grid{
      grid-column: 1 / -1;
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 780px){
      .ko-grid{ grid-template-columns: 1fr 1fr; }
    }
    @media (min-width: 1100px){
      .ko-grid{ grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (min-width: 1400px){
      .ko-grid{ grid-template-columns: 1fr 1fr 1fr 1fr; }
    }

    /* Centered rounds (SF/3P/Final) */
    .ko-grid.centered{
      grid-template-columns: 1fr;
      justify-items: center;
    }
    .ko-grid.centered .match-card{
      width: min(760px, 100%);
    }

    .match-card{
      background: rgba(255,255,255,0.035);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 12px 10px 12px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 10px 10px;
      align-items: center;
      position: relative;
    }

    /* Header row for KO cards */
    .match-head{
      grid-column: 1 / -1;
      text-align: center;
      font-weight: 800;
      font-size: 12.5px;
      letter-spacing: 0.4px;
      color: rgba(255,255,255,0.85);
      padding: 4px 6px 2px 6px;
    }
    .match-head .sub{
      font-weight: 600;
      font-size: 11.5px;
      color: var(--muted);
      margin-left: 6px;
    }

    .match-team{
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      font-size: 12.8px;
      cursor: pointer;
      text-align: center;
      user-select: none;
      transition: background 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
    }
    .match-team.locked{
      cursor: default;
      opacity: 0.9;
    }

    .match-team.winning{
      background: var(--win-bg);
      border-color: var(--win-br);
      box-shadow:
        0 0 0 1px var(--win-glow) inset,
        0 0 14px rgba(122,255,187,0.12);
    }

    .match-mid{
      min-width: 56px;
      text-align: center;
      font-weight: 900;
      font-size: 12.5px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
      letter-spacing: 1px;
    }

    /* Bottom meta */
    .match-bottom{
      grid-column: 1 / -1;
      display:flex;
      justify-content: space-between;
      gap: 10px;
      margin-top: 2px;
      font-size: 11.2px;
      color: var(--muted);
      flex-wrap: wrap;
    }
    .match-bottom .chip{
      display:inline-block;
      padding: 3px 7px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: rgba(255,255,255,0.04);
      font-size: 10.6px;
      white-space: nowrap;
    }

    .r32-fallback-note{
      grid-column: 1 / -1;
      margin-top: 2px;
      font-size: 10.5px;
      color: var(--muted);
      opacity: 0.9;
    }
  </style>
</head>

<body>
  <header>
    <div>
      <h1>Qualifier Pools → Form Groups → Group Tools → Knockouts</h1>
      <div class="hint">
        Click/tap two teams in the same editable zone to swap.
        Use “Form Groups” to copy pool winners into groups.
        Knockout winners are validated every render — changing an early result automatically clears later winners.
      </div>
    </div>

    <div class="actions">
      <span class="stage-pill" id="stagePill">Edit: Pools</span>
      <button id="reformPoolBtn" disabled>Reform Pool</button>
      <button id="resetBtn">Reset</button>
    </div>
  </header>

  <main class="board" id="board"></main>

  <div class="footer">
    Pools editable only in Pool mode. Groups + Third-place ranking editable only in Group mode.
  </div>

  <script>
    /* ==============================
       1) GROUPS + PATHS
    ============================== */
    const DEFAULT_GROUPS = {
      A: ["Mexico","South Africa","South Korea","UFEA Path D"],
      B: ["Canada","UFEA Path A","Qatar","Switzerland"],
      C: ["Brazil","Morocco","Haiti","Scotland"],
      D: ["United States","Paraguay","Australia","UFEA Path C"],
      E: ["Germany","Curaçao","Ivory Coast","Ecuador"],
      F: ["Netherlands","Japan","UFEA Path B","Tunisia"],
      G: ["Belgium","Egypt","Iran","New Zealand"],
      H: ["Spain","Cape Verde","Saudi Arabia","Uruguay"],
      I: ["France","Senegal","FIFA IC Path 2","Norway"],
      J: ["Argentina","Algeria","Austria","Jordan"],
      K: ["Portugal","FIFA IC Path 1","Uzbekistan","Colombia"],
      L: ["England","Croatia","Ghana","Panama"]
    };

    const PATHS = [
      { id: "ufeapath-a", label: "UFEA Path A",
        candidates: ["Wales", "Bosnia and Herzegovina", "Italy", "Northern Ireland"], group: "B" },
      { id: "ufeapath-b", label: "UFEA Path B",
        candidates: ["Ukraine", "Sweden", "Poland", "Albania"], group: "F" },
      { id: "ufeapath-c", label: "UFEA Path C",
        candidates: ["Slovakia", "Kosovo", "Turkey", "Romania"], group: "D" },
      { id: "ufeapath-d", label: "UFEA Path D",
        candidates: ["Czech Republic", "Republic of Ireland", "Denmark", "North Macedonia"], group: "A" },
      { id: "fifaicpath-1", label: "FIFA IC Path 1",
        candidates: ["New Caledonia", "Jamaica", "DR Congo"], group: "K" },
      { id: "fifaicpath-2", label: "FIFA IC Path 2",
        candidates: ["Bolivia", "Suriname", "Iraq"], group: "I" }
    ];

    const PATH_BY_ID = Object.fromEntries(PATHS.map(p => [p.id, p]));
    const PATH_ID_BY_LABEL = Object.fromEntries(PATHS.map(p => [p.label, p.id]));
    const GROUP_KEYS = Object.keys(DEFAULT_GROUPS);

    const toId = (name) =>
      String(name || "")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/(^-|-$)/g, "");

    /* ==============================
       2) Rank + odds models (AUTO)
    ============================== */
    const RANK_BY_NAME = {
      "Spain":1,
      "Argentina":2,
      "France":3,
      "England":4,
      "Brazil":5,
      "Portugal":6,
      "Netherlands":7,
      "Belgium":8,
      "Germany":9,
      "Croatia":10,
      "Morocco":11,
      "Italy":12,
      "Colombia":13,
      "United States":14,
      "USA":14,
      "Mexico":15,
      "Uruguay":16,
      "Switzerland":17,
      "Japan":18,
      "Senegal":19,
      "Iran":20,
      "Denmark":21,
      "South Korea":22,
      "Ecuador":23,
      "Austria":24,
      "Turkey":25,
      "Türkiye":25,
      "Australia":26,
      "Canada":27,
      "Ukraine":28,
      "Norway":29,
      "Panama":30,
      "Poland":31,
      "Wales":32,
      "Scotland":36,
      "Serbia":37,
      "Nigeria":38,
      "Czechia":39,
      "Czech Republic":39,
      "Tunisia":40,
      "Ivory Coast":42,
      "Côte d'Ivoire":42,
      "Sweden":43,
      "Slovakia":45,
      "Romania":47,
      "Uzbekistan":50,
      "Qatar":51,
      "Saudi Arabia":60,
      "South Africa":61,
      "Albania":63,
      "Jordan":64,
      "Cape Verde":68,
      "Cabo Verde":68,
      "Jamaica":70,
      "Kosovo":80,
      "Curaçao":82,
      "New Zealand":104
    };

    const ODDS_POSITIVE = {
      "Spain": 400,
      "England": 550,
      "France": 700,
      "Brazil": 750,
      "Argentina": 800,
      "Germany": 1200,
      "Portugal": 1200,
      "Netherlands": 1200
    };

    function rankOf(name){
      if(!name) return 999;
      // strip flag placeholders or labels
      return RANK_BY_NAME[name] ?? 999;
    }

    function impliedProbFromPositiveOdds(x){
      // +400 => 100/(400+100) = 0.2
      return 100 / (x + 100);
    }

    function pickWinnerNameAuto(a, b){
      // deterministic for all unless BOTH are in odds set
      const aOdds = ODDS_POSITIVE[a];
      const bOdds = ODDS_POSITIVE[b];

      if(aOdds && bOdds){
        const pa = impliedProbFromPositiveOdds(aOdds);
        const pb = impliedProbFromPositiveOdds(bOdds);
        const sum = pa + pb;
        const ra = pa / sum;
        return Math.random() < ra ? a : b;
      }

      // otherwise deterministic by rank
      const ra = rankOf(a);
      const rb = rankOf(b);
      if(ra === rb){
        // stable tie-break
        return String(a).localeCompare(String(b)) <= 0 ? a : b;
      }
      return ra < rb ? a : b;
    }

    /* ==============================
       3) Flags (image-based)
    ============================== */
    const FLAG_CODE_BY_NAME = {
      "Mexico":"mx",
      "South Africa":"za",
      "South Korea":"kr",
      "Canada":"ca",
      "Qatar":"qa",
      "Switzerland":"ch",
      "Brazil":"br",
      "Morocco":"ma",
      "Haiti":"ht",
      "Scotland":"gb",
      "United States":"us",
      "United States of America":"us",
      "USA":"us",
      "Paraguay":"py",
      "Australia":"au",
      "Germany":"de",
      "Curaçao":"cw",
      "Ivory Coast":"ci",
      "Côte d'Ivoire":"ci",
      "Ecuador":"ec",
      "Netherlands":"nl",
      "Japan":"jp",
      "Tunisia":"tn",
      "Belgium":"be",
      "Egypt":"eg",
      "Iran":"ir",
      "New Zealand":"nz",
      "Spain":"es",
      "Cape Verde":"cv",
      "Cabo Verde":"cv",
      "Saudi Arabia":"sa",
      "Uruguay":"uy",
      "France":"fr",
      "Senegal":"sn",
      "Norway":"no",
      "Argentina":"ar",
      "Algeria":"dz",
      "Austria":"at",
      "Jordan":"jo",
      "Portugal":"pt",
      "Uzbekistan":"uz",
      "Colombia":"co",
      "England":"gb",
      "Croatia":"hr",
      "Ghana":"gh",
      "Panama":"pa",
      "Wales":"gb",
      "Bosnia and Herzegovina":"ba",
      "Italy":"it",
      "Northern Ireland":"gb",
      "Ukraine":"ua",
      "Sweden":"se",
      "Poland":"pl",
      "Albania":"al",
      "Slovakia":"sk",
      "Kosovo":"xk",
      "Turkey":"tr",
      "Türkiye":"tr",
      "Romania":"ro",
      "Czech Republic":"cz",
      "Czechia":"cz",
      "Republic of Ireland":"ie",
      "Denmark":"dk",
      "North Macedonia":"mk",
      "New Caledonia":"nc",
      "Jamaica":"jm",
      "DR Congo":"cd",
      "Bolivia":"bo",
      "Suriname":"sr",
      "Iraq":"iq",
      "Serbia":"rs",
      "Nigeria":"ng"
    };

    function flagHTML(name){
      if(!name) return "";
      // skip placeholders/path labels
      if(
        name.startsWith("UEFA Path") ||
        name.startsWith("FIFA IC Path") ||
        name.includes("UFEA Path") ||
        name.includes("FIFA IC Path") ||
        name.includes("Path") && name.length <= 16
      ) return "";

      const code = FLAG_CODE_BY_NAME[name];
      if(!code) return "";
      return `<img class="flag-img" src="https://flagcdn.com/w20/${code}.png" alt="${code} flag" loading="lazy">`;
    }
    function nameWithFlagHTML(name){
      return `${flagHTML(name)}${name ?? ""}`;
    }

    /* ==============================
       4) Edit mode + click-swap state
    ============================== */
    let editMode = "pools";
    let swapSelection = null;
    let qualifiedThirdGroupLetters = "";
    let qualifiedThirdPlacedTeams = [];

    /* ==============================
       5) Build state
    ============================== */
    function buildGroupsFromDefaults(){
      const groups = {};
      GROUP_KEYS.forEach(g => {
        groups[g] = DEFAULT_GROUPS[g].map(entryName => {
          const pathId = PATH_ID_BY_LABEL[entryName];
          if(pathId){
            return {
              id: `ph-${pathId}-${g}`,
              name: entryName,
              tag: "Placeholder",
              isPlaceholder: true,
              pathId
            };
          }
          return {
            id: toId(`${g}-${entryName}`),
            name: entryName,
            tag: `Group ${g}`,
            isPlaceholder: false
          };
        });
      });
      return groups;
    }

    function buildPaths(){
      const paths = {};
      PATHS.forEach(p => {
        paths[p.id] = p.candidates.map(name => ({
          id: toId(`${p.id}-${name}`),
          name,
          tag: p.label,
          originPathId: p.id,
          isQualified: false,
          isEliminated: false
        }));
      });
      return paths;
    }

    function fallbackPathNameForGroup(g){
      const p = PATHS.find(x => x.group === g);
      if(!p) return "TBD";

      if(p.id.startsWith("ufeapath-")){
        const letter = p.id.replace("ufeapath-","");
        const map = { a: 1, b: 2, c: 3, d: 4 };
        const n = map[letter] ?? letter.toUpperCase();
        return `UEFA Path ${n}`;
      }

      if(p.id.startsWith("fifaicpath-")){
        const n = p.id.replace("fifaicpath-","");
        return `FIFA IC Path ${n}`;
      }

      return p.label;
    }

    function buildThirdRankingFromGroups(groups){
      const base = [];
      GROUP_KEYS.forEach(g => {
        const third = groups[g]?.[2];
        base.push({
          id: toId(`third-${g}-${third?.name ?? "tbd"}`),
          groupKey: g,
          name: third?.name ?? fallbackPathNameForGroup(g)
        });
      });
      return base;
    }

    const initialState = () => {
      const groups = buildGroupsFromDefaults();
      const paths  = buildPaths();
      const qualifiedByPath = {};
      PATHS.forEach(p => qualifiedByPath[p.id] = false);

      return {
        paths,
        groups,
        qualifiedByPath,
        thirdRanking: buildThirdRankingFromGroups(groups),

        // Knockout
        r32Generated: false,
        winners: {} // matchId -> { side, name, abbrev }
      };
    };

    let state = initialState();

    /* ==============================
       6) Zones
    ============================== */
    const pathZones  = PATHS.map(p => `path-${p.id}`);
    const groupZones = GROUP_KEYS.map(g => `group-${g}`);

    const THIRD_RANK_ZONE = "third-ranking";
    const CHAMP_ZONE      = "champions-view";
    const RUNNERS_ZONE    = "runners-view";
    const TOP8_ZONE       = "top8-third-view";

    const zones = [
      ...pathZones,
      ...groupZones,
      THIRD_RANK_ZONE,
      CHAMP_ZONE,
      RUNNERS_ZONE,
      TOP8_ZONE
    ];

    const isPathZone = (z) => z.startsWith("path-");
    const isGroupZone = (z) => z.startsWith("group-");
    const pathIdFromZone = (z) => z.replace("path-","");
    const groupKeyFromZone = (z) => {
      const m = z.match(/^group-([A-L])$/);
      return m ? m[1] : null;
    };

    /* ==============================
       7) KO structure
    ============================== */
    const R32_INFO = {
      73: { date: "June 28, 2026", time: "12:00 p.m. (UTC−7)", stadium: "SoFi Stadium", city: "Inglewood" },
      74: { date: "June 29, 2026", time: "4:30 p.m. (UTC−4)", stadium: "Gillette Stadium", city: "Foxborough" },
      75: { date: "June 29, 2026", time: "7:00 p.m. (UTC−6)", stadium: "Estadio BBVA", city: "Guadalupe" },
      76: { date: "June 29, 2026", time: "12:00 p.m. (UTC−5)", stadium: "NRG Stadium", city: "Houston" },
      77: { date: "June 30, 2026", time: "5:00 p.m. (UTC−4)", stadium: "MetLife Stadium", city: "East Rutherford" },
      78: { date: "June 30, 2026", time: "12:00 p.m. (UTC−5)", stadium: "AT&T Stadium", city: "Arlington" },
      79: { date: "June 30, 2026", time: "7:00 p.m. (UTC−6)", stadium: "Estadio Azteca", city: "Mexico City" },
      80: { date: "July 1, 2026", time: "12:00 p.m. (UTC−4)", stadium: "Mercedes-Benz Stadium", city: "Atlanta" },
      81: { date: "July 1, 2026", time: "5:00 p.m. (UTC−7)", stadium: "Levi's Stadium", city: "Santa Clara" },
      82: { date: "July 1, 2026", time: "1:00 p.m. (UTC−7)", stadium: "Lumen Field", city: "Seattle" },
      83: { date: "July 2, 2026", time: "7:00 p.m. (UTC−4)", stadium: "BMO Field", city: "Toronto" },
      84: { date: "July 2, 2026", time: "12:00 p.m. (UTC−7)", stadium: "SoFi Stadium", city: "Inglewood" },
      85: { date: "July 2, 2026", time: "8:00 p.m. (UTC−7)", stadium: "BC Place", city: "Vancouver" },
      86: { date: "July 3, 2026", time: "6:00 p.m. (UTC−4)", stadium: "Hard Rock Stadium", city: "Miami Gardens" },
      87: { date: "July 3, 2026", time: "8:30 p.m. (UTC−5)", stadium: "Arrowhead Stadium", city: "Kansas City" },
      88: { date: "July 3, 2026", time: "1:00 p.m. (UTC−5)", stadium: "AT&T Stadium", city: "Arlington" }
    };

    const R16_INFO = {
      89: { date:"July 4, 2026", time:"5:00 p.m. (UTC−4)", stadium:"Lincoln Financial Field", city:"Philadelphia" },
      90: { date:"July 4, 2026", time:"12:00 p.m. (UTC−5)", stadium:"NRG Stadium", city:"Houston" },
      91: { date:"July 5, 2026", time:"4:00 p.m. (UTC−4)", stadium:"MetLife Stadium", city:"East Rutherford" },
      92: { date:"July 5, 2026", time:"6:00 p.m. (UTC−6)", stadium:"Estadio Azteca", city:"Mexico City" },
      93: { date:"July 6, 2026", time:"2:00 p.m. (UTC−5)", stadium:"AT&T Stadium", city:"Arlington" },
      94: { date:"July 6, 2026", time:"5:00 p.m. (UTC−7)", stadium:"Lumen Field", city:"Seattle" },
      95: { date:"July 7, 2026", time:"12:00 p.m. (UTC−4)", stadium:"Mercedes-Benz Stadium", city:"Atlanta" },
      96: { date:"July 7, 2026", time:"1:00 p.m. (UTC−7)", stadium:"BC Place", city:"Vancouver" }
    };

    const QF_INFO = {
      97: { date:"July 9, 2026", time:"4:00 p.m. (UTC−4)", stadium:"Gillette Stadium", city:"Foxborough" },
      98: { date:"July 10, 2026", time:"12:00 p.m. (UTC−7)", stadium:"SoFi Stadium", city:"Inglewood" },
      99: { date:"July 11, 2026", time:"5:00 p.m. (UTC−4)", stadium:"Hard Rock Stadium", city:"Miami Gardens" },
      100:{ date:"July 11, 2026", time:"8:00 p.m. (UTC−5)", stadium:"Arrowhead Stadium", city:"Kansas City" }
    };

    const SF_INFO = {
      101:{ date:"July 14, 2026", time:"2:00 p.m. (UTC−5)", stadium:"AT&T Stadium", city:"Arlington" },
      102:{ date:"July 15, 2026", time:"3:00 p.m. (UTC−4)", stadium:"Mercedes-Benz Stadium", city:"Atlanta" }
    };

    const THIRD_INFO = {
      103:{ date:"July 18, 2026", time:"5:00 p.m. (UTC−4)", stadium:"Hard Rock Stadium", city:"Miami Gardens" }
    };

    const FINAL_INFO = {
      104:{ date:"July 19, 2026", time:"3:00 p.m. (UTC−4)", stadium:"MetLife Stadium", city:"East Rutherford" }
    };

    const R32_MATCHES = [
      { id: 73, left: {type:"RU", g:"A"}, right:{type:"RU", g:"B"} },
      { id: 74, left: {type:"W",  g:"E"}, right:{type:"3SET", set:"A/B/C/D/F"} },
      { id: 75, left: {type:"W",  g:"F"}, right:{type:"RU", g:"C"} },
      { id: 76, left: {type:"W",  g:"C"}, right:{type:"RU", g:"F"} },
      { id: 77, left: {type:"W",  g:"I"}, right:{type:"3SET", set:"C/D/F/G/H"} },
      { id: 78, left: {type:"RU", g:"E"}, right:{type:"RU", g:"I"} },
      { id: 79, left: {type:"W",  g:"A"}, right:{type:"3SET", set:"C/E/F/H/I"} },
      { id: 80, left: {type:"W",  g:"L"}, right:{type:"3SET", set:"E/H/I/J/K"} },
      { id: 81, left: {type:"W",  g:"D"}, right:{type:"3SET", set:"B/E/F/I/J"} },
      { id: 82, left: {type:"W",  g:"G"}, right:{type:"3SET", set:"A/E/H/I/J"} },
      { id: 83, left: {type:"RU", g:"K"}, right:{type:"RU", g:"L"} },
      { id: 84, left: {type:"W",  g:"H"}, right:{type:"RU", g:"J"} },
      { id: 85, left: {type:"W",  g:"B"}, right:{type:"3SET", set:"E/F/G/I/J"} },
      { id: 86, left: {type:"W",  g:"J"}, right:{type:"RU", g:"H"} },
      { id: 87, left: {type:"W",  g:"K"}, right:{type:"3SET", set:"D/E/I/J/L"} },
      { id: 88, left: {type:"RU", g:"D"}, right:{type:"RU", g:"G"} }
    ];

    // R16 pairings per user text
    const R16_MATCHES = [
      { id: 90, left:{type:"WM", id:73}, right:{type:"WM", id:75} },
      { id: 89, left:{type:"WM", id:74}, right:{type:"WM", id:77} },
      { id: 91, left:{type:"WM", id:76}, right:{type:"WM", id:78} },
      { id: 92, left:{type:"WM", id:79}, right:{type:"WM", id:80} },
      { id: 93, left:{type:"WM", id:83}, right:{type:"WM", id:84} },
      { id: 94, left:{type:"WM", id:81}, right:{type:"WM", id:82} },
      { id: 95, left:{type:"WM", id:86}, right:{type:"WM", id:88} },
      { id: 96, left:{type:"WM", id:85}, right:{type:"WM", id:87} }
    ];

    const QF_MATCHES = [
      { id: 97, left:{type:"WM", id:89}, right:{type:"WM", id:90} },
      { id: 98, left:{type:"WM", id:93}, right:{type:"WM", id:94} },
      { id: 99, left:{type:"WM", id:91}, right:{type:"WM", id:92} },
      { id:100, left:{type:"WM", id:95}, right:{type:"WM", id:96} }
    ];

    const SF_MATCHES = [
      { id:101, left:{type:"WM", id:97}, right:{type:"WM", id:98} },
      { id:102, left:{type:"WM", id:99}, right:{type:"WM", id:100} }
    ];

    const THIRD_MATCH = [
      { id:103, left:{type:"LM", id:101}, right:{type:"LM", id:102} }
    ];

    const FINAL_MATCH = [
      { id:104, left:{type:"WM", id:101}, right:{type:"WM", id:102} }
    ];

    const ALL_ROUNDS = {
      r32: R32_MATCHES,
      r16: R16_MATCHES,
      qf:  QF_MATCHES,
      sf:  SF_MATCHES,
      third: THIRD_MATCH,
      final: FINAL_MATCH
    };

    const INFO_BY_MATCH = {
      ...R32_INFO, ...R16_INFO, ...QF_INFO, ...SF_INFO, ...THIRD_INFO, ...FINAL_INFO
    };

    /* ==============================
       8) Third-place logic
    ============================== */
    function getThirdTeamForGroup(g){
      const arr = state.groups[g] ?? [];
      const t = arr[2];
      return t && !t.isPlaceholder ? t : null;
    }

    function syncThirdRankingNames(){
      const existingByGroup = new Map(state.thirdRanking.map(x => [x.groupKey, x]));

      GROUP_KEYS.forEach(g => {
        if(!existingByGroup.has(g)){
          state.thirdRanking.push({
            id: toId(`third-${g}-tbd`),
            groupKey: g,
            name: fallbackPathNameForGroup(g)
          });
        }
      });

      state.thirdRanking = state.thirdRanking.filter(x => GROUP_KEYS.includes(x.groupKey));

      state.thirdRanking.forEach(item => {
        const third = getThirdTeamForGroup(item.groupKey);
        item.name = third ? third.name : fallbackPathNameForGroup(item.groupKey);
      });
    }

    function computeChampions(){
      return GROUP_KEYS.map(g => {
        const t = state.groups[g]?.[0];
        const name = (!t || t.isPlaceholder) ? fallbackPathNameForGroup(g) : t.name;
        return { id: toId(`champ-${g}-${name}`), name, groupKey: g };
      });
    }

    function computeRunners(){
      return GROUP_KEYS.map(g => {
        const t = state.groups[g]?.[1];
        const name = (!t || t.isPlaceholder) ? fallbackPathNameForGroup(g) : t.name;
        return { id: toId(`runner-${g}-${name}`), name, groupKey: g };
      });
    }

    function computeTop8ThirdPlaced(){
      syncThirdRankingNames();

      const top8Source = state.thirdRanking.slice(0, 8);

      qualifiedThirdPlacedTeams = top8Source.map(x => ({ groupKey: x.groupKey, name: x.name }));

      qualifiedThirdGroupLetters = top8Source
        .map(x => x.groupKey)
        .sort((a,b) => a.localeCompare(b))
        .join("");

      const top8 = top8Source.map((x, i) => ({
        id: toId(`top8-third-${i}-${x.groupKey}-${x.name}`),
        name: x.name,
        groupKey: x.groupKey
      }));

      top8.sort((a, b) => a.groupKey.localeCompare(b.groupKey));
      return top8;
    }

    function thirdPlaceholderName(setSpec){
      return setSpec
        .split("/")
        .map(s => s.trim())
        .filter(Boolean)
        .map(g => `3${g}`)
        .join("/");
    }

    function parseAllowedThird(spec){
      return spec.split("/").map(s => s.trim()).filter(Boolean);
    }

    // You can fill this later if you want exact FIFA mapping.
    const THIRD_TABLE = {};

    function resolveThirdFromRankingOnly(){
      computeTop8ThirdPlaced();
      const ranked = state.thirdRanking.slice(0, 8);
      const first = ranked[0];
      if(first) return { groupKey:first.groupKey, name:first.name, fallback:false };
      return { groupKey:"?", name:"UEFA/FIFA Path", fallback:true };
    }

    function resolveThirdForMatch(matchId, allowedLetters){
      computeTop8ThirdPlaced();
      const key = qualifiedThirdGroupLetters;
      const row = THIRD_TABLE[key];

      if(row && row[matchId]){
        const tag = row[matchId];
        const g = tag.replace("3", "");
        const third = state.thirdRanking.find(x => x.groupKey === g);
        const name = third ? third.name : tag;
        return { groupKey: g, name, source: "table", tableKey: key, fallback: false };
      }

      // Requirement #4: after R32 generated, remove "allowed-set" emphasis.
      if(state.r32Generated){
        const res = resolveThirdFromRankingOnly();
        return { groupKey: res.groupKey, name: res.name, source:"ranking", tableKey:key, fallback: res.fallback };
      }

      // Before generation we never reach here (placeholder shown).
      // But keep a safe fallback.
      const res = resolveThirdFromRankingOnly();
      return { groupKey: res.groupKey, name: res.name, source:"ranking", tableKey:key, fallback: res.fallback };
    }

    /* ==============================
       9) KO slot resolution
    ============================== */
    function getGroupPosTeam(g, idx){
      const t = state.groups[g]?.[idx];
      if(!t || t.isPlaceholder) return { name: fallbackPathNameForGroup(g), groupKey: g };
      return { name: t.name, groupKey: g };
    }

    function teamAbbrev(name){
      if(!name) return "---";
      const SPECIAL = {
        "United States": "USA",
        "United States of America": "USA",
        "South Korea": "KOR",
        "North Macedonia": "MKD",
        "Republic of Ireland": "IRL",
        "Czech Republic": "CZE",
        "Bosnia and Herzegovina": "BIH",
        "New Zealand": "NZL",
        "Cape Verde": "CPV",
        "Cabo Verde": "CPV",
        "Ivory Coast": "CIV",
        "Côte d'Ivoire":"CIV",
        "DR Congo": "COD",
        "Northern Ireland": "NIR"
      };
      if(SPECIAL[name]) return SPECIAL[name];

      if(name.startsWith("UEFA Path")) return "UEF";
      if(name.startsWith("FIFA IC Path")) return "FIC";

      const words = name.replace(/[().]/g,"").split(/\s+/).filter(Boolean);
      if(words.length >= 2){
        const init = words.map(w => w[0]).join("").toUpperCase();
        return init.slice(0,3).padEnd(3, init[0] ?? "X");
      }
      const s = words[0].toUpperCase();
      if(s.length <= 3) return s;
      return s.slice(0,3);
    }

    function resolveSlot(slot, matchId){
      if(slot.type === "W"){
        const t = getGroupPosTeam(slot.g, 0);
        return { name: t.name, label: `1${slot.g}`, placeholder:false };
      }
      if(slot.type === "RU"){
        const t = getGroupPosTeam(slot.g, 1);
        return { name: t.name, label: `2${slot.g}`, placeholder:false };
      }
      if(slot.type === "3SET"){
        const allowed = parseAllowedThird(slot.set);

        if(!state.r32Generated){
          const ph = thirdPlaceholderName(slot.set);
          return { name: ph, label: ph, placeholder:true, source:"placeholder", allowed };
        }

        const res = resolveThirdForMatch(matchId, allowed);
        return {
          name: res.name,
          label: `3${res.groupKey}`,
          placeholder:false,
          source: res.source
        };
      }
      if(slot.type === "WM"){
        const w = state.winners[slot.id];
        if(!w) return { name:`Winner ${slot.id}`, label:`W${slot.id}`, placeholder:true };
        return { name:w.name, label:`W${slot.id}`, placeholder:false };
      }
      if(slot.type === "LM"){
        const w = state.winners[slot.id];
        if(!w) return { name:`Loser ${slot.id}`, label:`L${slot.id}`, placeholder:true };
        // loser name isn't stored; infer from resolved participants
        const prev = findMatchById(slot.id);
        if(!prev) return { name:`Loser ${slot.id}`, label:`L${slot.id}`, placeholder:true };

        const p = resolveParticipants(prev);
        const loserName = (p.left.name === w.name) ? p.right.name : p.left.name;
        if(!loserName || loserName.startsWith("Winner") || loserName.startsWith("Loser")){
          return { name:`Loser ${slot.id}`, label:`L${slot.id}`, placeholder:true };
        }
        return { name: loserName, label:`L${slot.id}`, placeholder:false };
      }

      return { name:"TBD", label:"---", placeholder:true };
    }

    function findMatchById(id){
      for(const k of Object.keys(ALL_ROUNDS)){
        const m = ALL_ROUNDS[k].find(x => x.id === id);
        if(m) return m;
      }
      return null;
    }

    function resolveParticipants(match){
      const L = resolveSlot(match.left, match.id);
      const R = resolveSlot(match.right, match.id);
      return { left:L, right:R };
    }

    /* ==============================
       10) Winner validation (Feature #1)
    ============================== */
    function validateAllWinners(){
      // Ensure stored winners always match currently resolved participants.
      // If not, delete them. This naturally cascades.

      // Keep iterating once is enough because later matches depend on earlier winners.
      const order = [
        ...R32_MATCHES.map(m=>m.id),
        ...R16_MATCHES.map(m=>m.id),
        ...QF_MATCHES.map(m=>m.id),
        ...SF_MATCHES.map(m=>m.id),
        103,
        104
      ];

      order.forEach(id => {
        const match = findMatchById(id);
        if(!match) return;

        const stored = state.winners[id];
        if(!stored) return;

        const p = resolveParticipants(match);

        const names = [p.left.name, p.right.name];

        // Must be concrete names
        if(p.left.placeholder || p.right.placeholder){
          delete state.winners[id];
          return;
        }

        if(!names.includes(stored.name)){
          delete state.winners[id];
        }
      });
    }

    function setWinner(matchId, side, name){
      const ab = teamAbbrev(name);
      state.winners[matchId] = { side, name, abbrev: ab };
      validateAllWinners();
      render();
    }

    /* ==============================
       11) Edit rules
    ============================== */
    function isClickSwapEnabledForZone(zoneKey){
      if(editMode === "pools") return isPathZone(zoneKey);
      if(editMode === "groups"){
        // After R32 generated, keep third ranking visible but still editable if you want.
        // If you want it hard-locked, change to: && !state.r32Generated
        return isGroupZone(zoneKey) || zoneKey === THIRD_RANK_ZONE;
      }
      return false;
    }

    /* ==============================
       12) Zone arrays
    ============================== */
    function getZoneArray(zoneKey){
      if(isPathZone(zoneKey)) return state.paths[pathIdFromZone(zoneKey)];
      if(isGroupZone(zoneKey)) return state.groups[groupKeyFromZone(zoneKey)];
      if(zoneKey === THIRD_RANK_ZONE){ syncThirdRankingNames(); return state.thirdRanking; }
      if(zoneKey === CHAMP_ZONE) return computeChampions();
      if(zoneKey === RUNNERS_ZONE) return computeRunners();
      if(zoneKey === TOP8_ZONE) return computeTop8ThirdPlaced();
      return null;
    }

    /* ==============================
       13) Pool status display
    ============================== */
    function clearPoolStatus(){
      PATHS.forEach(p => {
        const arr = state.paths[p.id];
        if(!arr) return;
        arr.forEach(t => { t.isQualified = false; t.isEliminated = false; });
        state.qualifiedByPath[p.id] = false;
      });
    }

    function markQualifiedAndEliminated(pathId){
      const pathArr = state.paths[pathId];
      if(!pathArr || pathArr.length === 0) return;
      pathArr.forEach((t, i) => {
        t.isQualified = (i === 0);
        t.isEliminated = (i !== 0);
      });
      state.qualifiedByPath[pathId] = true;
    }

    /* ==============================
       14) Click-to-swap logic
    ============================== */
    function swapTeamsInArray(arr, id1, id2){
      const i1 = arr.findIndex(t => t.id === id1);
      const i2 = arr.findIndex(t => t.id === id2);
      if(i1 === -1 || i2 === -1) return false;
      [arr[i1], arr[i2]] = [arr[i2], arr[i1]];
      return true;
    }

    function handleClickSwap(teamId, zone){
      if(!isClickSwapEnabledForZone(zone)) return;

      if(!swapSelection){
        swapSelection = { teamId, zone };
        render();
        return;
      }

      if(swapSelection.teamId === teamId && swapSelection.zone === zone){
        swapSelection = null;
        render();
        return;
      }

      if(swapSelection.zone !== zone){
        swapSelection = { teamId, zone };
        render();
        return;
      }

      const arr = getZoneArray(zone);
      if(!arr) return;

      swapTeamsInArray(arr, swapSelection.teamId, teamId);
      swapSelection = null;

      // Any group change can affect KO resolution
      validateAllWinners();
      render();
    }

    function attachClickSwap(card){
      card.addEventListener("click", () => {
        handleClickSwap(card.dataset.id, card.dataset.zone);
      });
    }

    /* ==============================
       15) Form Groups (COPY)
    ============================== */
    function upsertPathTeamInGroup(groupKey, pathId, chosenTeam){
      const arr = state.groups[groupKey];
      if(!arr) return;

      const phIndex = arr.findIndex(t => t.isPlaceholder && t.pathId === pathId);
      if(phIndex !== -1){
        arr.splice(phIndex, 1, {
          id: toId(`grp-${groupKey}-${pathId}-${chosenTeam.name}`),
          name: chosenTeam.name,
          tag: PATH_BY_ID[pathId].label,
          chosenFromPath: true,
          pathId
        });
        return;
      }

      const exIndex = arr.findIndex(t => t.chosenFromPath && t.pathId === pathId);
      if(exIndex !== -1){
        arr.splice(exIndex, 1, {
          id: toId(`grp-${groupKey}-${pathId}-${chosenTeam.name}`),
          name: chosenTeam.name,
          tag: PATH_BY_ID[pathId].label,
          chosenFromPath: true,
          pathId
        });
        return;
      }

      arr.push({
        id: toId(`grp-${groupKey}-${pathId}-${chosenTeam.name}`),
        name: chosenTeam.name,
        tag: PATH_BY_ID[pathId].label,
        chosenFromPath: true,
        pathId
      });
    }

    function formGroupsFromPools(){
      PATHS.forEach(p => {
        const pathArr = state.paths[p.id];
        if(!pathArr || pathArr.length === 0) return;
        const chosen = pathArr[0];
        upsertPathTeamInGroup(p.group, p.id, chosen);
        markQualifiedAndEliminated(p.id);
      });

      editMode = "groups";
      swapSelection = null;

      validateAllWinners();
      render();
    }

    function reformPoolMode(){
      editMode = "pools";
      swapSelection = null;
      clearPoolStatus();
      render();
    }

    /* ==============================
       16) AUTO buttons (Feature #2)
    ============================== */
    function sortArrayByRank(arr){
      arr.sort((a,b) => {
        const ra = rankOf(a.name);
        const rb = rankOf(b.name);
        if(ra === rb) return String(a.name).localeCompare(String(b.name));
        return ra - rb;
      });
    }

    function autoPools(){
      PATHS.forEach(p => {
        const arr = state.paths[p.id];
        if(arr) sortArrayByRank(arr);
      });
      render();
    }

    function autoGroups(){
      GROUP_KEYS.forEach(g => {
        const arr = state.groups[g];
        if(!arr) return;
        // keep placeholders at end
        const real = arr.filter(x => !x.isPlaceholder);
        const ph   = arr.filter(x => x.isPlaceholder);
        real.sort((a,b) => {
          const ra = rankOf(a.name);
          const rb = rankOf(b.name);
          if(ra === rb) return String(a.name).localeCompare(String(b.name));
          return ra - rb;
        });
        state.groups[g] = [...real, ...ph].slice(0,4);
      });

      validateAllWinners();
      render();
    }

    function autoThirdRanking(){
      syncThirdRankingNames();
      state.thirdRanking.sort((a,b) => {
        const ra = rankOf(a.name);
        const rb = rankOf(b.name);
        if(ra === rb) return a.groupKey.localeCompare(b.groupKey);
        return ra - rb;
      });

      validateAllWinners();
      render();
    }

    function canAutoRound(match){
      const p = resolveParticipants(match);
      return !p.left.placeholder && !p.right.placeholder;
    }

    function autoRound(matches){
      matches.forEach(m => {
        const p = resolveParticipants(m);
        if(p.left.placeholder || p.right.placeholder) return;

        const winnerName = pickWinnerNameAuto(p.left.name, p.right.name);
        const side = (winnerName === p.left.name) ? "L" : "R";
        state.winners[m.id] = { side, name: winnerName, abbrev: teamAbbrev(winnerName) };
      });

      validateAllWinners();
      render();
    }

    function generateR32(){
      state.winners = {}; // reset all knockouts on generation for clean logic
      state.r32Generated = true;
      validateAllWinners();
      render();
    }

    /* ==============================
       17) UI build
    ============================== */
    function makeSeparator(text, buttonOptions=null){
      const sep = document.createElement("div");
      sep.className = "stage-separator";

      const left = document.createElement("div");
      left.className = "stage-left";
      left.innerHTML = `
        <span class="stage-title">${text}</span>
        <span class="stage-line"></span>
      `;
      sep.appendChild(left);

      if(buttonOptions){
        const right = document.createElement("div");
        right.className = "stage-right";

        const btns = Array.isArray(buttonOptions) ? buttonOptions : [buttonOptions];
        btns.forEach(opt => {
          const btn = document.createElement("button");
          btn.id = opt.id;
          btn.textContent = opt.text;
          if(opt.mini) btn.classList.add("btn-mini");
          right.appendChild(btn);
        });

        sep.appendChild(right);
      }

      return sep;
    }

    function makeColumn(title, zoneKey, subtitle = ""){
      const col = document.createElement("section");
      col.className = "column";
      col.innerHTML = `
        <div class="column-header">
          <div class="column-title">${title}${subtitle ? ` • ${subtitle}` : ""}</div>
          <div class="count" data-count-for="${zoneKey}"></div>
        </div>
        <div class="zone" data-zone="${zoneKey}"></div>
      `;
      return col;
    }

    function makeKoGrid(roundKey, className=""){
      const grid = document.createElement("div");
      grid.className = `ko-grid ${className}`.trim();
      grid.dataset.koRound = roundKey;
      return grid;
    }

    function buildBoard(){
      const board = document.getElementById("board");
      board.innerHTML = "";

      // Pools
      board.appendChild(
        makeSeparator(
          "Qualifier Pools",
          [
            { id:"autoPoolsBtn", text:"Auto Pools" },
          ]
        )
      );
      PATHS.forEach(p => {
        board.appendChild(makeColumn(p.label, `path-${p.id}`, `feeds Group ${p.group}`));
      });

      // Groups
      board.appendChild(
        makeSeparator(
          "Groups",
          [
            { id:"formGroupsBtn", text:"Form Groups" },
            { id:"autoGroupsBtn", text:"Auto Groups" }
          ]
        )
      );
      GROUP_KEYS.forEach(g => {
        board.appendChild(makeColumn(`Group ${g}`, `group-${g}`));
      });

      // Tools
      board.appendChild(
        makeSeparator(
          "Group Tools & Third-Place Logic",
          [
            { id:"autoThirdBtn", text:"Auto Third Ranking" }
          ]
        )
      );
      board.appendChild(makeColumn("Third Place Team Ranking", THIRD_RANK_ZONE, "A3 → L3"));
      board.appendChild(makeColumn("Group Champions", CHAMP_ZONE, "A1 → L1"));
      board.appendChild(makeColumn("Group Runners", RUNNERS_ZONE, "A2 → L2"));
      board.appendChild(makeColumn("Top-8 Third Placed Teams", TOP8_ZONE, "auto"));

      // R32
      board.appendChild(
        makeSeparator(
          "Round of 32",
          [
            { id:"generateR32Btn", text:"Generate R32" },
            { id:"autoR32Btn", text:"Auto R32" }
          ]
        )
      );
      const r32Grid = makeKoGrid("r32");
      board.appendChild(r32Grid);

      // R16
      board.appendChild(
        makeSeparator(
          "Round of 16",
          [
            { id:"autoR16Btn", text:"Auto R16" }
          ]
        )
      );
      const r16Grid = makeKoGrid("r16");
      board.appendChild(r16Grid);

      // QF
      board.appendChild(
        makeSeparator(
          "Quarterfinals",
          [
            { id:"autoQFBtn", text:"Auto QF" }
          ]
        )
      );
      const qfGrid = makeKoGrid("qf");
      board.appendChild(qfGrid);

      // SF (centered)
      board.appendChild(
        makeSeparator(
          "Semifinals",
          [
            { id:"autoSFBtn", text:"Auto SF" }
          ]
        )
      );
      const sfGrid = makeKoGrid("sf", "centered");
      board.appendChild(sfGrid);

      // Third place (centered)
      board.appendChild(
        makeSeparator(
          "Third Place",
          [
            { id:"autoThirdMatchBtn", text:"Auto Third" }
          ]
        )
      );
      const tGrid = makeKoGrid("third", "centered");
      board.appendChild(tGrid);

      // Final (centered)
      board.appendChild(
        makeSeparator(
          "Final",
          [
            { id:"autoFinalBtn", text:"Auto Final" }
          ]
        )
      );
      const fGrid = makeKoGrid("final", "centered");
      board.appendChild(fGrid);
    }

    /* ==============================
       18) Render groups/pools/tools
    ============================== */
    function applyRankHighlight(cardEl, zone, idx, team){
      cardEl.classList.remove("rank-strong", "rank-mild", "qualified", "eliminated");

      if(isPathZone(zone)){
        if(idx === 0) cardEl.classList.add("rank-strong");
        if(editMode === "groups"){
          if(team.isQualified) cardEl.classList.add("qualified");
          if(team.isEliminated) cardEl.classList.add("eliminated");
        }
        return;
      }

      if(isGroupZone(zone)){
        if(idx === 0 || idx === 1) cardEl.classList.add("rank-strong");
        else if(idx === 2) cardEl.classList.add("rank-mild");
        return;
      }

      if(zone === THIRD_RANK_ZONE){
        if(idx < 8) cardEl.classList.add("rank-strong");
        return;
      }

      if(zone === TOP8_ZONE){
        cardEl.classList.add("rank-strong");
      }
    }

    function renderStandardZones(){
      syncThirdRankingNames();

      zones.forEach(zone => {
        const dz = document.querySelector(`.zone[data-zone="${zone}"]`);
        if(!dz) return;

        dz.innerHTML = "";
        const arr = getZoneArray(zone) ?? [];
        const gKey = isGroupZone(zone) ? groupKeyFromZone(zone) : null;

        arr.forEach((team, idx) => {
          const card = document.createElement("div");
          card.className = "card";
          card.dataset.id = team.id;
          card.dataset.zone = zone;

          const editable =
            isClickSwapEnabledForZone(zone) &&
            !team.isPlaceholder &&
            zone !== CHAMP_ZONE &&
            zone !== RUNNERS_ZONE &&
            zone !== TOP8_ZONE;

          if(!editable) card.classList.add("locked");

          applyRankHighlight(card, zone, idx, team);

          if(swapSelection && swapSelection.teamId === team.id && swapSelection.zone === zone){
            card.classList.add("swap-armed");
          }

          let tagText = "";
          if(isPathZone(zone)){
            tagText = (editMode === "groups")
              ? (team.isQualified ? "Qualified" : "Eliminated")
              : (team.tag ?? PATH_BY_ID[pathIdFromZone(zone)]?.label ?? "");
          }
          else if(isGroupZone(zone)){
            tagText = team.isPlaceholder ? "Placeholder" : `${gKey}${idx + 1}`;
          }
          else if(zone === THIRD_RANK_ZONE){
            tagText = `${team.groupKey}3`;
          }
          else if(zone === CHAMP_ZONE){
            tagText = `${team.groupKey}1`;
          }
          else if(zone === RUNNERS_ZONE){
            tagText = `${team.groupKey}2`;
          }
          else if(zone === TOP8_ZONE){
            tagText = `${team.groupKey}3`;
          }

          card.innerHTML = `
            <span class="name">${nameWithFlagHTML(team.name)}</span>
            <span class="tag">${tagText}</span>
          `;

          if(!team.isPlaceholder && ![CHAMP_ZONE, RUNNERS_ZONE, TOP8_ZONE].includes(zone)){
            attachClickSwap(card);
          }

          dz.appendChild(card);
        });

        if(zone === TOP8_ZONE){
          const summary = document.createElement("div");
          summary.className = "top8-summary";
          summary.textContent = qualifiedThirdGroupLetters || "—";
          dz.appendChild(summary);
        }

        const countEl = document.querySelector(`[data-count-for="${zone}"]`);
        if(countEl){
          countEl.textContent = `${arr.length} team${arr.length !== 1 ? "s" : ""}`;
        }
      });
    }

    /* ==============================
       19) Render KO rounds
    ============================== */
    function buildMatchCard(match){
      const p = resolveParticipants(match);
      const L = p.left;
      const R = p.right;

      const winner = state.winners[match.id];
      const info = INFO_BY_MATCH[match.id];

      const card = document.createElement("div");
      card.className = "match-card";
      card.dataset.matchId = match.id;

      // header
      const head = document.createElement("div");
      head.className = "match-head";

      // label for header (examples: 1A vs 3C)
      const headerLabel = `Match ${match.id}`;
      const subLabel = `${L.label} vs ${R.label}`;

      head.innerHTML = `${headerLabel} <span class="sub">• ${subLabel}</span>`;
      card.appendChild(head);

      // left team
      const leftBtn = document.createElement("div");
      leftBtn.className = "match-team";
      leftBtn.innerHTML = nameWithFlagHTML(L.name);

      // mid abbrev
      const mid = document.createElement("div");
      mid.className = "match-mid";

      // right team
      const rightBtn = document.createElement("div");
      rightBtn.className = "match-team";
      rightBtn.innerHTML = nameWithFlagHTML(R.name);

      const canPick =
        (match.id >= 73 && match.id <= 88 ? state.r32Generated : true) &&
        !L.placeholder && !R.placeholder;

      if(!canPick){
        leftBtn.classList.add("locked");
        rightBtn.classList.add("locked");
        mid.textContent = "---";
      } else {
        leftBtn.addEventListener("click", () => setWinner(match.id, "L", L.name));
        rightBtn.addEventListener("click", () => setWinner(match.id, "R", R.name));
        mid.textContent = winner ? winner.abbrev : "---";
      }

      // winner highlight persistence
      if(winner && canPick){
        if(winner.name === L.name) leftBtn.classList.add("winning");
        if(winner.name === R.name) rightBtn.classList.add("winning");
      }

      card.appendChild(leftBtn);
      card.appendChild(mid);
      card.appendChild(rightBtn);

      // bottom meta
      const bottom = document.createElement("div");
      bottom.className = "match-bottom";

      const leftMeta = document.createElement("span");
      const rightMeta = document.createElement("span");

      if(info){
        leftMeta.innerHTML = `
          <span class="chip">${info.date}</span>
          <span class="chip">${info.time}</span>
        `;
        rightMeta.innerHTML = `
          <span class="chip">${info.stadium}</span>
          <span class="chip">${info.city}</span>
        `;
      } else {
        leftMeta.innerHTML = `<span class="chip">Date/Time TBD</span>`;
        rightMeta.innerHTML = `<span class="chip">Venue TBD</span>`;
      }

      bottom.appendChild(leftMeta);
      bottom.appendChild(rightMeta);

      card.appendChild(bottom);

      return card;
    }

    function renderKoRound(roundKey){
      const grid = document.querySelector(`.ko-grid[data-ko-round="${roundKey}"]`);
      if(!grid) return;

      grid.innerHTML = "";

      const matches = ALL_ROUNDS[roundKey] ?? [];

      matches.forEach(m => {
        grid.appendChild(buildMatchCard(m));
      });

      // R32 note about 3rd-place source
      if(roundKey === "r32"){
        const note = document.createElement("div");
        note.className = "r32-fallback-note";

        if(!state.r32Generated){
          note.textContent =
            "R32 not generated yet. Third-place slots are placeholders from the mapping sets.";
        } else {
          // After generation we no longer show ALLOWED/FALLBACK wording.
          note.textContent =
            "3rd-place mapping source: RANKING (add FIFA table later if desired).";
        }

        grid.appendChild(note);
      }
    }

    function renderAllKo(){
      validateAllWinners();

      renderKoRound("r32");
      renderKoRound("r16");
      renderKoRound("qf");
      renderKoRound("sf");
      renderKoRound("third");
      renderKoRound("final");
    }

    /* ==============================
       20) Stage pill + buttons
    ============================== */
    function updateStagePillAndButtons(){
      const pill = document.getElementById("stagePill");
      const reformBtn = document.getElementById("reformPoolBtn");
      const formBtn = document.getElementById("formGroupsBtn");
      const genR32Btn = document.getElementById("generateR32Btn");

      if(pill){
        pill.textContent = editMode === "pools" ? "Edit: Pools" : "Edit: Groups";
      }
      if(reformBtn){
        reformBtn.disabled = (editMode === "pools");
      }
      if(formBtn){
        formBtn.disabled = (editMode !== "pools");
      }
      if(genR32Btn){
        // allow generation only after groups exist
        genR32Btn.disabled = false;
      }
    }

    function wireButtons(){
      const resetBtn = document.getElementById("resetBtn");
      const reformBtn = document.getElementById("reformPoolBtn");
      const formBtn = document.getElementById("formGroupsBtn");

      const autoPoolsBtn = document.getElementById("autoPoolsBtn");
      const autoGroupsBtn = document.getElementById("autoGroupsBtn");
      const autoThirdBtn = document.getElementById("autoThirdBtn");

      const generateR32Btn = document.getElementById("generateR32Btn");
      const autoR32Btn = document.getElementById("autoR32Btn");
      const autoR16Btn = document.getElementById("autoR16Btn");
      const autoQFBtn = document.getElementById("autoQFBtn");
      const autoSFBtn = document.getElementById("autoSFBtn");
      const autoThirdMatchBtn = document.getElementById("autoThirdMatchBtn");
      const autoFinalBtn = document.getElementById("autoFinalBtn");

      if(formBtn){
        formBtn.addEventListener("click", () => {
          if(editMode !== "pools") return;
          formGroupsFromPools();
        });
      }

      if(reformBtn){
        reformBtn.addEventListener("click", () => reformPoolMode());
      }

      if(resetBtn){
        resetBtn.addEventListener("click", () => {
          state = initialState();
          editMode = "pools";
          swapSelection = null;
          buildBoard();
          render();
          wireButtons();
        });
      }

      if(autoPoolsBtn) autoPoolsBtn.addEventListener("click", autoPools);
      if(autoGroupsBtn) autoGroupsBtn.addEventListener("click", autoGroups);
      if(autoThirdBtn) autoThirdBtn.addEventListener("click", autoThirdRanking);

      if(generateR32Btn) generateR32Btn.addEventListener("click", generateR32);

      if(autoR32Btn){
        autoR32Btn.addEventListener("click", () => {
          if(!state.r32Generated) generateR32();
          autoRound(R32_MATCHES);
        });
      }

      if(autoR16Btn) autoR16Btn.addEventListener("click", () => autoRound(R16_MATCHES));
      if(autoQFBtn)  autoQFBtn.addEventListener("click", () => autoRound(QF_MATCHES));
      if(autoSFBtn)  autoSFBtn.addEventListener("click", () => autoRound(SF_MATCHES));
      if(autoThirdMatchBtn) autoThirdMatchBtn.addEventListener("click", () => autoRound(THIRD_MATCH));
      if(autoFinalBtn) autoFinalBtn.addEventListener("click", () => autoRound(FINAL_MATCH));
    }

    /* ==============================
       21) Render orchestrator
    ============================== */
    function render(){
      // derived sync
      syncThirdRankingNames();

      renderStandardZones();
      renderAllKo();
      updateStagePillAndButtons();
    }

    /* ==============================
       22) Boot
    ============================== */
    document.addEventListener("DOMContentLoaded", () => {
      buildBoard();
      render();
      wireButtons();
    });
  </script>
</body>
</html>
