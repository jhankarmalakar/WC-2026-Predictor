<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>World Cup 2026 – Pools → Form Groups → Group Tools</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg:#0f1220;
      --panel:#151a2e;
      --panel-2:#111527;
      --text:#f5f7ff;
      --muted:#b9c0e6;
      --accent:#7aa2ff;
      --border:rgba(255,255,255,0.08);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;

      /* Rank highlights */
      --hl-strong-bg: rgba(94, 230, 168, 0.14);
      --hl-strong-br: rgba(94, 230, 168, 0.45);
      --hl-mild-bg:   rgba(122, 162, 255, 0.10);
      --hl-mild-br:   rgba(122, 162, 255, 0.35);

      /* Qualified styling */
      --qualified-br: rgba(94, 230, 168, 0.55);
      --qualified-glow: rgba(94, 230, 168, 0.18);

      /* Eliminated styling */
      --elim-bg: rgba(255, 107, 122, 0.08);
      --elim-br: rgba(255, 107, 122, 0.35);

      /* Click-swap armed styling (amber) */
      --swap-bg: rgba(255, 184, 107, 0.14);
      --swap-br: rgba(255, 184, 107, 0.55);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: radial-gradient(1200px 800px at 10% 10%, #1c2342 0%, var(--bg) 40%, #070912 100%);
      min-height:100vh;
    }

    header{
      padding: 18px 20px 8px 20px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap: wrap;
    }
    header h1{
      font-size: 18px;
      font-weight: 650;
      margin:0 0 2px 0;
    }
    header .hint{
      color:var(--muted);
      font-size: 11.5px;
      max-width: 70ch;
    }

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
    }

    .stage-pill{
      font-size: 11.5px;
      color: var(--text);
      border: 1px solid var(--border);
      padding: 9px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.05);
      letter-spacing: 0.2px;
    }

    button{
      background: rgba(122,162,255,0.12);
      color: var(--text);
      border: 1px solid rgba(122,162,255,0.35);
      padding: 11px 14px;
      border-radius: 12px;
      font-size: 12.5px;
      cursor: pointer;
      white-space: nowrap;
    }
    button:hover{ background: rgba(122,162,255,0.18); }
    button:disabled{ opacity: 0.6; cursor: not-allowed; }

    /* Board grid */
    .board{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
      padding: 8px 16px 30px 16px;
    }
    @media (min-width: 780px){
      .board{ grid-template-columns: 1fr 1fr; }
    }
    @media (min-width: 1100px){
      .board{ grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (min-width: 1400px){
      .board{ grid-template-columns: 1fr 1fr 1fr 1fr; }
    }

    /* Stage separators */
    .stage-separator{
      grid-column: 1 / -1;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 6px 2px 6px;
    }
    .stage-left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
      flex: 1;
    }
    .stage-title{
      font-size: 11px;
      letter-spacing: 0.35px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.55);
      white-space: nowrap;
    }
    .stage-line{
      height: 1px;
      background: var(--border);
      flex: 1;
      min-width: 30px;
    }

    /* Column */
    .column{
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      min-height: 160px;
      display:flex;
      flex-direction:column;
    }
    .column-header{
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid var(--border);
      gap: 10px;
    }
    .column-title{
      font-size: 12.2px;
      letter-spacing: 0.35px;
      text-transform: uppercase;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 80%;
    }
    .count{
      font-size: 10.5px;
      color: var(--muted);
      opacity: 0.9;
      white-space: nowrap;
    }

    .zone{
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
      flex: 1;
    }

    /* R32 zone: show match cards as a responsive grid */
      .zone[data-zone="r32-fixtures"]{
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      
      /* 2-up */
      @media (min-width: 780px){
        .zone[data-zone="r32-fixtures"]{
          grid-template-columns: 1fr 1fr;
        }
      }
      
      /* 3-up */
      @media (min-width: 1100px){
        .zone[data-zone="r32-fixtures"]{
          grid-template-columns: 1fr 1fr 1fr;
        }
      }
      
      /* 4-up */
      @media (min-width: 1400px){
        .zone[data-zone="r32-fixtures"]{
          grid-template-columns: 1fr 1fr 1fr 1fr;
        }
      }


    /* Card */
    .card{
      background: rgba(255,255,255,0.04);
      border:1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      user-select: none;
      cursor: pointer;
      transition: background 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
    }
    .card.locked{
      cursor: default;
      opacity: 0.9;
    }

    .match-card{
      background: rgba(255,255,255,0.035);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 8px;
      align-items: center;
    }
    
    .match-team{
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      font-size: 12.5px;
      cursor: pointer;
      text-align: center;
    }
    
    .match-team.locked{
      cursor: default;
      opacity: 0.9;
    }
    
    .match-mid{
      min-width: 48px;
      text-align: center;
      font-weight: 800;
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
    }
    
    .match-meta{
      grid-column: 1 / -1;
      font-size: 10px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .match-meta.secondary{
      margin-top: 2px;
      opacity: 0.9;
    }
    .match-chip{
      display:inline-block;
      padding: 2px 6px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: rgba(255,255,255,0.04);
      font-size: 9.5px;
      white-space: nowrap;
    }

    
    .r32-fallback-note{
      margin-top: 8px;
      font-size: 10.5px;
      color: var(--muted);
      opacity: 0.9;
    }


    .name{
      font-size: 13.8px;
      font-weight: 560;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .tag{
      font-size: 9.8px;
      color: var(--muted);
      border:1px solid var(--border);
      padding: 3px 7px;
      border-radius: 999px;
      white-space: nowrap;
    }

    /* Rank highlights */
    .rank-strong{
      background: var(--hl-strong-bg);
      border-color: var(--hl-strong-br);
    }
    .rank-mild{
      background: var(--hl-mild-bg);
      border-color: var(--hl-mild-br);
    }

    /* Qualified/Eliminated */
    .qualified{
      border-color: var(--qualified-br);
      box-shadow: 0 0 0 1px var(--qualified-glow) inset;
    }
    .eliminated{
      background: var(--elim-bg);
      border-color: var(--elim-br);
    }

    /* First-click armed swap */
    .swap-armed{
      background: var(--swap-bg);
      border-color: var(--swap-br);
      box-shadow: 0 0 0 1px rgba(255,184,107,0.18) inset;
    }

    .footer{
      padding: 0 16px 24px 16px;
      color: var(--muted);
      font-size: 11px;
    }

    .top8-summary{
          margin-top: 10px;
          padding: 10px 12px;
          font-size: 14px;
          font-weight: 800;
          color: var(--text);
          border: 1px dashed var(--border);
          border-radius: 10px;
          letter-spacing: 2px;
          text-transform: uppercase;
          text-align: center;
          background: rgba(255,255,255,0.03);
        }

  </style>
</head>

<body>
  <header>
    <div>
      <h1>Qualifier Pools → Form Groups → Tools</h1>
      <div class="hint">
        Click/tap two teams in the same editable zone to swap. Use “Form Groups” to copy current pool winners into groups.
        Use “Reform Pool” to unlock pools and lock groups (without changing group order).
      </div>
    </div>

    <div class="actions">
      <span class="stage-pill" id="stagePill">Edit: Pools</span>
      <button id="reformPoolBtn" disabled>Reform Pool</button>
      <button id="resetBtn">Reset</button>
    </div>
  </header>

  <main class="board" id="board"></main>

  <div class="footer">
    No drag. Pools editable only in Pool mode. Groups + Third-place ranking editable only in Group mode.
  </div>

  <script>
    /* ==============================
       1) GROUPS + PATHS
    ============================== */
    const DEFAULT_GROUPS = {
      A: ["Mexico","South Africa","South Korea","UFEA Path D"],
      B: ["Canada","UFEA Path A","Qatar","Switzerland"],
      C: ["Brazil","Morocco","Haiti","Scotland"],
      D: ["United States","Paraguay","Australia","UFEA Path C"],
      E: ["Germany","Curaçao","Ivory Coast","Ecuador"],
      F: ["Netherlands","Japan","UFEA Path B","Tunisia"],
      G: ["Belgium","Egypt","Iran","New Zealand"],
      H: ["Spain","Cape Verde","Saudi Arabia","Uruguay"],
      I: ["France","Senegal","FIFA IC Path 2","Norway"],
      J: ["Argentina","Algeria","Austria","Jordan"],
      K: ["Portugal","FIFA IC Path 1","Uzbekistan","Colombia"],
      L: ["England","Croatia","Ghana","Panama"]
    };

    const PATHS = [
      { id: "ufeapath-a", label: "UFEA Path A",
        candidates: ["Wales", "Bosnia and Herzegovina", "Italy", "Northern Ireland"], group: "B" },
      { id: "ufeapath-b", label: "UFEA Path B",
        candidates: ["Ukraine", "Sweden", "Poland", "Albania"], group: "F" },
      { id: "ufeapath-c", label: "UFEA Path C",
        candidates: ["Slovakia", "Kosovo", "Turkey", "Romania"], group: "D" },
      { id: "ufeapath-d", label: "UFEA Path D",
        candidates: ["Czech Republic", "Republic of Ireland", "Denmark", "North Macedonia"], group: "A" },
      { id: "fifaicpath-1", label: "FIFA IC Path 1",
        candidates: ["New Caledonia", "Jamaica", "DR Congo"], group: "K" },
      { id: "fifaicpath-2", label: "FIFA IC Path 2",
        candidates: ["Bolivia", "Suriname", "Iraq"], group: "I" }
    ];

    const PATH_BY_ID = Object.fromEntries(PATHS.map(p => [p.id, p]));
    const PATH_ID_BY_LABEL = Object.fromEntries(PATHS.map(p => [p.label, p.id]));
    const GROUP_KEYS = Object.keys(DEFAULT_GROUPS);

    const toId = (name) =>
      name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");

    /* ==============================
       2) Edit mode + click-swap state
       editMode:
         - "pools": pools editable, groups locked
         - "groups": groups + third-ranking editable, pools locked
    ============================== */
    let editMode = "pools";
    let swapSelection = null; // { teamId, zone }
    let qualifiedThirdGroupLetters = "";
    let qualifiedThirdPlacedTeams = []; // NEW: full objects hook
    let usedThirdFallback = false;       // NEW: display note



    /* ==============================
       3) State
    ============================== */
    function buildGroupsFromDefaults(){
      const groups = {};
      GROUP_KEYS.forEach(g => {
        groups[g] = DEFAULT_GROUPS[g].map(entryName => {
          const pathId = PATH_ID_BY_LABEL[entryName];
          if(pathId){
            return {
              id: `ph-${pathId}-${g}`,
              name: entryName,
              tag: "Placeholder",
              isPlaceholder: true,
              pathId
            };
          }
          return {
            id: toId(`${g}-${entryName}`),
            name: entryName,
            tag: `Group ${g}`,
            isPlaceholder: false
          };
        });
      });
      return groups;
    }

    function buildPaths(){
      const paths = {};
      PATHS.forEach(p => {
        paths[p.id] = p.candidates.map(name => ({
          id: toId(`${p.id}-${name}`),
          name,
          tag: p.label,
          originPathId: p.id,
          isQualified: false,
          isEliminated: false
        }));
      });
      return paths;
    }
    
function fallbackPathNameForGroup(g){
        const p = PATHS.find(x => x.group === g);
        if(!p) return "TBD";
      
        if(p.id.startsWith("ufeapath-")){
          const letter = p.id.replace("ufeapath-",""); // a/b/c/d
          const map = { a: 1, b: 2, c: 3, d: 4 };
          const n = map[letter] ?? letter.toUpperCase();
          return `UEFA Path ${n}`;
        }
      
        if(p.id.startsWith("fifaicpath-")){
          const n = p.id.replace("fifaicpath-","");
          return `FIFA IC Path ${n}`;
        }
      
        return p.label;
      }

   function buildThirdRankingFromGroups(groups){
          const base = [];
          GROUP_KEYS.forEach(g => {
            const third = groups[g]?.[2];
        
            base.push({
              id: toId(`third-${g}-${third?.name ?? "tbd"}`),
              groupKey: g,
              name: third?.name ?? fallbackPathNameForGroup(g)
            });
          });
          return base;
        }
    


    const initialState = () => {
      const groups = buildGroupsFromDefaults();
      const paths  = buildPaths();
      const qualifiedByPath = {};
      PATHS.forEach(p => qualifiedByPath[p.id] = false);

     return {
        paths,
        groups,
        qualifiedByPath,
        thirdRanking: buildThirdRankingFromGroups(groups),
        r32Winners: {}, // NEW
        r32Generated: false
      };

    };

    let state = initialState();

    /* ==============================
       4) Zones
    ============================== */
    const pathZones  = PATHS.map(p => `path-${p.id}`);
    const groupZones = GROUP_KEYS.map(g => `group-${g}`);

    const THIRD_RANK_ZONE = "third-ranking";
    const CHAMP_ZONE      = "champions-view";
    const RUNNERS_ZONE    = "runners-view";
    const TOP8_ZONE       = "top8-third-view";
    const R32_ZONE = "r32-fixtures";
    const ABBR_ZONE = "abbr-table";

      const zones = [
        ...pathZones,
        ...groupZones,
        THIRD_RANK_ZONE,
        CHAMP_ZONE,
        RUNNERS_ZONE,
        TOP8_ZONE,
        R32_ZONE
      ];


    const isPathZone = (z) => z.startsWith("path-");
    const isGroupZone = (z) => z.startsWith("group-");
    const isDerivedZone = (z) =>
      [THIRD_RANK_ZONE, CHAMP_ZONE, RUNNERS_ZONE, TOP8_ZONE].includes(z);

    const pathIdFromZone = (z) => z.replace("path-","");
    const groupKeyFromZone = (z) => {
      const m = z.match(/^group-([A-L])$/);
      return m ? m[1] : null;
    };

    /* ==============================
       5) UI build
    ============================== */
    function makeSeparator(text, buttonOptions=null){
      const sep = document.createElement("div");
      sep.className = "stage-separator";
    
      const left = document.createElement("div");
      left.className = "stage-left";
      left.innerHTML = `
        <span class="stage-title">${text}</span>
        <span class="stage-line"></span>
      `;
      sep.appendChild(left);
    
      if(buttonOptions){
        const btn = document.createElement("button");
        btn.id = buttonOptions.id;
        btn.textContent = buttonOptions.text;
        sep.appendChild(btn);
      }
    
      return sep;
    }


    function makeColumn(title, zoneKey, subtitle = ""){
      const col = document.createElement("section");
      col.className = "column";
      col.innerHTML = `
        <div class="column-header">
          <div class="column-title">${title}${subtitle ? ` • ${subtitle}` : ""}</div>
          <div class="count" data-count-for="${zoneKey}"></div>
        </div>
        <div class="zone" data-zone="${zoneKey}"></div>
      `;
      return col;
    }

    function buildBoard(){
      const board = document.getElementById("board");
      board.innerHTML = "";

      // Pools
      board.appendChild(makeSeparator("Qualifier Pools (click-swap in Pool mode)"));
      PATHS.forEach(p => {
        board.appendChild(makeColumn(p.label, `path-${p.id}`, `feeds Group ${p.group}`));
      });

      // Groups
      board.appendChild(
            makeSeparator(
              "Groups (click-swap in Group mode)",
              { id:"formGroupsBtn", text:"Form Groups" }
            )
          );

      GROUP_KEYS.forEach(g => {
        board.appendChild(makeColumn(`Group ${g}`, `group-${g}`));
      });

      // Tools / tables
      board.appendChild(makeSeparator("Group Tools & Third-Place Logic"));
      board.appendChild(makeColumn("Third Place Team Ranking", THIRD_RANK_ZONE, "A3 → L3"));
      board.appendChild(makeColumn("Group Champions", CHAMP_ZONE, "A1 → L1"));
      board.appendChild(makeColumn("Group Runners", RUNNERS_ZONE, "A2 → L2"));
      board.appendChild(makeColumn("Top-8 Third Placed Teams", TOP8_ZONE, "auto"));
      
      board.appendChild(
                makeSeparator(
                  "Round of 32 (placeholder → generate → pick winners)",
                  { id:"generateR32Btn", text:"Generate R32" }
                )
              );

      
      board.appendChild(makeColumn("R32 Fixtures", R32_ZONE, "winners by click"));
    //  board.appendChild(makeColumn("Team Abbreviations", ABBR_ZONE, "auto"));

    }

    /* ==============================
       6) Edit rules
    ============================== */
    function isClickSwapEnabledForZone(zoneKey){
      if(editMode === "pools"){
        return isPathZone(zoneKey);
      }
      if(editMode === "groups"){
        return isGroupZone(zoneKey) || zoneKey === THIRD_RANK_ZONE;
      }
      return false;
    }

    /* ==============================
       7) Derived data
    ============================== */
    function getThirdTeamForGroup(g){
      const arr = state.groups[g] ?? [];
      const t = arr[2];
      return t && !t.isPlaceholder ? t : null;
    }

    function syncThirdRankingNames(){
      // Ensure one entry per groupKey, preserve user order
      const existingByGroup = new Map(state.thirdRanking.map(x => [x.groupKey, x]));

      // Add missing groups
      GROUP_KEYS.forEach(g => {
        if(!existingByGroup.has(g)){
         state.thirdRanking.push({
            id: toId(`third-${g}-tbd`),
            groupKey: g,
            name: fallbackPathNameForGroup(g)
          });

        }
      });

      // Remove extras that no longer map to a group (unlikely)
      state.thirdRanking = state.thirdRanking.filter(x => GROUP_KEYS.includes(x.groupKey));

      // Update names based on current group 3rd-place
      state.thirdRanking.forEach(item => {
            const third = getThirdTeamForGroup(item.groupKey);
            item.name = third ? third.name : fallbackPathNameForGroup(item.groupKey);
          });

    }

    function computeChampions(){
          return GROUP_KEYS.map(g => {
            const t = state.groups[g]?.[0];
        
            const name =
              (!t || t.isPlaceholder)
                ? fallbackPathNameForGroup(g)
                : t.name;
        
            return {
              id: toId(`champ-${g}-${name}`),
              name,
              groupKey: g
            };
          });
        }


   function computeRunners(){
          return GROUP_KEYS.map(g => {
            const t = state.groups[g]?.[1];
        
            const name =
              (!t || t.isPlaceholder)
                ? fallbackPathNameForGroup(g)
                : t.name;
        
            return {
              id: toId(`runner-${g}-${name}`),
              name,
              groupKey: g
            };
          });
        }


      function computeTop8ThirdPlaced(){
          syncThirdRankingNames();
        
          // 1) Take top 8 based on manual ranking order
          const top8Source = state.thirdRanking.slice(0, 8);
        
          // 2) Save full objects hook
          qualifiedThirdPlacedTeams = top8Source.map(x => ({
            groupKey: x.groupKey,
            name: x.name
          }));
        
          // 3) Save letters hook (sorted A→L)
          qualifiedThirdGroupLetters = top8Source
            .map(x => x.groupKey)
            .sort((a,b) => a.localeCompare(b))
            .join("");
        
          // 4) Build display list
          const top8 = top8Source.map((x, i) => ({
            id: toId(`top8-third-${i}-${x.groupKey}-${x.name}`),
            name: x.name,
            groupKey: x.groupKey
          }));
        
          // 5) Display in alphabetical group order
          top8.sort((a, b) => a.groupKey.localeCompare(b.groupKey));
        
          return top8;
        }

    function resolveThirdFromAllowedGroups(allowedLetters){
            // allowedLetters: array of group letters ["A","B","C"...]
            usedThirdFallback = false;
          
            // Ensure hooks are up to date
            computeTop8ThirdPlaced();
          
            // Use manual ranking priority
            const ranked = state.thirdRanking.slice(0, 8);
          
            const found = ranked.find(x => allowedLetters.includes(x.groupKey));
          
            if(found){
              return { groupKey: found.groupKey, name: found.name, fallback: false };
            }
          
            // Fallback rule per your instruction
            usedThirdFallback = true;
          
            // Interpret fallback ABCDEFGH as "pretend allowed set is A..H"
            const fallbackAllowed = ["A","B","C","D","E","F","G","H"];
            const fbFound = ranked.find(x => fallbackAllowed.includes(x.groupKey));
          
            if(fbFound){
              return { groupKey: fbFound.groupKey, name: fbFound.name, fallback: true };
            }
          
            // Absolute last fallback
            return { groupKey: "?", name: "UEFA/FIFA Path", fallback: true };
          }

    const ABBR_SPECIAL = {
            "United States": "USA",
            "United States of America": "USA",
            "South Korea": "KOR",
            "North Macedonia": "MKD",
            "Republic of Ireland": "IRL",
            "Czech Republic": "CZE",
            "Bosnia and Herzegovina": "BIH",
            "New Zealand": "NZL",
            "Cape Verde": "CPV",
            "Ivory Coast": "CIV",
            "DR Congo": "COD",
            "Northern Ireland": "NIR"
          };

      function teamAbbrev(name){
              if(!name) return "---";
              if(ABBR_SPECIAL[name]) return ABBR_SPECIAL[name];
            
              // Ignore placeholders/path labels for abbreviations
              if(name.startsWith("UEFA Path")) return "UEF";
              if(name.startsWith("FIFA IC Path")) return "FIC";
            
              const words = name
                .replace(/[().]/g,"")
                .split(/\s+/)
                .filter(Boolean);
            
              // If multi-word: use initials up to 3
              if(words.length >= 2){
                const init = words.map(w => w[0]).join("").toUpperCase();
                return init.slice(0,3).padEnd(3, init[0] ?? "X");
              }
            
              // Single word fallback
              const s = words[0].toUpperCase();
              if(s.length <= 3) return s;
              return s.slice(0,3);
            }





    /* ==============================
       8) Zone arrays
    ============================== */
  

    
    
 function getZoneArray(zoneKey){
      if(isPathZone(zoneKey)){
        return state.paths[pathIdFromZone(zoneKey)];
      }
      if(isGroupZone(zoneKey)){
        return state.groups[groupKeyFromZone(zoneKey)];
      }
      if(zoneKey === THIRD_RANK_ZONE){
        syncThirdRankingNames();
        return state.thirdRanking;
      }
      if(zoneKey === CHAMP_ZONE){
        return computeChampions();
      }
      if(zoneKey === RUNNERS_ZONE){
        return computeRunners();
      }
      if(zoneKey === TOP8_ZONE){
        return computeTop8ThirdPlaced();
      }
      if(zoneKey === R32_ZONE){
        return []; // rendered manually
      }
    
      return null;
}


    /* ==============================
       9) Pool status display
    ============================== */
    function clearPoolStatus(){
      PATHS.forEach(p => {
        const arr = state.paths[p.id];
        if(!arr) return;
        arr.forEach(t => {
          t.isQualified = false;
          t.isEliminated = false;
        });
        state.qualifiedByPath[p.id] = false;
      });
    }

    function markQualifiedAndEliminated(pathId){
      const pathArr = state.paths[pathId];
      if(!pathArr || pathArr.length === 0) return;

      pathArr.forEach((t, i) => {
        t.isQualified = (i === 0);
        t.isEliminated = (i !== 0);
      });
      state.qualifiedByPath[pathId] = true;
    }

    /* ==============================
       10) Render
    ============================== */
    function render(){
      // Keep third-ranking synced with group A3..L3
      syncThirdRankingNames();

      zones.forEach(zone => {
        const dz = document.querySelector(`.zone[data-zone="${zone}"]`);
        if(!dz) return;

        dz.innerHTML = "";
        const arr = getZoneArray(zone) ?? [];

        if(zone === R32_ZONE){
            renderR32(dz);
            const countEl = document.querySelector(`[data-count-for="${zone}"]`);
            if(countEl) countEl.textContent = `${R32_MATCHES.length} matches`;
            return;
          }

        const gKey = isGroupZone(zone) ? groupKeyFromZone(zone) : null;

        arr.forEach((team, idx) => {
          const card = document.createElement("div");
          card.className = "card";
          card.dataset.id = team.id;
          card.dataset.zone = zone;

          const editable = isClickSwapEnabledForZone(zone) && !team.isPlaceholder && zone !== CHAMP_ZONE && zone !== RUNNERS_ZONE && zone !== TOP8_ZONE;
          if(!editable) card.classList.add("locked");

          applyRankHighlight(card, zone, idx, team);

          if(swapSelection && swapSelection.teamId === team.id && swapSelection.zone === zone){
            card.classList.add("swap-armed");
          }

          // Tag text
          let tagText = "";

          if(isPathZone(zone)){
            tagText = (editMode === "groups")
              ? (team.isQualified ? "Qualified" : "Eliminated")
              : (team.tag ?? PATH_BY_ID[pathIdFromZone(zone)]?.label ?? "");
          }
          else if(isGroupZone(zone)){
            if(team.isPlaceholder){
              tagText = "Placeholder";
            } else {
              tagText = `${gKey}${idx + 1}`;
            }
          }
          else if(zone === THIRD_RANK_ZONE){
            tagText = `${team.groupKey}3`;
          }
          else if(zone === CHAMP_ZONE){
            tagText = `${team.groupKey}1`;
          }
          else if(zone === RUNNERS_ZONE){
            tagText = `${team.groupKey}2`;
          }
          else if(zone === TOP8_ZONE){
            tagText = `${team.groupKey}3`;
          }

          card.innerHTML = `
            <span class="name">${team.name}</span>
            <span class="tag">${tagText}</span>
          `;

          if(!team.isPlaceholder && ![CHAMP_ZONE, RUNNERS_ZONE, TOP8_ZONE].includes(zone)){
            attachClickSwap(card);
          }

          dz.appendChild(card);
        });

        // Extra summary line for Top-8 Third Placed column
                if(zone === TOP8_ZONE){
                  const summary = document.createElement("div");
                  summary.className = "top8-summary";
                  summary.textContent = qualifiedThirdGroupLetters || "—";
                  dz.appendChild(summary);
                }






        const countEl = document.querySelector(`[data-count-for="${zone}"]`);
        if(countEl){
          countEl.textContent = `${arr.length} team${arr.length !== 1 ? "s" : ""}`;
        }
      });

      updateStagePillAndButtons();
    }

    function applyRankHighlight(cardEl, zone, idx, team){
      cardEl.classList.remove("rank-strong", "rank-mild", "qualified", "eliminated");

      if(isPathZone(zone)){
        // Pool topper highlight always
        if(idx === 0) cardEl.classList.add("rank-strong");

        // When in group edit mode, show qualified/eliminated styling
        if(editMode === "groups"){
          if(team.isQualified) cardEl.classList.add("qualified");
          if(team.isEliminated) cardEl.classList.add("eliminated");
        }
        return;
      }

      if(isGroupZone(zone)){
        if(idx === 0 || idx === 1) cardEl.classList.add("rank-strong");
        else if(idx === 2) cardEl.classList.add("rank-mild");
        return;
      }

      if(zone === THIRD_RANK_ZONE){
        // Top 8 highlight like pool topper style
        if(idx < 8) cardEl.classList.add("rank-strong");
        return;
      }

       if(zone === TOP8_ZONE){
                  cardEl.classList.add("rank-strong");
                  return;
                }
    }

    function getGroupPosTeam(g, idx){
  const t = state.groups[g]?.[idx];
  if(!t || t.isPlaceholder) return { name: fallbackPathNameForGroup(g), groupKey: g };
  return { name: t.name, groupKey: g };
}

function parseAllowedThird(spec){
  // spec like "A/B/C/D/F"
  return spec.split("/").map(s => s.trim()).filter(Boolean);
}


const R32_INFO = {
  73: { date: "June 28, 2026", time: "12:00 p.m. (UTC−7)", stadium: "SoFi Stadium", city: "Inglewood" },

  74: { date: "June 29, 2026", time: "4:30 p.m. (UTC−4)", stadium: "Gillette Stadium", city: "Foxborough" },
  75: { date: "June 29, 2026", time: "7:00 p.m. (UTC−6)", stadium: "Estadio BBVA", city: "Guadalupe" },
  76: { date: "June 29, 2026", time: "12:00 p.m. (UTC−5)", stadium: "NRG Stadium", city: "Houston" },

  77: { date: "June 30, 2026", time: "5:00 p.m. (UTC−4)", stadium: "MetLife Stadium", city: "East Rutherford" },
  78: { date: "June 30, 2026", time: "12:00 p.m. (UTC−5)", stadium: "AT&T Stadium", city: "Arlington" },
  79: { date: "June 30, 2026", time: "7:00 p.m. (UTC−6)", stadium: "Estadio Azteca", city: "Mexico City" },

  80: { date: "July 1, 2026", time: "12:00 p.m. (UTC−4)", stadium: "Mercedes-Benz Stadium", city: "Atlanta" },
  81: { date: "July 1, 2026", time: "5:00 p.m. (UTC−7)", stadium: "Levi's Stadium", city: "Santa Clara" },
  82: { date: "July 1, 2026", time: "1:00 p.m. (UTC−7)", stadium: "Lumen Field", city: "Seattle" },

  83: { date: "July 2, 2026", time: "7:00 p.m. (UTC−4)", stadium: "BMO Field", city: "Toronto" },
  84: { date: "July 2, 2026", time: "12:00 p.m. (UTC−7)", stadium: "SoFi Stadium", city: "Inglewood" },
  85: { date: "July 2, 2026", time: "8:00 p.m. (UTC−7)", stadium: "BC Place", city: "Vancouver" },

  86: { date: "July 3, 2026", time: "6:00 p.m. (UTC−4)", stadium: "Hard Rock Stadium", city: "Miami Gardens" },
  87: { date: "July 3, 2026", time: "8:30 p.m. (UTC−5)", stadium: "Arrowhead Stadium", city: "Kansas City" },
  88: { date: "July 3, 2026", time: "1:00 p.m. (UTC−5)", stadium: "AT&T Stadium", city: "Arlington" }
};
    
const R32_MATCHES = [
  { id: 73, left: {type:"RU", g:"A"}, right:{type:"RU", g:"B"} },
  { id: 74, left: {type:"W",  g:"E"}, right:{type:"3SET", set:"A/B/C/D/F"} },
  { id: 75, left: {type:"W",  g:"F"}, right:{type:"RU", g:"C"} },
  { id: 76, left: {type:"W",  g:"C"}, right:{type:"RU", g:"F"} },

  { id: 77, left: {type:"W",  g:"I"}, right:{type:"3SET", set:"C/D/F/G/H"} },
  { id: 78, left: {type:"RU", g:"E"}, right:{type:"RU", g:"I"} },
  { id: 79, left: {type:"W",  g:"A"}, right:{type:"3SET", set:"C/E/F/H/I"} },
  { id: 80, left: {type:"W",  g:"L"}, right:{type:"3SET", set:"E/H/I/J/K"} },

  { id: 81, left: {type:"W",  g:"D"}, right:{type:"3SET", set:"B/E/F/I/J"} },
  { id: 82, left: {type:"W",  g:"G"}, right:{type:"3SET", set:"A/E/H/I/J"} },
  { id: 83, left: {type:"RU", g:"K"}, right:{type:"RU", g:"L"} },
  { id: 84, left: {type:"W",  g:"H"}, right:{type:"RU", g:"J"} },

  { id: 85, left: {type:"W",  g:"B"}, right:{type:"3SET", set:"E/F/G/I/J"} },
  { id: 86, left: {type:"W",  g:"J"}, right:{type:"RU", g:"H"} },
  { id: 87, left: {type:"W",  g:"K"}, right:{type:"3SET", set:"D/E/I/J/L"} },
  { id: 88, left: {type:"RU", g:"D"}, right:{type:"RU", g:"G"} }
];

    // You will fill this later based on FIFA's third-place mapping table.
const THIRD_TABLE = {};

function resolveThirdForMatch(matchId, allowedLetters){
  computeTop8ThirdPlaced();

  const key = qualifiedThirdGroupLetters; // sorted letters
  const row = THIRD_TABLE[key];

  // Table has priority if you add it later
  if(row && row[matchId]){
    const tag = row[matchId]; // e.g. "3E"
    const g = tag.replace("3", "");
    const third = state.thirdRanking.find(x => x.groupKey === g);
    const name = third ? third.name : tag;

    return { groupKey: g, name, source: "table", tableKey: key, fallback: false };
  }

  // Otherwise use allowed/fallback logic
  const res = resolveThirdFromAllowedGroups(allowedLetters);
  return {
    groupKey: res.groupKey,
    name: res.name,
    source: res.fallback ? "fallback" : "allowed",
    tableKey: key,
    fallback: res.fallback
  };
}


function resolveSlot(slot, matchId){
  if(slot.type === "W"){
    const t = getGroupPosTeam(slot.g, 0);
    return { name: t.name, label: `1${slot.g}`, groupKey: slot.g, placeholder: false };
  }

  if(slot.type === "RU"){
    const t = getGroupPosTeam(slot.g, 1);
    return { name: t.name, label: `2${slot.g}`, groupKey: slot.g, placeholder: false };
  }

  if(slot.type === "3SET"){
    const allowed = parseAllowedThird(slot.set);

    // BEFORE generation: show placeholder like 3C/3D/3F/3G/3H
    if(!state.r32Generated){
      const ph = thirdPlaceholderName(slot.set);
      return {
        name: ph,
        label: ph,
        groupKey: "?",
        placeholder: true,
        allowed,
        source: "placeholder"
      };
    }

    // AFTER generation: resolve via table (if present) else allowed/fallback
    const res = resolveThirdForMatch(matchId, allowed);

    return {
      name: res.name,
      label: `3${res.groupKey}`,
      groupKey: res.groupKey,
      placeholder: false,
      allowed,
      source: res.source,
      tableKey: res.tableKey,
      fallback: res.fallback
    };
  }

  return { name: "TBD", label: "---", groupKey: "?", placeholder: true };
}


function renderR32(dz){
  dz.innerHTML = "";

  let anyFallback = false;
  let anyTable = false;
  let tableKeyUsed = "";


  R32_MATCHES.forEach(m => {
    const L = resolveSlot(m.left, m.id);
    const R = resolveSlot(m.right, m.id);



    const winner = state.r32Winners[m.id];

    const card = document.createElement("div");
    card.className = "match-card";

    const leftBtn = document.createElement("div");
    leftBtn.className = "match-team";
    leftBtn.textContent = L.name;

    const rightBtn = document.createElement("div");
    rightBtn.className = "match-team";
    rightBtn.textContent = R.name;

    const mid = document.createElement("div");
    mid.className = "match-mid";
    mid.textContent = winner ? winner.abbrev : "---";

   
    if(L.source === "fallback" || R.source === "fallback") anyFallback = true;
    if(L.source === "table" || R.source === "table"){
      anyTable = true;
      tableKeyUsed = L.tableKey || R.tableKey || tableKeyUsed;
    }

    const canPick = state.r32Generated && !L.placeholder && !R.placeholder;

if(!canPick){
  leftBtn.classList.add("locked");
  rightBtn.classList.add("locked");
} else {
  leftBtn.addEventListener("click", () => {
    const ab = teamAbbrev(L.name);
    state.r32Winners[m.id] = { side:"L", name:L.name, abbrev:ab };
    render();
  });

  rightBtn.addEventListener("click", () => {
    const ab = teamAbbrev(R.name);
    state.r32Winners[m.id] = { side:"R", name:R.name, abbrev:ab };
    render();
  });
}  

    mid.textContent = (canPick && winner) ? winner.abbrev : "---";




    const meta = document.createElement("div");
    meta.className = "match-meta";

    
    const metaLeft = document.createElement("span");
    metaLeft.textContent = `Match ${m.id}: ${L.label} vs ${R.label}`;
    const metaRight = document.createElement("span");

        if(m.right.type === "3SET" || m.left.type === "3SET"){
          if(!state.r32Generated){
            metaRight.textContent = "3rd-place: placeholder";
          } else {
            // Prefer TABLE label if used for this match
            const src = (L.source === "table" || R.source === "table") ? "TABLE"
                      : (L.source === "fallback" || R.source === "fallback") ? "FALLBACK"
                      : "ALLOWED";
            metaRight.textContent = `3rd-place: ${src}`;
          }
        } else {
          metaRight.textContent = "";
        }

    meta.appendChild(metaLeft);
    meta.appendChild(metaRight);

    const info = R32_INFO[m.id];

    const meta2 = document.createElement("div");
    meta2.className = "match-meta secondary";
    
    const meta2Left = document.createElement("span");
    const meta2Right = document.createElement("span");
    
    if(info){
      meta2Left.innerHTML = `
        <span class="match-chip">${info.date}</span>
        <span class="match-chip">${info.time}</span>
      `;
      meta2Right.innerHTML = `
        <span class="match-chip">${info.stadium}</span>
        <span class="match-chip">${info.city}</span>
      `;
    } else {
      meta2Left.textContent = "Date/Time TBD";
      meta2Right.textContent = "Venue TBD";
    }
    
    meta2.appendChild(meta2Left);
    meta2.appendChild(meta2Right);



    

    card.appendChild(leftBtn);
    card.appendChild(mid);
    card.appendChild(rightBtn);
    card.appendChild(meta);
    card.appendChild(meta2);


    dz.appendChild(card);
  });

const note = document.createElement("div");
note.className = "r32-fallback-note";

if(!state.r32Generated){
  note.textContent =
    "R32 not generated yet. Third-place slots are placeholders from the FIFA mapping sets.";
} else if(anyTable){
  note.textContent = `3rd-place mapping source: TABLE (${tableKeyUsed || "key"})`;
} else if(anyFallback){
  note.textContent = "3rd-place mapping source: FALLBACK ABCDEFGH";
} else {
  note.textContent = "3rd-place mapping source: Allowed-set ranking";
}

dz.appendChild(note);

}

}


    function thirdPlaceholderName(setSpec){
        // "C/D/F/G/H" -> "3C/3D/3F/3G/3H"
        return setSpec
          .split("/")
          .map(s => s.trim())
          .filter(Boolean)
          .map(g => `3${g}`)
          .join("/");
      }

    




    /* ==============================
       11) Click-to-swap logic
    ============================== */
    function swapTeamsInArray(arr, id1, id2){
      const i1 = arr.findIndex(t => t.id === id1);
      const i2 = arr.findIndex(t => t.id === id2);
      if(i1 === -1 || i2 === -1) return false;
      [arr[i1], arr[i2]] = [arr[i2], arr[i1]];
      return true;
    }

    function handleClickSwap(teamId, zone){
      // Ignore clicks in locked zones
      if(!isClickSwapEnabledForZone(zone)){
        return;
      }

      if(!swapSelection){
        swapSelection = { teamId, zone };
        render();
        return;
      }

      // Clicking same card cancels
      if(swapSelection.teamId === teamId && swapSelection.zone === zone){
        swapSelection = null;
        render();
        return;
      }

      // Different zone = re-arm within new editable zone
      if(swapSelection.zone !== zone){
        swapSelection = { teamId, zone };
        render();
        return;
      }

      // Same zone: perform swap
      const arr = getZoneArray(zone);
      if(!arr) return;

      const ok = swapTeamsInArray(arr, swapSelection.teamId, teamId);
      swapSelection = null;

      if(ok){
        // If swapping in groups, third-ranking names should refresh automatically
        // If swapping in pools (pool mode), #1 changes for later Form Groups
      }

      render();
    }

    function attachClickSwap(card){
      card.addEventListener("click", () => {
        handleClickSwap(card.dataset.id, card.dataset.zone);
      });
    }

    /* ==============================
       12) Form Groups (COPY, don't move)
       - Works both first time and re-form
    ============================== */
    function upsertPathTeamInGroup(groupKey, pathId, chosenTeam){
      const arr = state.groups[groupKey];
      if(!arr) return;

      // 1) Replace placeholder if present
      const phIndex = arr.findIndex(t => t.isPlaceholder && t.pathId === pathId);
      if(phIndex !== -1){
        arr.splice(phIndex, 1, {
          id: toId(`grp-${groupKey}-${pathId}-${chosenTeam.name}`),
          name: chosenTeam.name,
          tag: PATH_BY_ID[pathId].label,
          chosenFromPath: true,
          pathId
        });
        return;
      }

      // 2) Otherwise, replace existing chosen-from-path entry
      const exIndex = arr.findIndex(t => t.chosenFromPath && t.pathId === pathId);
      if(exIndex !== -1){
        arr.splice(exIndex, 1, {
          id: toId(`grp-${groupKey}-${pathId}-${chosenTeam.name}`),
          name: chosenTeam.name,
          tag: PATH_BY_ID[pathId].label,
          chosenFromPath: true,
          pathId
        });
        return;
      }

      // 3) Fallback: append (should rarely happen)
      arr.push({
        id: toId(`grp-${groupKey}-${pathId}-${chosenTeam.name}`),
        name: chosenTeam.name,
        tag: PATH_BY_ID[pathId].label,
        chosenFromPath: true,
        pathId
      });
    }

    function formGroupsFromPools(){
      // Update groups from current #1 in each pool
      PATHS.forEach(p => {
        const pathArr = state.paths[p.id];
        if(!pathArr || pathArr.length === 0) return;

        const chosen = pathArr[0];
        upsertPathTeamInGroup(p.group, p.id, chosen);
        markQualifiedAndEliminated(p.id);
      });

      // Switch edit mode
      editMode = "groups";
      swapSelection = null;
      render();
    }

    function reformPoolMode(){
      // Lock groups, unlock pools, remove Q/E styling in visual terms
      editMode = "pools";
      swapSelection = null;
      clearPoolStatus();
      render();
    }

    /* ==============================
       13) Buttons + stage UI
    ============================== */
    function updateStagePillAndButtons(){
      const pill = document.getElementById("stagePill");
      const reformBtn = document.getElementById("reformPoolBtn");
      const formBtn = document.getElementById("formGroupsBtn");
      const genR32Btn = document.getElementById("generateR32Btn");
            if(genR32Btn){
              // allow generation only in group mode (optional but cleaner)
              genR32Btn.disabled = (editMode !== "groups");
            }

      

      if(pill){
        pill.textContent = editMode === "pools" ? "Edit: Pools" : "Edit: Groups";
      }

      if(reformBtn){
        reformBtn.disabled = (editMode === "pools");
      }

      if(formBtn){
        // Form Groups is meaningful only in pool edit mode
        formBtn.disabled = (editMode !== "pools");
      }
    }

    function wireButtons(){
      const resetBtn = document.getElementById("resetBtn");
      const reformBtn = document.getElementById("reformPoolBtn");
      const formBtn = document.getElementById("formGroupsBtn");
      const genR32Btn = document.getElementById("generateR32Btn");


      if(formBtn){
        formBtn.addEventListener("click", () => {
          if(editMode !== "pools") return;
          formGroupsFromPools();
        });
      }

      if(reformBtn){
        reformBtn.addEventListener("click", () => {
          reformPoolMode();
        });
      }

      if(resetBtn){
        resetBtn.addEventListener("click", () => {
          state = initialState();
          editMode = "pools";
          swapSelection = null;
          buildBoard();
          render();
          wireButtons(); // because Form Groups button is rebuilt
        });
      }

      if(genR32Btn){
            genR32Btn.addEventListener("click", () => {
              // reset winners, then generate
              state.r32Winners = {};
              state.r32Generated = true;
              render();
            });
          }

    }

    /* ==============================
       14) Boot
    ============================== */
    document.addEventListener("DOMContentLoaded", () => {
      buildBoard();
      render();
      wireButtons();
    });
  </script>
</body>
</html>
