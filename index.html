<!doctype html>
<html lang="en">
<head>
  <!-- =========================================================
       HEAD
       - Meta
       - Title
       - Viewport
       - Styles (theme + layout + drag UX)
  ========================================================== -->
  <meta charset="utf-8" />
  <title>World Cup 2026 Groups Drag-Drop (Mobile Safe Base)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    /* =========================================================
       CSS MAP
       1) Theme variables
       2) Global/base
       3) Header
       4) Board grid
       5) Column + dropzone
       6) Cards
       7) Drag states
       8) Buttons + footer
    ========================================================== */

    /* 1) Theme variables */
    :root{
      --bg:#0f1220;
      --panel:#151a2e;
      --panel-2:#111527;
      --text:#f5f7ff;
      --muted:#b9c0e6;
      --accent:#7aa2ff;
      --border:rgba(255,255,255,0.08);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;
    }

    /* 2) Global/base */
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: radial-gradient(1200px 800px at 10% 10%, #1c2342 0%, var(--bg) 40%, #070912 100%);
      min-height:100vh;
    }

    /* 3) Header */
    header{
      padding: 18px 20px 0 20px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap: wrap;
    }
    header h1{
      font-size: 18px;
      font-weight: 650;
      margin:0 0 2px 0;
      letter-spacing:0.2px;
    }
    header .hint{
      color:var(--muted);
      font-size: 11.5px;
    }
    .actions{
      display:flex;
      gap:8px;
      align-items:center;
    }

    /* 4) Board grid */
    .board{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
      padding: 14px 16px 30px 16px;
    }
    @media (min-width: 780px){
      .board{ grid-template-columns: 1fr 1fr; }
    }
    @media (min-width: 1100px){
      .board{ grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (min-width: 1400px){
      .board{ grid-template-columns: 1fr 1fr 1fr 1fr; }
    }

    /* 5) Column + dropzone */
    .column{
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      min-height: 180px;
      display:flex;
      flex-direction:column;
    }
    .column-header{
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid var(--border);
      gap: 10px;
    }
    .column-title{
      font-size: 12.5px;
      letter-spacing: 0.35px;
      text-transform: uppercase;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 70%;
    }
    .count{
      font-size: 10.5px;
      color: var(--muted);
      opacity: 0.9;
      white-space: nowrap;
    }

    .dropzone{
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
      flex: 1;
      transition: background 120ms ease, outline 120ms ease;
    }
    .dropzone.over{
      background: rgba(122,162,255,0.08);
      outline: 1px dashed rgba(122,162,255,0.5);
      outline-offset: -6px;
    }

    /* 6) Cards */
    .card{
      background: rgba(255,255,255,0.04);
      border:1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      cursor: grab;
      user-select: none;

      /* ✅ Critical mobile fix */
      touch-action: none;

      transition: transform 80ms ease, background 120ms ease, border-color 120ms ease;
    }
    .card:active{ cursor: grabbing; }

    .name{
      font-size: 13.8px;
      font-weight: 560;
      letter-spacing: 0.1px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .tag{
      font-size: 9.5px;
      color: var(--muted);
      border:1px solid var(--border);
      padding: 3px 6px;
      border-radius: 999px;
      white-space: nowrap;
    }

    /* 7) Drag states */
    .dragging{ opacity: 0.35; }

    .drag-clone{
      position: fixed;
      z-index: 9999;
      pointer-events: none;
      width: min(340px, 88vw);
      transform: translate(-50%, -50%);
      box-shadow: 0 18px 45px rgba(0,0,0,0.5);
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(8px);
    }

    /* 8) Buttons + footer */
    button{
      background: rgba(122,162,255,0.12);
      color: var(--text);
      border: 1px solid rgba(122,162,255,0.35);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 11px;
      cursor: pointer;
    }
    button:hover{
      background: rgba(122,162,255,0.18);
    }
    .footer{
      padding: 0 16px 24px 16px;
      color: var(--muted);
      font-size: 11px;
    }
  </style>
</head>

<body>
  <!-- =========================================================
       BODY / HTML STRUCTURE
       1) Header + actions
       2) Dynamic board container
       3) Footer
  ========================================================== -->

  <header>
    <div>
      <h1>World Cup 2026 Groups – Drag & Drop Base</h1>
      <div class="hint">Uses Pointer Events for reliable mobile dragging.</div>
    </div>
    <div class="actions">
      <button id="resetBtn">Reset Groups</button>
      <button id="clearPoolBtn">Clear Pool</button>
    </div>
  </header>

  <!-- Board will be built dynamically from DEFAULT_GROUPS -->
  <main class="board" id="board"></main>

  <div class="footer">
    This is a stable foundation. Next upgrades: group capacity rules (max 4), pool auto-fill, standings, and 3rd-place ranking.
  </div>

  <script>
 /* =========================================================
   World Cup 2026 Predictor – Qualifier Pools → Form Groups → Group Dragging
   COMPLETE JS (no pool column)

   What this version does (per your update):
   1) You can drag/reorder teams INSIDE qualifier pools (Paths).
   2) You can NOT drag from pools to groups.
   3) Groups are shown but "locked" during pool selection.
   4) When you click a button with id="formGroupsBtn",
      the TOP team of each Path list is selected and replaces
      its placeholder in the assigned group.
   5) After that, pool stage ends and group stage begins:
      - Pools become locked (no dragging)
      - Groups become draggable (reorder within each group)

   Required HTML:
     <main class="board" id="board"></main>
     <button id="formGroupsBtn">Form Groups</button>
   Optional:
     <button id="resetBtn">Reset</button>

   Notes:
   - Uses Pointer Events for mobile reliability.
   - Your CSS must include:
       .card { touch-action: none; }
     to prevent scroll during drag.
========================================================= */


/* ---------------------------------------------------------
   1) GROUPS with UPDATED placeholder names
--------------------------------------------------------- */
const DEFAULT_GROUPS = {
  A: ["Mexico","South Africa","South Korea","UFEA Path D"],
  B: ["Canada","UFEA Path A","Qatar","Switzerland"],
  C: ["Brazil","Morocco","Haiti","Scotland"],
  D: ["United States","Paraguay","Australia","UFEA Path C"],
  E: ["Germany","Curaçao","Ivory Coast","Ecuador"],
  F: ["Netherlands","Japan","UFEA Path B","Tunisia"],
  G: ["Belgium","Egypt","Iran","New Zealand"],
  H: ["Spain","Cape Verde","Saudi Arabia","Uruguay"],
  I: ["France","Senegal","FIFA IC Path 2","Norway"],
  J: ["Argentina","Algeria","Austria","Jordan"],
  K: ["Portugal","FIFA IC Path 1","Uzbekistan","Colombia"],
  L: ["England","Croatia","Ghana","Panama"]
};


/* ---------------------------------------------------------
   2) QUALIFIER POOLS (Paths) + where they feed
--------------------------------------------------------- */
const PATHS = [
  {
    id: "ufeapath-a",
    label: "UFEA Path A",
    candidates: ["Wales", "Bosnia and Herzegovina", "Italy", "Northern Ireland"],
    group: "B"
  },
  {
    id: "ufeapath-b",
    label: "UFEA Path B",
    candidates: ["Ukraine", "Sweden", "Poland", "Albania"],
    group: "F"
  },
  {
    id: "ufeapath-c",
    label: "UFEA Path C",
    candidates: ["Slovakia", "Kosovo", "Turkey", "Romania"],
    group: "D"
  },
  {
    id: "ufeapath-d",
    label: "UFEA Path D",
    candidates: ["Czech Republic", "Republic of Ireland", "Denmark", "North Macedonia"],
    group: "A"
  },
  {
    id: "fifaicpath-1",
    label: "FIFA IC Path 1",
    candidates: ["New Caledonia", "Jamaica", "DR Congo"],
    group: "K"
  },
  {
    id: "fifaicpath-2",
    label: "FIFA IC Path 2",
    candidates: ["Bolivia", "Suriname", "Iraq"],
    group: "I"
  }
];

const PATH_BY_ID = Object.fromEntries(PATHS.map(p => [p.id, p]));
const PATH_ID_BY_LABEL = Object.fromEntries(PATHS.map(p => [p.label, p.id]));


/* ---------------------------------------------------------
   3) Utilities
--------------------------------------------------------- */
const GROUP_KEYS = Object.keys(DEFAULT_GROUPS);

const toId = (name) =>
  name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");


/* ---------------------------------------------------------
   4) App stage control
     - "pools": only Path columns draggable
     - "groups": only Group columns draggable
--------------------------------------------------------- */
let stage = "pools";


/* ---------------------------------------------------------
   5) State constructor
--------------------------------------------------------- */
const initialState = () => {
  // Build path candidate arrays
  const paths = {};
  PATHS.forEach(p => {
    paths[p.id] = p.candidates.map(name => ({
      id: toId(`${p.id}-${name}`),
      name,
      tag: p.label,
      originPathId: p.id
    }));
  });

  // Build groups with placeholder objects
  const groups = {};
  GROUP_KEYS.forEach(g => {
    groups[g] = DEFAULT_GROUPS[g].map(entryName => {
      const pathId = PATH_ID_BY_LABEL[entryName];

      if (pathId) {
        return {
          id: `ph-${pathId}-${g}`,
          name: entryName,
          tag: "Placeholder",
          isPlaceholder: true,
          pathId
        };
      }

      return {
        id: toId(`${g}-${entryName}`),
        name: entryName,
        tag: `Group ${g}`
      };
    });
  });

  return { paths, groups };
};

let state = initialState();


/* ---------------------------------------------------------
   6) Zones
     - Path zones first
     - Group zones next
--------------------------------------------------------- */
const pathZones = PATHS.map(p => `path-${p.id}`);
const groupZones = GROUP_KEYS.map(g => `group-${g}`);
const zones = [...pathZones, ...groupZones];

const isPathZone = (zoneKey) => zoneKey.startsWith("path-");
const isGroupZone = (zoneKey) => zoneKey.startsWith("group-");
const pathIdFromZone = (zoneKey) => zoneKey.replace("path-", "");
const groupKeyFromZone = (zoneKey) => {
  const m = zoneKey.match(/^group-([A-L])$/);
  return m ? m[1] : null;
};


/* ---------------------------------------------------------
   7) Board builder with clear separation
     - Adds visual separators using simple elements
     - If your CSS doesn't style these classes, it's still fine
--------------------------------------------------------- */
function makeSeparator(text){
  const sep = document.createElement("div");
  sep.className = "stage-separator";
  // Inline style to force spanning across grid without needing extra CSS
  sep.style.gridColumn = "1 / -1";
  sep.style.padding = "10px 6px 2px 6px";
  sep.style.fontSize = "11px";
  sep.style.letterSpacing = "0.35px";
  sep.style.textTransform = "uppercase";
  sep.style.color = "rgba(255,255,255,0.55)";
  sep.textContent = text;
  return sep;
}

function makeColumn(title, zoneKey, subtitle = ""){
  const col = document.createElement("section");
  col.className = "column";
  col.dataset.zoneOwner = zoneKey;

  col.innerHTML = `
    <div class="column-header">
      <div class="column-title">${title}${subtitle ? ` • ${subtitle}` : ""}</div>
      <div class="count" data-count-for="${zoneKey}"></div>
    </div>
    <div class="dropzone" data-zone="${zoneKey}"></div>
  `;
  return col;
}

function buildBoard(){
  const board = document.getElementById("board");
  if(!board) return;

  board.innerHTML = "";

  // ---- Pool selection stage region ----
  board.appendChild(makeSeparator("Qualifier Pools (reorder to rank)"));

  PATHS.forEach(p => {
    board.appendChild(
      makeColumn(p.label, `path-${p.id}`, `feeds Group ${p.group}`)
    );
  });

  // ---- Group stage region ----
  board.appendChild(makeSeparator("Group Stage (unlocks after 'Form Groups')"));

  GROUP_KEYS.forEach(g => {
    board.appendChild(
      makeColumn(`Group ${g}`, `group-${g}`)
    );
  });
}


/* ---------------------------------------------------------
   8) Zone data access
--------------------------------------------------------- */
function getZoneArray(zoneKey){
  if (isPathZone(zoneKey)) {
    const id = pathIdFromZone(zoneKey);
    return state.paths[id];
  }
  if (isGroupZone(zoneKey)) {
    const g = groupKeyFromZone(zoneKey);
    return state.groups[g];
  }
  return null;
}


/* ---------------------------------------------------------
   9) Render
     - Creates cards for each zone
     - Attaches drag only if allowed by stage
     - Placeholders are never draggable
--------------------------------------------------------- */
function isDragEnabledForZone(zoneKey){
  if(stage === "pools") return isPathZone(zoneKey);
  if(stage === "groups") return isGroupZone(zoneKey);
  return false;
}

function render(){
  zones.forEach(zone => {
    const dz = document.querySelector(`.dropzone[data-zone="${zone}"]`);
    if(!dz) return;

    dz.innerHTML = "";

    const arr = getZoneArray(zone) ?? [];

    arr.forEach(team => {
      const card = document.createElement("div");
      card.className = "card";
      card.dataset.id = team.id;
      card.dataset.zone = zone;

      card.innerHTML = `
        <span class="name">${team.name}</span>
        <span class="tag">${team.tag ?? ""}</span>
      `;

      const canDrag =
        !team.isPlaceholder &&
        isDragEnabledForZone(zone);

      if(canDrag){
        attachPointerDrag(card);
      }

      dz.appendChild(card);
    });

    const countEl = document.querySelector(`[data-count-for="${zone}"]`);
    if(countEl){
      countEl.textContent = `${arr.length} item${arr.length !== 1 ? "s" : ""}`;
    }
  });

  // Optionally disable the form button after use
  const formBtn = document.getElementById("formGroupsBtn");
  if(formBtn){
    formBtn.disabled = (stage === "groups");
    formBtn.style.opacity = formBtn.disabled ? "0.6" : "1";
    formBtn.style.cursor = formBtn.disabled ? "not-allowed" : "pointer";
  }
}


/* ---------------------------------------------------------
   10) Reorder helper
     - Compute insertion index inside a dropzone based on Y
--------------------------------------------------------- */
function getInsertIndex(zoneEl, clientY){
  const cards = [...zoneEl.querySelectorAll(".card:not(.dragging)")];

  for(let i = 0; i < cards.length; i++){
    const r = cards[i].getBoundingClientRect();
    const mid = r.top + r.height / 2;
    if(clientY < mid) return i;
  }
  return cards.length;
}


/* ---------------------------------------------------------
   11) Find + drop logic
     - We only allow REORDER within the same zone.
     - No drag across pools/groups.
--------------------------------------------------------- */
function findTeamAndZone(teamId){
  for(const z of zones){
    const arr = getZoneArray(z);
    if(!arr) continue;

    const idx = arr.findIndex(t => t.id === teamId);
    if(idx !== -1) return { zone: z, index: idx, team: arr[idx] };
  }
  return null;
}

/**
 * Drop/reorder in the same zone.
 */
function reorderWithinZone(teamId, zoneEl, clientY){
  const toZone = zoneEl.dataset.zone;
  const arr = getZoneArray(toZone);
  if(!arr) return;

  const found = findTeamAndZone(teamId);
  if(!found) return;

  // Only reorder inside same zone
  if(found.zone !== toZone) return;

  // Remove team from array
  const [team] = arr.splice(found.index, 1);

  // Compute new insertion index
  let insertIndex = getInsertIndex(zoneEl, clientY);

  // If removing earlier element shifts index, adjust
  if(insertIndex > found.index) insertIndex -= 1;

  // Insert back
  arr.splice(insertIndex, 0, team);

  render();
}


/* ---------------------------------------------------------
   12) "Form Groups" button logic
     Rule:
       The TOP team of each Path list (index 0)
       replaces its placeholder in the assigned group.
     After forming:
       stage flips to "groups".
--------------------------------------------------------- */
function groupHasPlaceholder(groupKey, pathId){
  return state.groups[groupKey].some(t => t.isPlaceholder && t.pathId === pathId);
}

function replacePlaceholderWithTeam(groupKey, pathId, chosenTeam){
  const arr = state.groups[groupKey];
  const idx = arr.findIndex(t => t.isPlaceholder && t.pathId === pathId);

  // If placeholder not found, just append as safe fallback
  const insertionIndex = (idx === -1) ? arr.length : idx;

  // Remove placeholder if present
  if(idx !== -1) arr.splice(idx, 1);

  // Insert chosen team at that slot
  arr.splice(insertionIndex, 0, {
    ...chosenTeam,
    tag: PATH_BY_ID[pathId].label,
    chosenFromPath: true
  });
}

function formGroupsFromPools(){
  // For each path, pick the top-ranked team
  PATHS.forEach(p => {
    const pathArr = state.paths[p.id];
    if(!pathArr || pathArr.length === 0) return;

    const chosen = pathArr[0];

    // Only replace if placeholder exists (keeps logic clean)
    if(!groupHasPlaceholder(p.group, p.id)) return;

    // Remove chosen from path candidates
    pathArr.shift();

    // Replace placeholder in assigned group
    replacePlaceholderWithTeam(p.group, p.id, chosen);
  });

  // Pool stage ends here
  stage = "groups";

  render();
}


/* ---------------------------------------------------------
   13) Pointer drag engine (mobile-safe)
--------------------------------------------------------- */
function zoneFromPoint(x, y){
  const all = [...document.querySelectorAll(".dropzone")];
  return all.find(dz => {
    const r = dz.getBoundingClientRect();
    return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
  });
}

let dragging = null;

function attachPointerDrag(card){
  card.addEventListener("pointerdown", (e) => {
    if(e.button !== undefined && e.button !== 0) return;

    e.preventDefault();

    const teamId = card.dataset.id;
    const fromZone = card.dataset.zone;

    // Hard gate: only allow drag if zone is enabled for this stage
    if(!isDragEnabledForZone(fromZone)) return;

    const rect = card.getBoundingClientRect();

    const clone = card.cloneNode(true);
    clone.classList.add("drag-clone");
    document.body.appendChild(clone);

    card.classList.add("dragging");

    dragging = {
      teamId,
      originCard: card,
      clone,
      pointerId: e.pointerId,
      fromZone,
      offsetX: e.clientX - (rect.left + rect.width / 2),
      offsetY: e.clientY - (rect.top + rect.height / 2),
      lastZoneEl: null
    };

    card.setPointerCapture(e.pointerId);
    positionClone(e.clientX, e.clientY);
  });

  card.addEventListener("pointermove", (e) => {
    if(!dragging || dragging.pointerId !== e.pointerId) return;

    e.preventDefault();

    positionClone(e.clientX, e.clientY);

    const zoneEl = zoneFromPoint(e.clientX, e.clientY);

    if(zoneEl !== dragging.lastZoneEl){
      document.querySelectorAll(".dropzone")
        .forEach(z => z.classList.remove("over"));

      if(zoneEl) zoneEl.classList.add("over");

      dragging.lastZoneEl = zoneEl;
    }
  });

  card.addEventListener("pointerup", (e) => {
    if(!dragging || dragging.pointerId !== e.pointerId) return;
    e.preventDefault();
    finishDrag(e.clientX, e.clientY);
  });

  card.addEventListener("pointercancel", (e) => {
    if(!dragging || dragging.pointerId !== e.pointerId) return;
    finishDrag(null, null, true);
  });
}

function positionClone(x, y){
  if(!dragging) return;
  dragging.clone.style.left = `${x - dragging.offsetX}px`;
  dragging.clone.style.top  = `${y - dragging.offsetY}px`;
}

function finishDrag(x, y, cancelled=false){
  const { teamId, originCard, clone, fromZone } = dragging;

  document.querySelectorAll(".dropzone")
    .forEach(z => z.classList.remove("over"));

  originCard.classList.remove("dragging");
  clone.remove();

  if(!cancelled && x !== null && y !== null){
    const zoneEl = zoneFromPoint(x, y);
    if(zoneEl){
      const toZone = zoneEl.dataset.zone;

      // Only allow reorder within same zone
      if(toZone === fromZone){
        reorderWithinZone(teamId, zoneEl, y);
      }
      // Otherwise ignore (no cross-zone dragging)
    }
  }

  dragging = null;
}


/* ---------------------------------------------------------
   14) Buttons wiring
--------------------------------------------------------- */
function wireButtons(){
  const formBtn = document.getElementById("formGroupsBtn");
  if(formBtn){
    formBtn.addEventListener("click", () => {
      if(stage === "groups") return;
      formGroupsFromPools();
    });
  }

  const resetBtn = document.getElementById("resetBtn");
  if(resetBtn){
    resetBtn.addEventListener("click", () => {
      state = initialState();
      stage = "pools";
      buildBoard();
      render();
    });
  }
}


/* ---------------------------------------------------------
   15) Boot
--------------------------------------------------------- */
document.addEventListener("DOMContentLoaded", () => {
  buildBoard();
  render();
  wireButtons();
});



  </script>
</body>
</html>
