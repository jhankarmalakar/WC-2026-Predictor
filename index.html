<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>World Cup 2026 – Pools → Groups → Knockouts</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg:#0f1220;
      --panel:#151a2e;
      --panel-2:#111527;
      --text:#f5f7ff;
      --muted:#b9c0e6;
      --accent:#7aa2ff;
      --accent-2:#5ee6ff;
      --border:rgba(255,255,255,0.08);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;

      /* Rank highlights */
      --hl-strong-bg: rgba(94, 230, 168, 0.14);
      --hl-strong-br: rgba(94, 230, 168, 0.45);
      --hl-mild-bg:   rgba(122, 162, 255, 0.10);
      --hl-mild-br:   rgba(122, 162, 255, 0.35);

      /* Qualified styling */
      --qualified-br: rgba(94, 230, 168, 0.55);
      --qualified-glow: rgba(94, 230, 168, 0.18);

      /* Eliminated styling */
      --elim-bg: rgba(255, 107, 122, 0.08);
      --elim-br: rgba(255, 107, 122, 0.35);

      /* Click-swap armed styling (amber) */
      --swap-bg: rgba(255, 184, 107, 0.14);
      --swap-br: rgba(255, 184, 107, 0.55);

      /* Winner highlight */
      --win-bg: rgba(122, 255, 187, 0.18);
      --win-br: rgba(122, 255, 187, 0.70);
      --win-glow: rgba(122, 255, 187, 0.22);

      /* Orange action buttons */
      --orange-bg-1: rgba(255, 168, 64, 0.28);
      --orange-bg-2: rgba(255, 122, 64, 0.18);
      --orange-br:   rgba(255, 170, 90, 0.70);

      /* Green primary action */
      --green-bg-1: rgba(94, 230, 168, 0.26);
      --green-bg-2: rgba(94, 230, 168, 0.12);
      --green-br:   rgba(94, 230, 168, 0.75);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: radial-gradient(1200px 800px at 10% 10%, #1c2342 0%, var(--bg) 40%, #070912 100%);
      min-height:100vh;
    }

    header{
      padding: 18px 20px 8px 20px;
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap: wrap;
    }
    header h1{
      font-size: 19px;
      font-weight: 700;
      margin:0 0 8px 0;
      letter-spacing: 0.2px;
    }
    header .hint{
      color:var(--muted);
      font-size: 12.5px;
      line-height: 1.45;
      max-width: 95ch;
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .hint-line{ padding-left: 2px; }

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
      padding-top: 2px;
    }

    /* Base buttons */
    button{
      background: linear-gradient(135deg, rgba(122,162,255,0.22), rgba(94,230,255,0.12));
      color: var(--text);
      border: 1px solid rgba(122,162,255,0.55);
      padding: 11px 14px;
      border-radius: 12px;
      font-size: 12.5px;
      cursor: pointer;
      white-space: nowrap;
      box-shadow: 0 0 0 1px rgba(122,162,255,0.08) inset;
    }
    button:hover{
      background: linear-gradient(135deg, rgba(122,162,255,0.30), rgba(94,230,255,0.18));
    }
    button:disabled{ opacity: 0.55; cursor: not-allowed; }

    .btn-mini{
      padding: 8px 10px;
      font-size: 11px;
      border-radius: 10px;
    }

    /* Orange action buttons */
    .btn-orange{
      background: linear-gradient(135deg, var(--orange-bg-1), var(--orange-bg-2));
      border: 1px solid var(--orange-br);
      box-shadow:
        0 0 0 1px rgba(255,170,90,0.10) inset,
        0 6px 16px rgba(0,0,0,0.18);
    }
    .btn-orange:hover{
      background: linear-gradient(135deg, rgba(255, 180, 90, 0.35), rgba(255, 120, 70, 0.22));
    }

    /* Green primary button */
    .btn-green{
      background: linear-gradient(135deg, var(--green-bg-1), var(--green-bg-2));
      border: 1px solid var(--green-br);
      box-shadow:
        0 0 0 1px rgba(94,230,168,0.10) inset,
        0 6px 16px rgba(0,0,0,0.18);
    }
    .btn-green:hover{
      background: linear-gradient(135deg, rgba(94,230,168,0.34), rgba(94,230,168,0.18));
    }

    /* ==========================
       R32 out-of-date badge
    ========================== */
    .outofdate-badge{
      display: inline-block;
      margin-left: 8px;
      padding: 2px 7px;
      font-size: 9px;
      font-weight: 800;
      letter-spacing: 0.25px;
      border-radius: 999px;
      border: 1px solid rgba(255, 184, 107, 0.70);
      background: rgba(255, 184, 107, 0.16);
      color: var(--text);
      vertical-align: middle;
      line-height: 1.1;

      animation: badgeGlowPulse 1.8s ease-in-out infinite;
      transform-origin: left center;
    }
    @keyframes badgeGlowPulse{
      0%, 100%{
        box-shadow:
          0 0 0 0 rgba(255,184,107,0.00),
          0 0 0 0 rgba(255,184,107,0.00);
        filter: saturate(1);
        transform: scale(1);
      }
      50%{
        box-shadow:
          0 0 0 2px rgba(255,184,107,0.18),
          0 0 10px rgba(255,184,107,0.22);
        filter: saturate(1.08);
        transform: scale(1.03);
      }
    }
    @media (prefers-reduced-motion: reduce){
      .outofdate-badge{ animation: none; }
    }

    /* Board grid */
    .board{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
      padding: 8px 16px 30px 16px;
    }
    @media (min-width: 780px){
      .board{ grid-template-columns: 1fr 1fr; }
    }
    @media (min-width: 1100px){
      .board{ grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (min-width: 1400px){
      .board{ grid-template-columns: 1fr 1fr 1fr 1fr; }
    }

    /* Stage separators */
    .stage-separator{
      grid-column: 1 / -1;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 14px 6px 4px 6px;
      flex-wrap: wrap;
    }
    .stage-left{
      display:flex;
      align-items:center;
      gap: 12px;
      min-width: 0;
      flex: 1;
    }
    .stage-title{
      font-size: 14.5px;
      font-weight: 800;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.80);
      white-space: nowrap;
    }
    .stage-line{
      height: 1px;
      background: var(--border);
      flex: 1;
      min-width: 30px;
    }
    .stage-right{
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap: wrap;
    }

    /* Column */
    .column{
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      min-height: 160px;
      display:flex;
      flex-direction:column;
    }
    .column-header{
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid var(--border);
      gap: 10px;
    }
    .column-title{
      font-size: 12.2px;
      letter-spacing: 0.35px;
      text-transform: uppercase;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 80%;
    }
    .count{
      font-size: 10.5px;
      color: var(--muted);
      opacity: 0.9;
      white-space: nowrap;
    }

    .zone{
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
      flex: 1;
    }

    .zone-moved-indicator{
        margin-left: 6px;
        font-size: 9.5px;
        font-weight: 700;
        letter-spacing: 0.2px;
        padding: 2px 6px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.10);
        background: rgba(255,255,255,0.06);
        color: var(--muted);
        display: inline-block;
      }

    /* Zone-level "User moved" badge (header) */
    .zone-moved-badge{
      display: none;
      margin-left: 8px;
      padding: 2px 8px;
      font-size: 9.5px;
      font-weight: 700;
      letter-spacing: 0.25px;
      border-radius: 999px;

      color: var(--text);
      border: 1px solid rgba(122,162,255,0.45);
      background: rgba(122,162,255,0.10);

      vertical-align: middle;
      line-height: 1.15;
      box-shadow: 0 0 0 1px rgba(122,162,255,0.06) inset;
    }
    .zone-moved-badge.zone-moved-warm{
      border-color: rgba(255,184,107,0.60);
      background: rgba(255,184,107,0.12);
      box-shadow: 0 0 0 1px rgba(255,184,107,0.08) inset;
    }

    /* Card */
    .card{
      background: rgba(255,255,255,0.04);
      border:1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      user-select: none;
      cursor: pointer;
      transition: background 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
    }
    .card.locked{
      cursor: default;
      opacity: 0.9;
    }

    .name{
      font-size: 13.8px;
      font-weight: 560;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display:flex;
      align-items:center;
      gap: 0;
      min-width: 0;
    }
    .tag{
      font-size: 9.8px;
      color: var(--muted);
      border:1px solid var(--border);
      padding: 3px 7px;
      border-radius: 999px;
      white-space: nowrap;
    }

    /* Rank highlights */
    .rank-strong{
      background: var(--hl-strong-bg);
      border-color: var(--hl-strong-br);
    }
    .rank-mild{
      background: var(--hl-mild-bg);
      border-color: var(--hl-mild-br);
    }

    /* Qualified/Eliminated */
    .qualified{
      border-color: var(--qualified-br);
      box-shadow: 0 0 0 1px var(--qualified-glow) inset;
    }
    .eliminated{
      background: var(--elim-bg);
      border-color: var(--elim-br);
    }

    /* First-click armed swap */
    .swap-armed{
      background: var(--swap-bg);
      border-color: var(--swap-br);
      box-shadow: 0 0 0 1px rgba(255,184,107,0.18) inset;
    }

    .footer{
      padding: 0 16px 24px 16px;
      color: var(--muted);
      font-size: 11px;
    }

    .top8-summary{
      margin-top: 10px;
      padding: 10px 12px;
      font-size: 14px;
      font-weight: 800;
      color: var(--text);
      border: 1px dashed var(--border);
      border-radius: 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-align: center;
      background: rgba(255,255,255,0.03);
    }

    /* Flag images */
    .flag-img{
      width: 16px;
      height: 12px;
      object-fit: cover;
      border-radius: 2px;
      margin-right: 6px;
      vertical-align: -1px;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.08);
      flex: 0 0 auto;
    }

    /* ==========================
       Knockout layout + section border
    ========================== */
    .ko-section{
      grid-column: 1 / -1;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px;
      box-shadow: var(--shadow);
    }

    /* Mild different tints per stage */
    .ko-r32{
      background: linear-gradient(180deg, rgba(122,162,255,0.08), rgba(122,162,255,0.02));
    }
    .ko-r16{
      background: linear-gradient(180deg, rgba(94,230,168,0.08), rgba(94,230,168,0.02));
    }
    .ko-qf{
      background: linear-gradient(180deg, rgba(94,230,255,0.08), rgba(94,230,255,0.02));
    }
    .ko-sf{
      background: linear-gradient(180deg, rgba(255,184,107,0.08), rgba(255,184,107,0.02));
    }
    .ko-third{
      background: linear-gradient(180deg, rgba(255,107,122,0.07), rgba(255,107,122,0.02));
    }
    .ko-final{
      background: linear-gradient(180deg, rgba(122,255,187,0.08), rgba(122,255,187,0.02));
    }

    .ko-grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 780px){
      .ko-grid{ grid-template-columns: 1fr 1fr; }
    }
    @media (min-width: 1100px){
      .ko-grid{ grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (min-width: 1400px){
      .ko-grid{ grid-template-columns: 1fr 1fr 1fr 1fr; }
    }

    /* Centered rounds (SF/3P/Final) */
    .ko-grid.centered{
      grid-template-columns: 1fr;
      justify-items: center;
    }
    .ko-grid.centered .match-card{
      width: min(760px, 100%);
    }

    .match-card{
      background: rgba(255,255,255,0.035);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px 12px 10px 12px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 10px 10px;
      align-items: center;
      position: relative;
      overflow: hidden;
    }

    /* Match index top-left */
    .match-index{
      position:absolute;
      top: 8px;
      left: 10px;
      font-size: 10px;
      font-weight: 800;
      letter-spacing: 0.4px;
      color: rgba(255,255,255,0.7);
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
    }

    /* Center label above the mid box */
    .match-vs{
      grid-column: 1 / -1;
      text-align: center;
      font-weight: 800;
      font-size: 12.2px;
      letter-spacing: 0.35px;
      color: rgba(255,255,255,0.9);
      margin-top: 2px;
      margin-bottom: 2px;
    }

    .match-team{
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      font-size: 12.8px;
      cursor: pointer;
      text-align: center;
      user-select: none;
      transition: background 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
    }
    .match-team.locked{
      cursor: default;
      opacity: 0.9;
    }

    .match-team.winning{
      background: var(--win-bg);
      border-color: var(--win-br);
      box-shadow:
        0 0 0 1px var(--win-glow) inset,
        0 0 14px rgba(122,255,187,0.12);
    }

    .match-mid{
      min-width: 56px;
      text-align: center;
      font-weight: 900;
      font-size: 12.5px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
      letter-spacing: 1px;
    }

    /* Bottom meta */
    .match-bottom{
      grid-column: 1 / -1;
      display:flex;
      justify-content: space-between;
      gap: 10px;
      margin-top: 2px;
      color: var(--muted);
      flex-wrap: wrap;
    }
    .match-bottom .chip{
      display:inline-block;
      padding: 3px 7px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: rgba(255,255,255,0.04);
      font-size: 10.8px;
      white-space: nowrap;
    }

    .r32-note{
      margin-top: 8px;
      font-size: 10.8px;
      color: var(--muted);
      opacity: 0.9;
    }

    /* ==========================
       PRINT MODAL
    ========================== */
    .modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 14px;
    }
    .modal-backdrop.show{ display: flex; }

    .modal{
      width: min(980px, 100%);
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .modal-head{
      padding: 14px 16px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
      gap: 10px;
    }
    .modal-title{
      font-size: 13.5px;
      font-weight: 800;
      letter-spacing: 0.4px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.85);
    }
    .modal-body{
      padding: 14px 16px 6px 16px;
      display:grid;
      gap: 12px;
    }
    .modal-preview{
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(255,255,255,0.03);
      padding: 10px;
      display:flex;
      justify-content: center;
      align-items: center;
      min-height: 220px;
    }
    .modal-preview img{
      max-width: 100%;
      height: auto;
      border-radius: 10px;
      box-shadow: 0 8px 22px rgba(0,0,0,0.28);
    }
    .modal-foot{
      padding: 12px 16px 16px 16px;
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      border-top: 1px solid var(--border);
    }
    .modal-note{
      font-size: 11px;
      color: var(--muted);
    }
  </style>
</head>

<body>
  <header>
    <div>
      <h1>Qualifier Pools → Groups → Third Ranking → Knockouts</h1>
      <div class="hint">
        <div class="hint-line">Click/tap two teams in the same editable zone to swap positions.</div>
        <div class="hint-line">Use “Place qualifiers to the groups” to copy pool winners into groups.</div>
        <div class="hint-line">
          R32 third-place assignments are frozen once generated — reordering the Third Ranking won’t update R32
          and subsequent fixtures until you click “Regenerate R32”.
        </div>
      </div>
    </div>

    <div class="actions">
      <button id="clearMovedBtn">Clear moved flags</button>
      <button id="resetBtn">Reset ALL</button>
    </div>
  </header>

  <main class="board" id="board"></main>

  <div class="footer">
    Pools editable only in Pool mode. Groups + Third-place ranking editable only in Group mode.
  </div>

  <!-- ==========================
       PRINT RESULT MODAL
  ========================== -->
  <div id="printModalBackdrop" class="modal-backdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="printModalTitle">
      <div class="modal-head">
        <div class="modal-title" id="printModalTitle">Your Knockout Bracket Image</div>
        <button id="closePrintModal" class="btn-mini">Close</button>
      </div>
      <div class="modal-body">
        <div class="modal-note">
          This image includes your path from <b>R16 → QF → SF → Final + 3rd Place</b> using <b>FLAG + ABBR</b>.
        </div>
        <div class="modal-preview">
          <img id="printPreviewImg" alt="Prediction preview" />
        </div>
      </div>
      <div class="modal-foot">
        <button id="viewPrintImgBtn" class="btn-orange">View image</button>
        <button id="downloadPrintImgBtn" class="btn-green">Download PNG</button>
      </div>
    </div>
  </div>

  <script>
    /* ==============================
       1) GROUPS + PATHS
    ============================== */
    const DEFAULT_GROUPS = {
      A: ["Mexico","South Africa","South Korea","UFEA Path D"],
      B: ["Canada","UFEA Path A","Qatar","Switzerland"],
      C: ["Brazil","Morocco","Haiti","Scotland"],
      D: ["United States","Paraguay","Australia","UFEA Path C"],
      E: ["Germany","Curaçao","Ivory Coast","Ecuador"],
      F: ["Netherlands","Japan","UFEA Path B","Tunisia"],
      G: ["Belgium","Egypt","Iran","New Zealand"],
      H: ["Spain","Cape Verde","Saudi Arabia","Uruguay"],
      I: ["France","Senegal","FIFA IC Path 2","Norway"],
      J: ["Argentina","Algeria","Austria","Jordan"],
      K: ["Portugal","FIFA IC Path 1","Uzbekistan","Colombia"],
      L: ["England","Croatia","Ghana","Panama"]
    };

    const PATHS = [
      { id: "ufeapath-a", label: "UFEA Path A",
        candidates: ["Wales", "Bosnia and Herzegovina", "Italy", "Northern Ireland"], group: "B" },
      { id: "ufeapath-b", label: "UFEA Path B",
        candidates: ["Ukraine", "Sweden", "Poland", "Albania"], group: "F" },
      { id: "ufeapath-c", label: "UFEA Path C",
        candidates: ["Slovakia", "Kosovo", "Turkey", "Romania"], group: "D" },
      { id: "ufeapath-d", label: "UFEA Path D",
        candidates: ["Czech Republic", "Republic of Ireland", "Denmark", "North Macedonia"], group: "A" },
      { id: "fifaicpath-1", label: "FIFA IC Path 1",
        candidates: ["New Caledonia", "Jamaica", "DR Congo"], group: "K" },
      { id: "fifaicpath-2", label: "FIFA IC Path 2",
        candidates: ["Bolivia", "Suriname", "Iraq"], group: "I" }
    ];

    const PATH_BY_ID = Object.fromEntries(PATHS.map(p => [p.id, p]));
    const PATH_ID_BY_LABEL = Object.fromEntries(PATHS.map(p => [p.label, p.id]));
    const GROUP_KEYS = Object.keys(DEFAULT_GROUPS);

    const toId = (name) =>
      String(name || "")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/(^-|-$)/g, "");

    /* ==============================
       2) Rank + odds models (AUTO)
    ============================== */
    const RANK_BY_NAME = {
      "Spain":1,
      "Argentina":2,
      "France":3,
      "England":4,
      "Brazil":5,
      "Portugal":6,
      "Netherlands":7,
      "Belgium":8,
      "Germany":9,
      "Croatia":10,
      "Morocco":11,
      "Italy":12,
      "Colombia":13,
      "United States":14,
      "USA":14,
      "Mexico":15,
      "Uruguay":16,
      "Switzerland":17,
      "Japan":18,
      "Senegal":19,
      "Iran":20,
      "Denmark":21,
      "South Korea":22,
      "Ecuador":23,
      "Austria":24,
      "Turkey":25,
      "Türkiye":25,
      "Australia":26,
      "Canada":27,
      "Ukraine":28,
      "Norway":29,
      "Panama":30,
      "Poland":31,
      "Wales":32,
      "Scotland":36,
      "Serbia":37,
      "Nigeria":38,
      "Czechia":39,
      "Czech Republic":39,
      "Tunisia":40,
      "Ivory Coast":42,
      "Côte d'Ivoire":42,
      "Sweden":43,
      "Slovakia":45,
      "Romania":47,
      "Uzbekistan":50,
      "Qatar":51,
      "Saudi Arabia":60,
      "South Africa":61,
      "Albania":63,
      "Jordan":64,
      "Cape Verde":68,
      "Cabo Verde":68,
      "Jamaica":70,
      "Kosovo":80,
      "Curaçao":82,
      "New Zealand":104
    };

    const ODDS_POSITIVE = {
      "Spain": 400,
      "England": 550,
      "France": 700,
      "Brazil": 750,
      "Argentina": 800,
      "Germany": 1200,
      "Portugal": 1200,
      "Netherlands": 1200
    };

    function rankOf(name){
      if(!name) return 999;
      return RANK_BY_NAME[name] ?? 999;
    }

    function impliedProbFromPositiveOdds(x){
      return 100 / (x + 100);
    }

    function pickWinnerNameAuto(a, b){
      const aOdds = ODDS_POSITIVE[a];
      const bOdds = ODDS_POSITIVE[b];

      if(aOdds && bOdds){
        const pa = impliedProbFromPositiveOdds(aOdds);
        const pb = impliedProbFromPositiveOdds(bOdds);
        const sum = pa + pb;
        const ra = pa / sum;
        return Math.random() < ra ? a : b;
      }

      const ra = rankOf(a);
      const rb = rankOf(b);
      if(ra === rb){
        return String(a).localeCompare(String(b)) <= 0 ? a : b;
      }
      return ra < rb ? a : b;
    }

    /* ==============================
       3) Flags (image-based for DOM)
    ============================== */
    const FLAG_CODE_BY_NAME = {
      "Mexico":"mx",
      "South Africa":"za",
      "South Korea":"kr",
      "Canada":"ca",
      "Qatar":"qa",
      "Switzerland":"ch",
      "Brazil":"br",
      "Morocco":"ma",
      "Haiti":"ht",
      "Scotland":"gb",
      "United States":"us",
      "United States of America":"us",
      "USA":"us",
      "Paraguay":"py",
      "Australia":"au",
      "Germany":"de",
      "Curaçao":"cw",
      "Ivory Coast":"ci",
      "Côte d'Ivoire":"ci",
      "Ecuador":"ec",
      "Netherlands":"nl",
      "Japan":"jp",
      "Tunisia":"tn",
      "Belgium":"be",
      "Egypt":"eg",
      "Iran":"ir",
      "New Zealand":"nz",
      "Spain":"es",
      "Cape Verde":"cv",
      "Cabo Verde":"cv",
      "Saudi Arabia":"sa",
      "Uruguay":"uy",
      "France":"fr",
      "Senegal":"sn",
      "Norway":"no",
      "Argentina":"ar",
      "Algeria":"dz",
      "Austria":"at",
      "Jordan":"jo",
      "Portugal":"pt",
      "Uzbekistan":"uz",
      "Colombia":"co",
      "England":"gb",
      "Croatia":"hr",
      "Ghana":"gh",
      "Panama":"pa",
      "Wales":"gb",
      "Bosnia and Herzegovina":"ba",
      "Italy":"it",
      "Northern Ireland":"gb",
      "Ukraine":"ua",
      "Sweden":"se",
      "Poland":"pl",
      "Albania":"al",
      "Slovakia":"sk",
      "Kosovo":"xk",
      "Turkey":"tr",
      "Türkiye":"tr",
      "Romania":"ro",
      "Czech Republic":"cz",
      "Czechia":"cz",
      "Republic of Ireland":"ie",
      "Denmark":"dk",
      "North Macedonia":"mk",
      "New Caledonia":"nc",
      "Jamaica":"jm",
      "DR Congo":"cd",
      "Bolivia":"bo",
      "Suriname":"sr",
      "Iraq":"iq",
      "Serbia":"rs",
      "Nigeria":"ng"
    };

    function flagHTML(name){
      if(!name) return "";
      if(
        name.startsWith("UEFA Path") ||
        name.startsWith("FIFA IC Path") ||
        name.includes("UFEA Path") ||
        name.includes("FIFA IC Path")
      ) return "";

      const code = FLAG_CODE_BY_NAME[name];
      if(!code) return "";
      return `<img class="flag-img" src="https://flagcdn.com/w20/${code}.png" alt="${code} flag" loading="lazy">`;
    }
    function nameWithFlagHTML(name){
      return `${flagHTML(name)}${name ?? ""}`;
    }

    /* ==============================
       3b) Flags for CANVAS (emoji)
    ============================== */
    function isoToFlagEmoji(iso){
      if(!iso || iso.length !== 2) return "";
      const cc = iso.toUpperCase();
      const A = 0x1F1E6;
      const base = "A".charCodeAt(0);
      const c1 = cc.charCodeAt(0) - base;
      const c2 = cc.charCodeAt(1) - base;
      if(c1 < 0 || c2 < 0) return "";
      return String.fromCodePoint(A + c1, A + c2);
    }
    function flagEmojiForName(name){
      if(!name) return "";
      if(name.startsWith("UEFA Path") || name.startsWith("FIFA IC Path") || name.includes("UFEA Path")) return "";
      const code = FLAG_CODE_BY_NAME[name];
      // Kosovo "xk" isn't a standard flag emoji in many fonts
      if(code === "xk") return "";
      if(!code || code.length !== 2) return "";
      return isoToFlagEmoji(code);
    }

    /* ==============================
       4) Edit mode + click-swap state
    ============================== */
    let editMode = "pools";
    let swapSelection = null;

    let qualifiedThirdGroupLetters = "";
    let qualifiedThirdPlacedTeams = [];

    let thirdRankingDirty = false;

    /* ==============================
       5) Build state
    ============================== */
    function buildGroupsFromDefaults(){
      const groups = {};
      GROUP_KEYS.forEach(g => {
        groups[g] = DEFAULT_GROUPS[g].map(entryName => {
          const pathId = PATH_ID_BY_LABEL[entryName];
          if(pathId){
            return {
              id: `ph-${pathId}-${g}`,
              name: entryName,
              tag: "Placeholder",
              isPlaceholder: true,
              pathId,
              userMoved: false
            };
          }
          return {
            id: toId(`${g}-${entryName}`),
            name: entryName,
            tag: `Group ${g}`,
            isPlaceholder: false,
            userMoved: false
          };
        });
      });
      return groups;
    }

    function buildPaths(){
      const paths = {};
      PATHS.forEach(p => {
        paths[p.id] = p.candidates.map(name => ({
          id: toId(`${p.id}-${name}`),
          name,
          tag: p.label,
          originPathId: p.id,
          isQualified: false,
          isEliminated: false,
          userMoved: false
        }));
      });
      return paths;
    }

    function fallbackPathNameForGroup(g){
      const p = PATHS.find(x => x.group === g);
      if(!p) return "TBD";

      if(p.id.startsWith("ufeapath-")){
        const letter = p.id.replace("ufeapath-","");
        const map = { a: 1, b: 2, c: 3, d: 4 };
        const n = map[letter] ?? letter.toUpperCase();
        return `UEFA Path ${n}`;
      }
      if(p.id.startsWith("fifaicpath-")){
        const n = p.id.replace("fifaicpath-","");
        return `FIFA IC Path ${n}`;
      }
      return p.label;
    }

    function buildThirdRankingFromGroups(groups){
      const base = [];
      GROUP_KEYS.forEach(g => {
        const third = groups[g]?.[2];
        base.push({
          id: toId(`third-${g}`),
          groupKey: g,
          name: third?.name ?? fallbackPathNameForGroup(g),
          userMoved: false
        });
      });
      return base;
    }

    const initialState = () => {
      const groups = buildGroupsFromDefaults();
      const paths  = buildPaths();
      const qualifiedByPath = {};
      PATHS.forEach(p => qualifiedByPath[p.id] = false);

      return {
        paths,
        groups,
        qualifiedByPath,
        thirdRanking: buildThirdRankingFromGroups(groups),

        r32Generated: false,
        winners: {},
        r32ThirdSnapshot: null
      };
    };

    let state = initialState();

    /* ==============================
       6) Zones
    ============================== */
    const pathZones  = PATHS.map(p => `path-${p.id}`);
    const groupZones = GROUP_KEYS.map(g => `group-${g}`);

    const THIRD_RANK_ZONE = "third-ranking";
    const CHAMP_ZONE      = "champions-view";
    const RUNNERS_ZONE    = "runners-view";
    const TOP8_ZONE       = "top8-third-view";

    const zones = [
      ...pathZones,
      ...groupZones,
      THIRD_RANK_ZONE,
      CHAMP_ZONE,
      RUNNERS_ZONE,
      TOP8_ZONE
    ];

    const isPathZone = (z) => z.startsWith("path-");
    const isGroupZone = (z) => z.startsWith("group-");
    const pathIdFromZone = (z) => z.replace("path-","");
    const groupKeyFromZone = (z) => {
      const m = z.match(/^group-([A-L])$/);
      return m ? m[1] : null;
    };

    /* ==============================
       7) KO structure
    ============================== */
    const R32_INFO = {
      73: { date: "June 28, 2026", time: "12:00 p.m.", offsetHours:-7, stadium: "SoFi Stadium", city: "Inglewood" },
      74: { date: "June 29, 2026", time: "4:30 p.m.",  offsetHours:-4, stadium: "Gillette Stadium", city: "Foxborough" },
      75: { date: "June 29, 2026", time: "7:00 p.m.",  offsetHours:-6, stadium: "Estadio BBVA", city: "Guadalupe" },
      76: { date: "June 29, 2026", time: "12:00 p.m.", offsetHours:-5, stadium: "NRG Stadium", city: "Houston" },
      77: { date: "June 30, 2026", time: "5:00 p.m.",  offsetHours:-4, stadium: "MetLife Stadium", city: "East Rutherford" },
      78: { date: "June 30, 2026", time: "12:00 p.m.", offsetHours:-5, stadium: "AT&T Stadium", city: "Arlington" },
      79: { date: "June 30, 2026", time: "7:00 p.m.",  offsetHours:-6, stadium: "Estadio Azteca", city: "Mexico City" },
      80: { date: "July 1, 2026",  time: "12:00 p.m.", offsetHours:-4, stadium: "Mercedes-Benz Stadium", city: "Atlanta" },
      81: { date: "July 1, 2026",  time: "5:00 p.m.",  offsetHours:-7, stadium: "Levi's Stadium", city: "Santa Clara" },
      82: { date: "July 1, 2026",  time: "1:00 p.m.",  offsetHours:-7, stadium: "Lumen Field", city: "Seattle" },
      83: { date: "July 2, 2026",  time: "7:00 p.m.",  offsetHours:-4, stadium: "BMO Field", city: "Toronto" },
      84: { date: "July 2, 2026",  time: "12:00 p.m.", offsetHours:-7, stadium: "SoFi Stadium", city: "Inglewood" },
      85: { date: "July 2, 2026",  time: "8:00 p.m.",  offsetHours:-7, stadium: "BC Place", city: "Vancouver" },
      86: { date: "July 3, 2026",  time: "6:00 p.m.",  offsetHours:-4, stadium: "Hard Rock Stadium", city: "Miami Gardens" },
      87: { date: "July 3, 2026",  time: "8:30 p.m.",  offsetHours:-5, stadium: "Arrowhead Stadium", city: "Kansas City" },
      88: { date: "July 3, 2026",  time: "1:00 p.m.",  offsetHours:-5, stadium: "AT&T Stadium", city: "Arlington" }
    };

    const R16_INFO = {
      89: { date:"July 4, 2026", time:"5:00 p.m.",  offsetHours:-4, stadium:"Lincoln Financial Field", city:"Philadelphia" },
      90: { date:"July 4, 2026", time:"12:00 p.m.", offsetHours:-5, stadium:"NRG Stadium", city:"Houston" },
      91: { date:"July 5, 2026", time:"4:00 p.m.",  offsetHours:-4, stadium:"MetLife Stadium", city:"East Rutherford" },
      92: { date:"July 5, 2026", time:"6:00 p.m.",  offsetHours:-6, stadium:"Estadio Azteca", city:"Mexico City" },
      93: { date:"July 6, 2026", time:"2:00 p.m.",  offsetHours:-5, stadium:"AT&T Stadium", city:"Arlington" },
      94: { date:"July 6, 2026", time:"5:00 p.m.",  offsetHours:-7, stadium:"Lumen Field", city:"Seattle" },
      95: { date:"July 7, 2026", time:"12:00 p.m.", offsetHours:-4, stadium:"Mercedes-Benz Stadium", city:"Atlanta" },
      96: { date:"July 7, 2026", time:"1:00 p.m.",  offsetHours:-7, stadium:"BC Place", city:"Vancouver" }
    };

    const QF_INFO = {
      97: { date:"July 9, 2026",  time:"4:00 p.m.",  offsetHours:-4, stadium:"Gillette Stadium", city:"Foxborough" },
      98: { date:"July 10, 2026", time:"12:00 p.m.", offsetHours:-7, stadium:"SoFi Stadium", city:"Inglewood" },
      99: { date:"July 11, 2026", time:"5:00 p.m.",  offsetHours:-4, stadium:"Hard Rock Stadium", city:"Miami Gardens" },
      100:{ date:"July 11, 2026", time:"8:00 p.m.",  offsetHours:-5, stadium:"Arrowhead Stadium", city:"Kansas City" }
    };

    const SF_INFO = {
      101:{ date:"July 14, 2026", time:"2:00 p.m.", offsetHours:-5, stadium:"AT&T Stadium", city:"Arlington" },
      102:{ date:"July 15, 2026", time:"3:00 p.m.", offsetHours:-4, stadium:"Mercedes-Benz Stadium", city:"Atlanta" }
    };

    const THIRD_INFO = {
      103:{ date:"July 18, 2026", time:"5:00 p.m.", offsetHours:-4, stadium:"Hard Rock Stadium", city:"Miami Gardens" }
    };

    const FINAL_INFO = {
      104:{ date:"July 19, 2026", time:"3:00 p.m.", offsetHours:-4, stadium:"MetLife Stadium", city:"East Rutherford" }
    };

    const R32_MATCHES = [
      { id: 73, left: {type:"RU", g:"A"}, right:{type:"RU", g:"B"} },
      { id: 74, left: {type:"W",  g:"E"}, right:{type:"3SET", set:"A/B/C/D/F"} },
      { id: 75, left: {type:"W",  g:"F"}, right:{type:"RU", g:"C"} },
      { id: 76, left: {type:"W",  g:"C"}, right:{type:"RU", g:"F"} },
      { id: 77, left: {type:"W",  g:"I"}, right:{type:"3SET", set:"C/D/F/G/H"} },
      { id: 78, left: {type:"RU", g:"E"}, right:{type:"RU", g:"I"} },
      { id: 79, left: {type:"W",  g:"A"}, right:{type:"3SET", set:"C/E/F/H/I"} },
      { id: 80, left: {type:"W",  g:"L"}, right:{type:"3SET", set:"E/H/I/J/K"} },
      { id: 81, left: {type:"W",  g:"D"}, right:{type:"3SET", set:"B/E/F/I/J"} },
      { id: 82, left: {type:"W",  g:"G"}, right:{type:"3SET", set:"A/E/H/I/J"} },
      { id: 83, left: {type:"RU", g:"K"}, right:{type:"RU", g:"L"} },
      { id: 84, left: {type:"W",  g:"H"}, right:{type:"RU", g:"J"} },
      { id: 85, left: {type:"W",  g:"B"}, right:{type:"3SET", set:"E/F/G/I/J"} },
      { id: 86, left: {type:"W",  g:"J"}, right:{type:"RU", g:"H"} },
      { id: 87, left: {type:"W",  g:"K"}, right:{type:"3SET", set:"D/E/I/J/L"} },
      { id: 88, left: {type:"RU", g:"D"}, right:{type:"RU", g:"G"} }
    ];

    const R16_MATCHES = [
      { id: 90, left:{type:"WM", id:73}, right:{type:"WM", id:75} },
      { id: 89, left:{type:"WM", id:74}, right:{type:"WM", id:77} },
      { id: 91, left:{type:"WM", id:76}, right:{type:"WM", id:78} },
      { id: 92, left:{type:"WM", id:79}, right:{type:"WM", id:80} },
      { id: 93, left:{type:"WM", id:83}, right:{type:"WM", id:84} },
      { id: 94, left:{type:"WM", id:81}, right:{type:"WM", id:82} },
      { id: 95, left:{type:"WM", id:86}, right:{type:"WM", id:88} },
      { id: 96, left:{type:"WM", id:85}, right:{type:"WM", id:87} }
    ];

    const QF_MATCHES = [
      { id: 97, left:{type:"WM", id:89}, right:{type:"WM", id:90} },
      { id: 98, left:{type:"WM", id:93}, right:{type:"WM", id:94} },
      { id: 99, left:{type:"WM", id:91}, right:{type:"WM", id:92} },
      { id:100, left:{type:"WM", id:95}, right:{type:"WM", id:96} }
    ];

    const SF_MATCHES = [
      { id:101, left:{type:"WM", id:97}, right:{type:"WM", id:98} },
      { id:102, left:{type:"WM", id:99}, right:{type:"WM", id:100} }
    ];

    const THIRD_MATCH = [
      { id:103, left:{type:"LM", id:101}, right:{type:"LM", id:102} }
    ];

    const FINAL_MATCH = [
      { id:104, left:{type:"WM", id:101}, right:{type:"WM", id:102} }
    ];

    const ALL_ROUNDS = {
      r32: R32_MATCHES,
      r16: R16_MATCHES,
      qf:  QF_MATCHES,
      sf:  SF_MATCHES,
      third: THIRD_MATCH,
      final: FINAL_MATCH
    };

    const INFO_BY_MATCH = {
      ...R32_INFO, ...R16_INFO, ...QF_INFO, ...SF_INFO, ...THIRD_INFO, ...FINAL_INFO
    };

    /* ==============================
       8) Third-place mapping table
    ============================== */
    const THIRD_MATCH_ID_ORDER = [74, 77, 79, 80, 81, 82, 85, 87];

    const THIRD_TABLE_RAW = {
      "EFGHIJKL": ["3E","3J","3I","3F","3H","3G","3L","3K"],
      "DFGHIJKL": ["3H","3G","3I","3D","3J","3F","3L","3K"]
    };

    const THIRD_TABLE = Object.fromEntries(
      Object.entries(THIRD_TABLE_RAW).map(([key, arr]) => {
        const cleanKey = String(key).trim();
        const matchMap = {};
        THIRD_MATCH_ID_ORDER.forEach((mid, i) => {
          matchMap[mid] = arr[i];
        });
        return [cleanKey, matchMap];
      })
    );

    /* ==============================
       9) Third-place derived data
    ============================== */
    function getThirdTeamForGroup(g){
      const arr = state.groups[g] ?? [];
      const t = arr[2];
      return t && !t.isPlaceholder ? t : null;
    }

    function syncThirdRankingNames(){
      let arr = Array.isArray(state.thirdRanking) ? state.thirdRanking.slice() : [];
      const byGroup = new Map(arr.map(x => [x.groupKey, x]));

      GROUP_KEYS.forEach(g => {
        if(!byGroup.has(g)){
          const obj = {
            id: toId(`third-${g}`),
            groupKey: g,
            name: fallbackPathNameForGroup(g),
            userMoved: false
          };
          arr.push(obj);
          byGroup.set(g, obj);
        }
      });

      arr = arr.filter(x => GROUP_KEYS.includes(x.groupKey));

      arr.forEach(item => {
        const third = getThirdTeamForGroup(item.groupKey);
        const newName = third ? third.name : fallbackPathNameForGroup(item.groupKey);

        // ✅ Fix you asked for:
        // New team replacing old one shouldn't inherit moved
        if(item.name !== newName){
          item.userMoved = false;
        }

        item.name = newName;
      });

      state.thirdRanking = arr;
    }

    function computeChampions(){
      return GROUP_KEYS.map(g => {
        const t = state.groups[g]?.[0];
        const name = (!t || t.isPlaceholder) ? fallbackPathNameForGroup(g) : t.name;
        return { id: toId(`champ-${g}-${name}`), name, groupKey: g };
      });
    }

    function computeRunners(){
      return GROUP_KEYS.map(g => {
        const t = state.groups[g]?.[1];
        const name = (!t || t.isPlaceholder) ? fallbackPathNameForGroup(g) : t.name;
        return { id: toId(`runner-${g}-${name}`), name, groupKey: g };
      });
    }

    function computeTop8ThirdPlaced(){
      syncThirdRankingNames();

      const top8Source = state.thirdRanking.slice(0, 8);

      qualifiedThirdPlacedTeams = top8Source.map(x => ({ groupKey: x.groupKey, name: x.name }));

      qualifiedThirdGroupLetters = top8Source
        .map(x => x.groupKey)
        .sort((a,b) => a.localeCompare(b))
        .join("");

      const top8 = top8Source.map((x, i) => ({
        id: toId(`top8-third-${i}-${x.groupKey}-${x.name}`),
        name: x.name,
        groupKey: x.groupKey
      }));

      top8.sort((a, b) => a.groupKey.localeCompare(b.groupKey));
      return top8;
    }

    function thirdPlaceholderName(setSpec){
      return setSpec
        .split("/")
        .map(s => s.trim())
        .filter(Boolean)
        .map(g => `3${g}`)
        .join("/");
    }

    function parseAllowedThird(spec){
      return spec.split("/").map(s => s.trim()).filter(Boolean);
    }

    /* ==============================
       10) Build R32 third snapshot
    ============================== */
    function buildR32ThirdSnapshot(){
      computeTop8ThirdPlaced();
      const letters = qualifiedThirdGroupLetters;

      const tableRow = THIRD_TABLE[letters];

      const assignment = {};

      if(tableRow){
        THIRD_MATCH_ID_ORDER.forEach(mid => {
          const tag = tableRow[mid];
          const g = tag.replace("3","");
          const found = state.thirdRanking.find(x => x.groupKey === g);
          assignment[mid] = {
            groupKey: g,
            name: found ? found.name : tag,
            source: "table"
          };
        });
      } else {
        const rankedTop8 = state.thirdRanking.slice(0,8);
        const used = new Set();

        function pickAllowedUnique(allowed){
          const cand1 = rankedTop8.find(x => allowed.includes(x.groupKey) && !used.has(x.groupKey));
          if(cand1) return cand1;
          const cand2 = rankedTop8.find(x => !used.has(x.groupKey));
          return cand2 || null;
        }

        const thirdMatches = R32_MATCHES.filter(m =>
          m.left.type === "3SET" || m.right.type === "3SET"
        );

        thirdMatches.forEach(m => {
          const slot = (m.left.type === "3SET") ? m.left : m.right;
          const allowed = parseAllowedThird(slot.set);
          const pick = pickAllowedUnique(allowed);

          if(pick){
            used.add(pick.groupKey);
            assignment[m.id] = {
              groupKey: pick.groupKey,
              name: pick.name,
              source: "greedy"
            };
          } else {
            assignment[m.id] = {
              groupKey: "?",
              name: "3rd TBD",
              source: "greedy"
            };
          }
        });
      }

      state.r32ThirdSnapshot = { letters, top8: qualifiedThirdPlacedTeams.slice(), assignment };
    }

    /* ==============================
       11) KO slot resolution
    ============================== */
    function getGroupPosTeam(g, idx){
      const t = state.groups[g]?.[idx];
      if(!t || t.isPlaceholder) return { name: fallbackPathNameForGroup(g), groupKey: g };
      return { name: t.name, groupKey: g };
    }

    function teamAbbrev(name){
      if(!name) return "---";
      const SPECIAL = {
        "United States": "USA",
        "United States of America": "USA",
        "South Korea": "KOR",
        "North Macedonia": "MKD",
        "Republic of Ireland": "IRL",
        "Czech Republic": "CZE",
        "Bosnia and Herzegovina": "BIH",
        "New Zealand": "NZL",
        "Cape Verde": "CPV",
        "Cabo Verde": "CPV",
        "Ivory Coast": "CIV",
        "Côte d'Ivoire":"CIV",
        "DR Congo": "COD",
        "Northern Ireland": "NIR"
      };
      if(SPECIAL[name]) return SPECIAL[name];

      if(name.startsWith("UEFA Path")) return "UEF";
      if(name.startsWith("FIFA IC Path")) return "FIC";

      const words = name.replace(/[().]/g,"").split(/\s+/).filter(Boolean);
      if(words.length >= 2){
        const init = words.map(w => w[0]).join("").toUpperCase();
        return init.slice(0,3).padEnd(3, init[0] ?? "X");
      }
      const s = words[0].toUpperCase();
      if(s.length <= 3) return s;
      return s.slice(0,3);
    }

    function resolveSlot(slot, matchId){
      if(slot.type === "W"){
        const t = getGroupPosTeam(slot.g, 0);
        return { name: t.name, label: `1${slot.g}`, placeholder:false };
      }
      if(slot.type === "RU"){
        const t = getGroupPosTeam(slot.g, 1);
        return { name: t.name, label: `2${slot.g}`, placeholder:false };
      }
      if(slot.type === "3SET"){
        if(!state.r32Generated){
          const ph = thirdPlaceholderName(slot.set);
          return { name: ph, label: ph, placeholder:true, source:"placeholder" };
        }

        const snap = state.r32ThirdSnapshot;
        const assign = snap?.assignment?.[matchId];

        if(assign){
          return {
            name: assign.name,
            label: `3${assign.groupKey}`,
            placeholder:false,
            source: assign.source
          };
        }

        return { name:"3rd TBD", label:"3?", placeholder:true, source:"fallback" };
      }
      if(slot.type === "WM"){
        const w = state.winners[slot.id];
        if(!w) return { name:`Winner ${slot.id}`, label:`W${slot.id}`, placeholder:true };
        return { name:w.name, label:`W${slot.id}`, placeholder:false };
      }
      if(slot.type === "LM"){
        const w = state.winners[slot.id];
        if(!w) return { name:`Loser ${slot.id}`, label:`L${slot.id}`, placeholder:true };

        const prev = findMatchById(slot.id);
        if(!prev) return { name:`Loser ${slot.id}`, label:`L${slot.id}`, placeholder:true };

        const p = resolveParticipants(prev);
        const loserName = (p.left.name === w.name) ? p.right.name : p.left.name;

        if(!loserName || p.left.placeholder || p.right.placeholder){
          return { name:`Loser ${slot.id}`, label:`L${slot.id}`, placeholder:true };
        }

        return { name: loserName, label:`L${slot.id}`, placeholder:false };
      }

      return { name:"TBD", label:"---", placeholder:true };
    }

    function findMatchById(id){
      for(const k of Object.keys(ALL_ROUNDS)){
        const m = ALL_ROUNDS[k].find(x => x.id === id);
        if(m) return m;
      }
      return null;
    }

    function getAllMatchesFlat(){
      return [
        ...R32_MATCHES,
        ...R16_MATCHES,
        ...QF_MATCHES,
        ...SF_MATCHES,
        ...THIRD_MATCH,
        ...FINAL_MATCH
      ];
    }

    function getR32ThirdDependentMatchIds(){
      return R32_MATCHES
        .filter(m => m.left.type === "3SET" || m.right.type === "3SET")
        .map(m => m.id);
    }

    function buildDependencyGraph(){
      const graph = new Map();
      const all = getAllMatchesFlat();
      all.forEach(m => {
        [m.left, m.right].forEach(slot => {
          if(slot.type === "WM" || slot.type === "LM"){
            const src = slot.id;
            if(!graph.has(src)) graph.set(src, []);
            graph.get(src).push(m.id);
          }
        });
      });
      return graph;
    }

    const DEP_GRAPH = buildDependencyGraph();

    function collectDownstreamMatchIds(startIds){
      const out = new Set();
      const q = [...startIds];

      while(q.length){
        const cur = q.shift();
        const kids = DEP_GRAPH.get(cur) || [];
        kids.forEach(k => {
          if(!out.has(k)){
            out.add(k);
            q.push(k);
          }
        });
      }
      return out;
    }

    function getAssignedThirdNameFromSnapshot(snapshot, matchId, slot){
      if(!snapshot) return null;
      const assign = snapshot.assignment?.[matchId];
      if(assign) return assign.name;
      return thirdPlaceholderName(slot.set);
    }

    function resolveParticipants(match){
      const L = resolveSlot(match.left, match.id);
      const R = resolveSlot(match.right, match.id);
      return { left:L, right:R };
    }

    /* ==============================
       12) Winner validation (cascade)
    ============================== */
    function validateAllWinners(){
      const order = [
        ...R32_MATCHES.map(m=>m.id),
        ...R16_MATCHES.map(m=>m.id),
        ...QF_MATCHES.map(m=>m.id),
        ...SF_MATCHES.map(m=>m.id),
        103,
        104
      ];

      order.forEach(id => {
        const match = findMatchById(id);
        if(!match) return;

        const stored = state.winners[id];
        if(!stored) return;

        const p = resolveParticipants(match);

        if(p.left.placeholder || p.right.placeholder){
          delete state.winners[id];
          return;
        }

        const currentLeft = p.left.name;
        const currentRight = p.right.name;

        if(stored.leftAtPick !== currentLeft || stored.rightAtPick !== currentRight){
          delete state.winners[id];
          return;
        }

        if(![currentLeft, currentRight].includes(stored.name)){
          delete state.winners[id];
          return;
        }
      });
    }

    function setWinner(matchId, side, name){
      const match = findMatchById(matchId);
      if(!match) return;

      const p = resolveParticipants(match);
      if(p.left.placeholder || p.right.placeholder) return;

      const ab = teamAbbrev(name);

      state.winners[matchId] = {
        side,
        name,
        abbrev: ab,
        leftAtPick: p.left.name,
        rightAtPick: p.right.name
      };

      validateAllWinners();
      render();
    }

    /* ==============================
       13) Edit rules
    ============================== */
    function isClickSwapEnabledForZone(zoneKey){
      if(editMode === "pools") return isPathZone(zoneKey);
      if(editMode === "groups"){
        return isGroupZone(zoneKey) || zoneKey === "third-ranking";
      }
      return false;
    }

    /* ==============================
       14) Zone arrays
    ============================== */
    function getZoneArray(zoneKey){
      if(isPathZone(zoneKey)) return state.paths[pathIdFromZone(zoneKey)];
      if(isGroupZone(zoneKey)) return state.groups[groupKeyFromZone(zoneKey)];
      if(zoneKey === "third-ranking"){ syncThirdRankingNames(); return state.thirdRanking; }
      if(zoneKey === "champions-view") return computeChampions();
      if(zoneKey === "runners-view") return computeRunners();
      if(zoneKey === "top8-third-view") return computeTop8ThirdPlaced();
      return null;
    }

    /* ==============================
       15) Pool status display
    ============================== */
    function clearPoolStatus(){
      PATHS.forEach(p => {
        const arr = state.paths[p.id];
        if(!arr) return;
        arr.forEach(t => { t.isQualified = false; t.isEliminated = false; });
        state.qualifiedByPath[p.id] = false;
      });
    }

    function markQualifiedAndEliminated(pathId){
      const pathArr = state.paths[pathId];
      if(!pathArr || pathArr.length === 0) return;
      pathArr.forEach((t, i) => {
        t.isQualified = (i === 0);
        t.isEliminated = (i !== 0);
      });
      state.qualifiedByPath[pathId] = true;
    }

    /* ==============================
       16) Click-to-swap logic (+ userMoved)
       - Pools/Groups: FULL-ZONE lock
       - Third Ranking: TEAM-WISE lock
    ============================== */
    function swapTeamsInArray(arr, id1, id2){
      const i1 = arr.findIndex(t => t.id === id1);
      const i2 = arr.findIndex(t => t.id === id2);
      if(i1 === -1 || i2 === -1) return { ok:false };

      const t1 = arr[i1];
      const t2 = arr[i2];

      [arr[i1], arr[i2]] = [arr[i2], arr[i1]];

      return { ok:true, t1, t2 };
    }

    function markWholeZoneMoved(arr){
      if(!arr) return;
      arr.forEach(t => {
        if(t && !t.isPlaceholder) t.userMoved = true;
      });
    }

    function markTwoMoved(t1, t2){
      if(t1) t1.userMoved = true;
      if(t2) t2.userMoved = true;
    }

    function handleClickSwap(teamId, zone){
      if(!isClickSwapEnabledForZone(zone)) return;

      if(!swapSelection){
        swapSelection = { teamId, zone };
        render();
        return;
      }

      if(swapSelection.teamId === teamId && swapSelection.zone === zone){
        swapSelection = null;
        render();
        return;
      }

      if(swapSelection.zone !== zone){
        swapSelection = { teamId, zone };
        render();
        return;
      }

      const arr = getZoneArray(zone);
      if(!arr) return;

      const res = swapTeamsInArray(arr, swapSelection.teamId, teamId);
      swapSelection = null;

      if(res.ok){
        if(zone === "third-ranking"){
          markTwoMoved(res.t1, res.t2);
          thirdRankingDirty = true;
        } else if(isPathZone(zone) || isGroupZone(zone)){
          markWholeZoneMoved(arr);
        }

        validateAllWinners();
      }

      render();
    }

    function attachClickSwap(card){
      card.addEventListener("click", () => {
        handleClickSwap(card.dataset.id, card.dataset.zone);
      });
    }

    /* ==============================
       17) Place qualifiers to groups
    ============================== */
    function upsertPathTeamInGroup(groupKey, pathId, chosenTeam){
      const arr = state.groups[groupKey];
      if(!arr) return;

      const newObj = {
        id: toId(`grp-${groupKey}-${pathId}-${chosenTeam.name}`),
        name: chosenTeam.name,
        tag: PATH_BY_ID[pathId].label,
        chosenFromPath: true,
        pathId,
        userMoved: false
      };

      const phIndex = arr.findIndex(t => t.isPlaceholder && t.pathId === pathId);
      if(phIndex !== -1){
        arr.splice(phIndex, 1, newObj);
        return;
      }

      const exIndex = arr.findIndex(t => t.chosenFromPath && t.pathId === pathId);
      if(exIndex !== -1){
        arr.splice(exIndex, 1, newObj);
        return;
      }

      arr.push(newObj);
    }

    function placeQualifiersToGroups(){
      PATHS.forEach(p => {
        const pathArr = state.paths[p.id];
        if(!pathArr || pathArr.length === 0) return;
        const chosen = pathArr[0];
        upsertPathTeamInGroup(p.group, p.id, chosen);
        markQualifiedAndEliminated(p.id);
      });

      editMode = "groups";
      swapSelection = null;

      validateAllWinners();
      render();
    }

    function reformPoolMode(){
      editMode = "pools";
      swapSelection = null;
      clearPoolStatus();
      render();
    }

    /* ==============================
       18) AUTO select with lock-on-moved
    ============================== */
    function sortKeyForTeam(t){
      const ph = t?.isPlaceholder ? 1 : 0;
      const r  = rankOf(t?.name);
      return { ph, r, n: String(t?.name ?? "") };
    }

    function sortMovable(arr){
      arr.sort((a,b) => {
        const A = sortKeyForTeam(a);
        const B = sortKeyForTeam(b);
        if(A.ph !== B.ph) return A.ph - B.ph;
        if(A.r !== B.r) return A.r - B.r;
        return A.n.localeCompare(B.n);
      });
    }

    function reorderRespectingUserMoved(arr){
      const n = arr.length;
      const fixed = new Map();
      for(let i=0;i<n;i++){
        const t = arr[i];
        if(t && t.userMoved){
          fixed.set(i, t);
        }
      }

      const movable = arr.filter(t => !t.userMoved);
      sortMovable(movable);

      const out = new Array(n);
      let k = 0;
      for(let i=0;i<n;i++){
        if(fixed.has(i)){
          out[i] = fixed.get(i);
        } else {
          out[i] = movable[k++] ?? arr[i];
        }
      }
      return out;
    }

    function autoPools(){
      PATHS.forEach(p => {
        const arr = state.paths[p.id];
        if(!arr) return;
        state.paths[p.id] = reorderRespectingUserMoved(arr);
      });
      render();
    }

    function autoGroups(){
      GROUP_KEYS.forEach(g => {
        let arr = state.groups[g];
        if(!arr) return;

        arr = arr.slice(0,4);
        const re = reorderRespectingUserMoved(arr);

        state.groups[g] = re;
      });

      validateAllWinners();
      render();
    }

    function autoThirdRanking(){
      syncThirdRankingNames();
      state.thirdRanking = reorderRespectingUserMoved(state.thirdRanking);
      thirdRankingDirty = true;

      validateAllWinners();
      render();
    }

    function autoRound(matches){
      validateAllWinners();

      matches.forEach(m => {
        if(state.winners[m.id]) return;

        const p = resolveParticipants(m);
        if(p.left.placeholder || p.right.placeholder) return;

        const winnerName = pickWinnerNameAuto(p.left.name, p.right.name);
        const side = (winnerName === p.left.name) ? "L" : "R";

        state.winners[m.id] = {
          side,
          name: winnerName,
          abbrev: teamAbbrev(winnerName),
          leftAtPick: p.left.name,
          rightAtPick: p.right.name
        };
      });

      validateAllWinners();
      render();
    }

    /* ==============================
       19) Regenerate R32 (SMART)
    ============================== */
    function regenerateR32(){
      const hadSnapshot = !!state.r32ThirdSnapshot;
      const wasGenerated = !!state.r32Generated;

      if(!wasGenerated || !hadSnapshot){
        state.winners = {};
        state.r32Generated = true;
        buildR32ThirdSnapshot();
        thirdRankingDirty = false;

        validateAllWinners();
        render();
        return;
      }

      if(!thirdRankingDirty){
        buildR32ThirdSnapshot();
        validateAllWinners();
        render();
        return;
      }

      const oldSnap = state.r32ThirdSnapshot;

      buildR32ThirdSnapshot();
      const newSnap = state.r32ThirdSnapshot;

      const thirdR32Ids = getR32ThirdDependentMatchIds();
      const changedR32 = [];

      thirdR32Ids.forEach(mid => {
        const match = findMatchById(mid);
        if(!match) return;

        const thirdSlot =
          (match.left.type === "3SET") ? match.left :
          (match.right.type === "3SET") ? match.right :
          null;

        if(!thirdSlot) return;

        const oldName = getAssignedThirdNameFromSnapshot(oldSnap, mid, thirdSlot);
        const newName = getAssignedThirdNameFromSnapshot(newSnap, mid, thirdSlot);

        if(oldName !== newName){
          changedR32.push(mid);
        }
      });

      if(changedR32.length === 0){
        thirdRankingDirty = false;
        validateAllWinners();
        render();
        return;
      }

      changedR32.forEach(id => { delete state.winners[id]; });

      const downstream = collectDownstreamMatchIds(changedR32);
      downstream.forEach(id => { delete state.winners[id]; });

      state.r32Generated = true;
      thirdRankingDirty = false;

      validateAllWinners();
      render();
    }

    /* ==============================
       20) UI helpers
    ============================== */
    function makeSeparator(text, buttonOptions=null){
      const sep = document.createElement("div");
      sep.className = "stage-separator";

      const left = document.createElement("div");
      left.className = "stage-left";
      left.innerHTML = `
        <span class="stage-title">${text}</span>
        <span class="stage-line"></span>
      `;
      sep.appendChild(left);

      if(buttonOptions){
        const right = document.createElement("div");
        right.className = "stage-right";

        const btns = Array.isArray(buttonOptions) ? buttonOptions : [buttonOptions];
        btns.forEach(opt => {
          const btn = document.createElement("button");
          btn.id = opt.id;
          btn.textContent = opt.text;
          if(opt.mini) btn.classList.add("btn-mini");
          if(opt.orange) btn.classList.add("btn-orange");
          if(opt.green) btn.classList.add("btn-green");
          right.appendChild(btn);
        });

        sep.appendChild(right);
      }

      return sep;
    }

    function makeColumn(title, zoneKey, subtitle = ""){
      const col = document.createElement("section");
      col.className = "column";
      col.innerHTML = `
        <div class="column-header">
          <div class="column-title">
            ${title}${subtitle ? ` • ${subtitle}` : ""}
            <span class="zone-moved-badge" data-zone-moved="${zoneKey}" style="display:none;"></span>
          </div>
          <div class="count" data-count-for="${zoneKey}"></div>
        </div>
        <div class="zone" data-zone="${zoneKey}"></div>
      `;
      return col;
    }

    function makeKoSection(roundKey, className=""){
      const section = document.createElement("div");
      section.className = `ko-section ko-${roundKey}`.trim();

      const grid = document.createElement("div");
      grid.className = `ko-grid ${className}`.trim();
      grid.dataset.koRound = roundKey;

      section.appendChild(grid);
      return section;
    }

    /* ==============================
       21) Build Board (ORDER)
    ============================== */
    function buildBoard(){
      const board = document.getElementById("board");
      board.innerHTML = "";

      board.appendChild(makeSeparator("Qualifier Pools"));
      PATHS.forEach(p => {
        board.appendChild(makeColumn(p.label, `path-${p.id}`, `feeds Group ${p.group}`));
      });

      board.appendChild(
        makeSeparator(
          "Pool Actions",
          [
            { id:"autoPoolsBtn", text:"Auto Select Pool Positions", orange:true },
            { id:"placeQualifiersBtn", text:"Place qualifiers to the groups", green:true },
            { id:"reformPoolBtn", text:"Reform Pool" }
          ]
        )
      );

      board.appendChild(makeSeparator("Groups"));
      GROUP_KEYS.forEach(g => {
        board.appendChild(makeColumn(`Group ${g}`, `group-${g}`));
      });

      board.appendChild(
        makeSeparator(
          "Group Actions",
          [
            { id:"autoGroupsBtn", text:"Auto Select Remaining Group Positions", orange:true }
          ]
        )
      );

      board.appendChild(makeSeparator("Third-Place Ranking"));
      board.appendChild(makeColumn("Third Place Team Ranking", "third-ranking", "A3 → L3"));

      board.appendChild(
        makeSeparator(
          "Third-Place Actions",
          [
            { id:"autoThirdBtn", text:"Auto Select Remaining Third Positions", orange:true }
          ]
        )
      );

      board.appendChild(makeSeparator("Qualified Overview"));
      board.appendChild(makeColumn("Group Champions", "champions-view", "A1 → L1"));
      board.appendChild(makeColumn("Group Runners", "runners-view", "A2 → L2"));
      board.appendChild(makeColumn("Top-8 Third Placed Teams", "top8-third-view", "auto"));

      board.appendChild(
        makeSeparator(
          "R32 Sync",
          [
            { id:"regenerateR32Btn", text:"Regenerate R32", orange:true }
          ]
        )
      );

      board.appendChild(makeSeparator("Round of 32"));
      board.appendChild(makeKoSection("r32"));

      board.appendChild(
        makeSeparator(
          "Round of 32 Actions",
          [
            { id:"autoR32Btn", text:"Auto Select R32 Winners", orange:true }
          ]
        )
      );

      board.appendChild(makeSeparator("Round of 16"));
      board.appendChild(makeKoSection("r16"));
      board.appendChild(
        makeSeparator(
          "Round of 16 Actions",
          [
            { id:"autoR16Btn", text:"Auto Select R16 Winners", orange:true }
          ]
        )
      );

      board.appendChild(makeSeparator("Quarterfinals"));
      board.appendChild(makeKoSection("qf"));
      board.appendChild(
        makeSeparator(
          "Quarterfinal Actions",
          [
            { id:"autoQFBtn", text:"Auto Select QF Winners", orange:true }
          ]
        )
      );

      board.appendChild(makeSeparator("Semifinals"));
      board.appendChild(makeKoSection("sf", "centered"));
      board.appendChild(
        makeSeparator(
          "Semifinal Actions",
          [
            { id:"autoSFBtn", text:"Auto Select SF Winners", orange:true }
          ]
        )
      );

      board.appendChild(makeSeparator("Third Place Match"));
      board.appendChild(makeKoSection("third", "centered"));
      board.appendChild(
        makeSeparator(
          "Third Place Match Actions",
          [
            { id:"autoThirdMatchBtn", text:"Auto Select 3rd Place Winner", orange:true }
          ]
        )
      );

      board.appendChild(makeSeparator("Final"));
      board.appendChild(makeKoSection("final", "centered"));
      board.appendChild(
        makeSeparator(
          "Final Actions",
          [
            { id:"autoFinalBtn", text:"Auto Select Final Winner", orange:true }
          ]
        )
      );

      /* ✅ NEW: Result Actions at the end */
      board.appendChild(
        makeSeparator(
          "Result",
          [
            { id:"printResultsBtn", text:"Print Result", green:true }
          ]
        )
      );
    }

    /* ==============================
       22) Render standard zones
    ============================== */
    function applyRankHighlight(cardEl, zone, idx, team){
      cardEl.classList.remove("rank-strong", "rank-mild", "qualified", "eliminated");

      if(isPathZone(zone)){
        if(idx === 0) cardEl.classList.add("rank-strong");
        if(editMode === "groups"){
          if(team.isQualified) cardEl.classList.add("qualified");
          if(team.isEliminated) cardEl.classList.add("eliminated");
        }
        return;
      }

      if(isGroupZone(zone)){
        if(idx === 0 || idx === 1) cardEl.classList.add("rank-strong");
        else if(idx === 2) cardEl.classList.add("rank-mild");
        return;
      }

      if(zone === "third-ranking"){
        if(idx < 8) cardEl.classList.add("rank-strong");
        return;
      }

      if(zone === "top8-third-view"){
        cardEl.classList.add("rank-strong");
      }
    }

    function renderStandardZones(){
      syncThirdRankingNames();

      zones.forEach(zone => {
        const dz = document.querySelector(`.zone[data-zone="${zone}"]`);
        if(!dz) return;

        dz.innerHTML = "";

        const arr = getZoneArray(zone) ?? [];
        const gKey = isGroupZone(zone) ? groupKeyFromZone(zone) : null;

        /* ZONE-LEVEL "User moved" BADGE (Pools + Groups only) */
        const movedBadge = document.querySelector(`[data-zone-moved="${zone}"]`);
        if(movedBadge){
          if(isPathZone(zone) || isGroupZone(zone)){
            const movedAny = (arr || []).some(t => t && t.userMoved && !t.isPlaceholder);
            movedBadge.textContent = movedAny ? "User moved" : "";
            movedBadge.style.display = movedAny ? "inline-block" : "none";
          } else {
            movedBadge.textContent = "";
            movedBadge.style.display = "none";
          }
        }

        arr.forEach((team, idx) => {
          const card = document.createElement("div");
          card.className = "card";
          card.dataset.id = team.id;
          card.dataset.zone = zone;

          const editable =
            isClickSwapEnabledForZone(zone) &&
            !team.isPlaceholder &&
            zone !== "champions-view" &&
            zone !== "runners-view" &&
            zone !== "top8-third-view";

          if(!editable) card.classList.add("locked");

          applyRankHighlight(card, zone, idx, team);

          if(swapSelection && swapSelection.teamId === team.id && swapSelection.zone === zone){
            card.classList.add("swap-armed");
          }

          /* Tag text rules */
          let tagText = "";

          if(isPathZone(zone)){
            if(editMode === "groups"){
              tagText = (team.isQualified ? "Qualified" : "Eliminated");
            } else {
              tagText = team.tag ?? PATH_BY_ID[pathIdFromZone(zone)]?.label ?? "";
            }
          }
          else if(isGroupZone(zone)){
            if(team.isPlaceholder){
              tagText = "Placeholder";
            } else {
              tagText = `${gKey}${idx + 1}`;
            }
          }
          else if(zone === "third-ranking"){
            const moved = team?.userMoved ? " • moved" : "";
            tagText = `${team.groupKey}3${moved}`;
          }
          else if(zone === "champions-view"){
            tagText = `${team.groupKey}1`;
          }
          else if(zone === "runners-view"){
            tagText = `${team.groupKey}2`;
          }
          else if(zone === "top8-third-view"){
            tagText = `${team.groupKey}3`;
          }

          card.innerHTML = `
            <span class="name">${nameWithFlagHTML(team.name)}</span>
            <span class="tag">${tagText}</span>
          `;

          if(!team.isPlaceholder && !["champions-view", "runners-view", "top8-third-view"].includes(zone)){
            attachClickSwap(card);
          }

          dz.appendChild(card);
        });

        if(zone === "top8-third-view"){
          const summary = document.createElement("div");
          summary.className = "top8-summary";
          summary.textContent = qualifiedThirdGroupLetters || "—";
          dz.appendChild(summary);
        }

        const countEl = document.querySelector(`[data-count-for="${zone}"]`);
        if(countEl){
          countEl.textContent = `${arr.length} team${arr.length !== 1 ? "s" : ""}`;
        }
      });
    }

    /* ==============================
       23) Local time rendering helpers
    ============================== */
    const MONTHS = {
      january:0, february:1, march:2, april:3, may:4, june:5,
      july:6, august:7, september:8, october:9, november:10, december:11
    };

    function parseDateStr(dateStr){
      const m = String(dateStr).match(/^([A-Za-z]+)\s+(\d{1,2}),\s+(\d{4})$/);
      if(!m) return null;
      const month = MONTHS[m[1].toLowerCase()];
      const day = Number(m[2]);
      const year = Number(m[3]);
      if(month == null) return null;
      return { year, month, day };
    }

    function parseTime12h(timeStr){
      const s = String(timeStr).toLowerCase().replace(/\s+/g," ").trim();
      const m = s.match(/^(\d{1,2}):(\d{2})\s*(a\.m\.|p\.m\.)$/);
      if(!m) return null;
      let h = Number(m[1]);
      const min = Number(m[2]);
      const ampm = m[3];
      if(ampm.startsWith("p") && h !== 12) h += 12;
      if(ampm.startsWith("a") && h === 12) h = 0;
      return { h, min };
    }

    function utcMillisFromVenueInfo(info){
      if(!info || info.offsetHours == null) return null;
      const d = parseDateStr(info.date);
      const t = parseTime12h(info.time);
      if(!d || !t) return null;

      const utcHour = t.h - info.offsetHours;
      return Date.UTC(d.year, d.month, d.day, utcHour, t.min, 0);
    }

    function formatLocalKickoff(info){
      const ms = utcMillisFromVenueInfo(info);
      if(ms == null) return info?.time ? info.time : "Time TBD";

      const dt = new Date(ms);
      const fmt = new Intl.DateTimeFormat(undefined, {
        dateStyle: "medium",
        timeStyle: "short"
      });
      return fmt.format(dt);
    }

    /* ==============================
       24) Render KO rounds
    ============================== */
    function buildMatchCard(match){
      const p = resolveParticipants(match);
      const L = p.left;
      const R = p.right;

      const winner = state.winners[match.id];
      const info = INFO_BY_MATCH[match.id];

      const card = document.createElement("div");
      card.className = "match-card";
      card.dataset.matchId = match.id;

      const idx = document.createElement("div");
      idx.className = "match-index";
      idx.textContent = `Match ${match.id}`;
      card.appendChild(idx);

      const vs = document.createElement("div");
      vs.className = "match-vs";
      vs.textContent = `${L.label} vs ${R.label}`;
      card.appendChild(vs);

      const leftBtn = document.createElement("div");
      leftBtn.className = "match-team";
      leftBtn.innerHTML = nameWithFlagHTML(L.name);

      const mid = document.createElement("div");
      mid.className = "match-mid";

      const rightBtn = document.createElement("div");
      rightBtn.className = "match-team";
      rightBtn.innerHTML = nameWithFlagHTML(R.name);

      const inR32Range = (match.id >= 73 && match.id <= 88);

      const canPick =
        (!inR32Range || state.r32Generated) &&
        !L.placeholder && !R.placeholder;

      if(!canPick){
        leftBtn.classList.add("locked");
        rightBtn.classList.add("locked");
        mid.textContent = "---";
      } else {
        leftBtn.addEventListener("click", () => setWinner(match.id, "L", L.name));
        rightBtn.addEventListener("click", () => setWinner(match.id, "R", R.name));
        mid.textContent = winner ? winner.abbrev : "---";
      }

      if(winner && canPick){
        if(winner.name === L.name) leftBtn.classList.add("winning");
        if(winner.name === R.name) rightBtn.classList.add("winning");
      }

      card.appendChild(leftBtn);
      card.appendChild(mid);
      card.appendChild(rightBtn);

      const bottom = document.createElement("div");
      bottom.className = "match-bottom";

      const leftMeta = document.createElement("span");
      const rightMeta = document.createElement("span");

      if(info){
        leftMeta.innerHTML = `
          <span class="chip">${info.date}</span>
          <span class="chip">Local time: ${formatLocalKickoff(info)}</span>
        `;
        rightMeta.innerHTML = `
          <span class="chip">${info.stadium}</span>
          <span class="chip">${info.city}</span>
        `;
      } else {
        leftMeta.innerHTML = `<span class="chip">Date/Time TBD</span>`;
        rightMeta.innerHTML = `<span class="chip">Venue TBD</span>`;
      }

      bottom.appendChild(leftMeta);
      bottom.appendChild(rightMeta);
      card.appendChild(bottom);

      return card;
    }

    function renderKoRound(roundKey){
      const grid = document.querySelector(`.ko-grid[data-ko-round="${roundKey}"]`);
      if(!grid) return;

      grid.innerHTML = "";

      const matches = ALL_ROUNDS[roundKey] ?? [];
      matches.forEach(m => grid.appendChild(buildMatchCard(m)));

      if(roundKey === "r32"){
        const parent = grid.parentElement;
        parent.querySelectorAll(".r32-note").forEach(n => n.remove());

        const note = document.createElement("div");
        note.className = "r32-note";
        note.textContent = (!state.r32Generated)
          ? "R32 not generated yet. Third-place slots are placeholders from the mapping sets."
          : "R32 3rd-place teams are frozen from your last Regenerate click.";
        parent.appendChild(note);
      }
    }

    function renderAllKo(){
      validateAllWinners();
      renderKoRound("r32");
      renderKoRound("r16");
      renderKoRound("qf");
      renderKoRound("sf");
      renderKoRound("third");
      renderKoRound("final");
    }

    /* ==============================
       25) R32 badge updater
    ============================== */
    function updateRegenerateR32Badge(){
      const btn = document.getElementById("regenerateR32Btn");
      if(!btn) return;

      const base = "Regenerate R32";
      if(thirdRankingDirty){
        btn.innerHTML = `${base}<span class="outofdate-badge">R32 out-of-date</span>`;
      } else {
        btn.textContent = base;
      }
    }

    /* ==============================
       26) Clear moved flags (GLOBAL)
    ============================== */
    function clearAllUserMoved(){
      Object.values(state.paths || {}).forEach(arr => {
        (arr || []).forEach(t => { if(t) t.userMoved = false; });
      });

      Object.values(state.groups || {}).forEach(arr => {
        (arr || []).forEach(t => { if(t) t.userMoved = false; });
      });

      syncThirdRankingNames();
      (state.thirdRanking || []).forEach(t => { if(t) t.userMoved = false; });

      swapSelection = null;

      validateAllWinners();
      render();
    }

    /* ==============================
       27) PRINT RESULT - NAME + CANVAS
    ============================== */
    /* ==============================
   RESULT IMAGE GENERATION (FIXED)
   - compact match cards
   - working flag emoji
   - champion headline top-right
   - source bottom-right
============================== */

// You can customize this label if you want
const SITE_SOURCE_NAME = "World Cup 2026 Predictor";

// Try to infer your site URL. Fallback to location.href.
function getSiteUrlForImage(){
  try{
    return (document.querySelector('link[rel="canonical"]')?.href)
      || location.href;
  } catch(e){
    return "";
  }
}

// Grab user's first name from a simple prompt cache OR fallback
// If you already have a better mechanism, replace this function only.
function getUserFirstName(){
  // 1) If you previously stored it
  const stored = localStorage.getItem("wc26_user_first_name");
  if(stored) return stored;

  // 2) Try a gentle inference from browser profile (not reliable)
  // We'll keep it simple.
  return "Your";
}

// Convert country code -> flag emoji
function flagEmojiFromCode(code){
  if(!code) return "";
  const cc = String(code).toUpperCase();

  // Kosovo doesn't have a universally supported emoji flag
  if(cc === "XK") return "🏳️";

  if(!/^[A-Z]{2}$/.test(cc)) return "";

  const A = 0x1F1E6;
  const chars = [...cc].map(c => String.fromCodePoint(A + (c.charCodeAt(0) - 65)));
  return chars.join("");
}

// Use your existing FLAG_CODE_BY_NAME map
function flagEmojiForName(name){
  if(!name) return "";
  if(
    name.startsWith("UEFA Path") ||
    name.startsWith("FIFA IC Path") ||
    name.includes("UFEA Path") ||
    name.includes("FIFA IC Path")
  ) return "";
  const code = FLAG_CODE_BY_NAME[name];
  return flagEmojiFromCode(code);
}

// The badge shown inside tiny match cards
function badgeTextForName(name){
  const ab = teamAbbrev(name);
  const em = flagEmojiForName(name);
  return em ? `${em} ${ab}` : ab;
}

// Compact landscape bracket image
function buildResultsCanvas(){
  const W = 1400;
  const H = 820;

  const canvas = document.createElement("canvas");
  canvas.width = W;
  canvas.height = H;
  const ctx = canvas.getContext("2d");

  // Background (dark)
  ctx.fillStyle = "#070b18";
  ctx.fillRect(0,0,W,H);

  // Subtle vignette
  const grd = ctx.createRadialGradient(
    W*0.15, H*0.12, 40,
    W*0.15, H*0.12, W*1.1
  );
  grd.addColorStop(0, "rgba(255,255,255,0.06)");
  grd.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,W,H);

  const firstName = getUserFirstName();
  const SITE_URL = getSiteUrlForImage();

  /* ------------------------------
     Champion headline (TOP RIGHT)
  ------------------------------ */
  const finalWinner = state.winners?.[104]?.name ?? "";
  const championText = finalWinner
    ? `2026 FIFA WC Champion: ${finalWinner}`
    : `2026 FIFA WC Champion: TBD`;

  ctx.font = "900 28px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle = "rgba(255,255,255,0.98)";
  const champW = ctx.measureText(championText).width;
  ctx.fillText(championText, W - champW - 34, 52);

  // Title (TOP LEFT)
  ctx.font = "800 22px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillStyle = "rgba(255,255,255,0.94)";
  ctx.fillText(`${firstName}'s World Cup 2026 Knockout Prediction`, 32, 52);

  // ✅ Removed the redundant R16→QF→SF→Final line as requested

  /* ------------------------------
     Compact match card geometry
  ------------------------------ */
  const boxW = 165; // smaller length
  const boxH = 50;
  const r = 10;

  const xR16 = 40;
  const xQF  = 300;
  const xSF  = 560;
  const xF   = 820;
  const xF2  = 1080; // for Final/3rd cluster if needed

  // Match lookup
  const matchById = {};
  [...R16_MATCHES, ...QF_MATCHES, ...SF_MATCHES, ...THIRD_MATCH, ...FINAL_MATCH]
    .forEach(m => matchById[m.id] = m);

  function roundRect(x,y,w,h,rad){
    const rr = Math.min(rad, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.lineTo(x+w-rr, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
    ctx.lineTo(x+w, y+h-rr);
    ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
    ctx.lineTo(x+rr, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
    ctx.lineTo(x, y+rr);
    ctx.quadraticCurveTo(x, y, x+rr, y);
    ctx.closePath();
  }

  function drawBoxFrame(x,y,w,h, winnerAccent=false){
    roundRect(x,y,w,h,r);
    ctx.fillStyle = "rgba(255,255,255,0.045)";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.13)";
    ctx.lineWidth = 1.1;
    ctx.stroke();

    // winner accent bar
    if(winnerAccent){
      ctx.fillStyle = "rgba(94,230,168,0.30)";
      ctx.fillRect(x + w - 7, y + 6, 3, h - 12);
    }
  }

  function centerOf(pos){
    return { cx: pos.x + pos.w/2, cy: pos.y + pos.h/2 };
  }

  function drawConnector(fromPos, toPos){
    const a = centerOf(fromPos);
    const b = centerOf(toPos);
    const midX = (a.cx + b.cx) / 2;

    ctx.strokeStyle = "rgba(255,255,255,0.16)";
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(a.cx + fromPos.w/2 - 6, a.cy);
    ctx.lineTo(midX, a.cy);
    ctx.lineTo(midX, b.cy);
    ctx.lineTo(b.cx - toPos.w/2 + 6, b.cy);
    ctx.stroke();
  }

  function drawMatchBox(matchId, pos, labelPrefix){
    const match = matchById[matchId];
    if(!match) return;

    const p = resolveParticipants(match);
    const winner = state.winners?.[matchId]?.name ?? null;

    drawBoxFrame(pos.x, pos.y, pos.w, pos.h, !!winner);

    // small match label
    ctx.fillStyle = "rgba(255,255,255,0.62)";
    ctx.font = "700 9px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`${labelPrefix} • ${matchId}`, pos.x + 8, pos.y + 12);

    // badges (emoji + abbr)
    const leftText  = badgeTextForName(p.left.name);
    const rightText = badgeTextForName(p.right.name);

    const leftIsWinner  = winner && winner === p.left.name;
    const rightIsWinner = winner && winner === p.right.name;

    ctx.font = `${leftIsWinner ? "800" : "650"} 17px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillStyle = leftIsWinner ? "rgba(255,255,255,1)" : "rgba(255,255,255,0.86)";
    ctx.fillText(leftText, pos.x + 10, pos.y + 31);

    ctx.font = `${rightIsWinner ? "800" : "650"} 17px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillStyle = rightIsWinner ? "rgba(255,255,255,1)" : "rgba(255,255,255,0.86)";
    ctx.fillText(rightText, pos.x + 10, pos.y + 48);
  }

  /* ------------------------------
     Layout positions
     (keeps single-tree, avoids overlap)
  ------------------------------ */
  const matchIdsR16 = R16_MATCHES.map(m => m.id).slice().sort((a,b)=>a-b);
  const matchIdsQF  = QF_MATCHES.map(m => m.id).slice().sort((a,b)=>a-b);
  const matchIdsSF  = SF_MATCHES.map(m => m.id).slice().sort((a,b)=>a-b);

  const finalId = FINAL_MATCH[0]?.id; // 104
  const thirdId = THIRD_MATCH[0]?.id; // 103

  const posById = {};

  const topY = 110;
  const gapR16 = 86;

  matchIdsR16.forEach((id, i) => {
    posById[id] = { x: xR16, y: topY + i*gapR16, w: boxW, h: boxH };
  });

  // QF positions based on parents
  matchIdsQF.forEach(id => {
    const m = matchById[id];
    const parents = [m.left, m.right].filter(s => s.type === "WM").map(s => s.id);
    if(parents.length === 2 && posById[parents[0]] && posById[parents[1]]){
      const y1 = centerOf(posById[parents[0]]).cy;
      const y2 = centerOf(posById[parents[1]]).cy;
      posById[id] = { x: xQF, y: (y1+y2)/2 - boxH/2, w: boxW, h: boxH };
    } else {
      posById[id] = { x: xQF, y: topY + 120, w: boxW, h: boxH };
    }
  });

  // SF positions
  matchIdsSF.forEach(id => {
    const m = matchById[id];
    const parents = [m.left, m.right].filter(s => s.type === "WM").map(s => s.id);
    if(parents.length === 2 && posById[parents[0]] && posById[parents[1]]){
      const y1 = centerOf(posById[parents[0]]).cy;
      const y2 = centerOf(posById[parents[1]]).cy;
      posById[id] = { x: xSF, y: (y1+y2)/2 - boxH/2, w: boxW, h: boxH };
    } else {
      posById[id] = { x: xSF, y: topY + 230, w: boxW, h: boxH };
    }
  });

  // Final position
  if(finalId){
    const m = matchById[finalId];
    const parents = [m.left, m.right].filter(s => s.type === "WM").map(s => s.id);
    if(parents.length === 2 && posById[parents[0]] && posById[parents[1]]){
      const y1 = centerOf(posById[parents[0]]).cy;
      const y2 = centerOf(posById[parents[1]]).cy;
      posById[finalId] = { x: xF2, y: (y1+y2)/2 - boxH/2, w: boxW, h: boxH };
    } else {
      posById[finalId] = { x: xF2, y: topY + 300, w: boxW, h: boxH };
    }
  }

  // 3rd place just below final
  if(thirdId){
    const baseY = finalId && posById[finalId] ? posById[finalId].y : (topY + 300);
    posById[thirdId] = { x: xF2, y: baseY + 95, w: boxW, h: boxH };
  }

  /* ------------------------------
     Draw connectors
  ------------------------------ */
  matchIdsQF.forEach(qf => {
    const m = matchById[qf];
    [m.left, m.right].forEach(s => {
      if(s.type === "WM" && posById[s.id] && posById[qf]){
        drawConnector(posById[s.id], posById[qf]);
      }
    });
  });

  matchIdsSF.forEach(sf => {
    const m = matchById[sf];
    [m.left, m.right].forEach(s => {
      if(s.type === "WM" && posById[s.id] && posById[sf]){
        drawConnector(posById[s.id], posById[sf]);
      }
    });
  });

  if(finalId){
    const m = matchById[finalId];
    [m.left, m.right].forEach(s => {
      if(s.type === "WM" && posById[s.id] && posById[finalId]){
        drawConnector(posById[s.id], posById[finalId]);
      }
    });
  }

  if(thirdId){
    matchIdsSF.forEach(sf => {
      if(posById[sf] && posById[thirdId]){
        drawConnector(posById[sf], posById[thirdId]);
      }
    });
  }

  /* ------------------------------
     Draw boxes
  ------------------------------ */
  matchIdsR16.forEach(id => drawMatchBox(id, posById[id], "R16"));
  matchIdsQF.forEach(id  => drawMatchBox(id, posById[id], "QF"));
  matchIdsSF.forEach(id  => drawMatchBox(id, posById[id], "SF"));
  if(finalId) drawMatchBox(finalId, posById[finalId], "FINAL");
  if(thirdId) drawMatchBox(thirdId, posById[thirdId], "3RD PLACE");

  /* ------------------------------
     Optional tiny legend (bottom-left)
     This also confirms emoji works.
  ------------------------------ */
  ctx.fillStyle = "rgba(255,255,255,0.50)";
  ctx.font = "600 10px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("Legend: Flag emoji + 3-letter ABBR. Accent bar indicates selected winner.", 32, H - 26);

  /* ------------------------------
     Footer branding (BOTTOM RIGHT)
  ------------------------------ */
  const rightPad = 32;

  const sourceLine1 = "Source";
  const sourceLine2 = SITE_SOURCE_NAME;
  const sourceLine3 = "Get your predictions at:";
  const sourceLine4 = SITE_URL;

  ctx.textAlign = "right";

  ctx.fillStyle = "rgba(255,255,255,0.62)";
  ctx.font = "700 10px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(sourceLine1, W - rightPad, H - 78);

  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.font = "700 11px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(sourceLine2, W - rightPad, H - 62);

  ctx.fillStyle = "rgba(255,255,255,0.60)";
  ctx.font = "600 10px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(sourceLine3, W - rightPad, H - 44);

  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.font = "700 10px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(sourceLine4, W - rightPad, H - 28);

  // Timestamp bottom-right corner (above URL a bit)
  const ts = new Date().toLocaleString();
  ctx.fillStyle = "rgba(255,255,255,0.40)";
  ctx.font = "600 9px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(ts, W - rightPad, H - 10);

  ctx.textAlign = "start";

  return canvas;
}



    function openPrintModal(){
      const backdrop = document.getElementById("printModalBackdrop");
      const img = document.getElementById("printPreviewImg");

      const canvas = buildResultsCanvas();
      const dataUrl = canvas.toDataURL("image/png");

      img.src = dataUrl;
      img.dataset.url = dataUrl;

      backdrop.classList.add("show");
      backdrop.setAttribute("aria-hidden","false");
    }

    function closePrintModal(){
      const backdrop = document.getElementById("printModalBackdrop");
      const img = document.getElementById("printPreviewImg");
      img.src = "";
      img.dataset.url = "";
      backdrop.classList.remove("show");
      backdrop.setAttribute("aria-hidden","true");
    }

    function viewPrintImage(){
      const img = document.getElementById("printPreviewImg");
      const url = img.dataset.url;
      if(!url) return;
      window.open(url, "_blank", "noopener,noreferrer");
    }

    function downloadPrintImage(){
      const img = document.getElementById("printPreviewImg");
      const url = img.dataset.url;
      if(!url) return;

      const a = document.createElement("a");
      const stamp = new Date().toISOString().slice(0,10);
      a.href = url;
      a.download = `wc26-prediction-${stamp}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    /* ==============================
       28) Wire Buttons
    ============================== */
    function wireButtons(){
      const resetBtn = document.getElementById("resetBtn");
      const clearMovedBtn = document.getElementById("clearMovedBtn");

      const reformBtn = document.getElementById("reformPoolBtn");
      const placeBtn = document.getElementById("placeQualifiersBtn");
      const autoPoolsBtn = document.getElementById("autoPoolsBtn");

      const autoGroupsBtn = document.getElementById("autoGroupsBtn");
      const autoThirdBtn = document.getElementById("autoThirdBtn");

      const regenerateR32Btn = document.getElementById("regenerateR32Btn");
      const autoR32Btn = document.getElementById("autoR32Btn");
      const autoR16Btn = document.getElementById("autoR16Btn");
      const autoQFBtn = document.getElementById("autoQFBtn");
      const autoSFBtn = document.getElementById("autoSFBtn");
      const autoThirdMatchBtn = document.getElementById("autoThirdMatchBtn");
      const autoFinalBtn = document.getElementById("autoFinalBtn");

      const printBtn = document.getElementById("printResultsBtn");

      const closeModalBtn = document.getElementById("closePrintModal");
      const backdrop = document.getElementById("printModalBackdrop");
      const viewBtn = document.getElementById("viewPrintImgBtn");
      const dlBtn = document.getElementById("downloadPrintImgBtn");

      if(clearMovedBtn){
        clearMovedBtn.addEventListener("click", clearAllUserMoved);
      }

      if(placeBtn){
        placeBtn.addEventListener("click", () => {
          if(editMode !== "pools") return;
          placeQualifiersToGroups();
        });
      }

      if(reformBtn){
        reformBtn.addEventListener("click", () => reformPoolMode());
      }

      if(resetBtn){
        resetBtn.addEventListener("click", () => {
          state = initialState();
          editMode = "pools";
          swapSelection = null;
          thirdRankingDirty = false;

          buildBoard();
          render();
          wireButtons();
        });
      }

      if(autoPoolsBtn) autoPoolsBtn.addEventListener("click", autoPools);
      if(autoGroupsBtn) autoGroupsBtn.addEventListener("click", autoGroups);
      if(autoThirdBtn) autoThirdBtn.addEventListener("click", autoThirdRanking);

      if(regenerateR32Btn){
        regenerateR32Btn.addEventListener("click", regenerateR32);
      }

      if(autoR32Btn){
        autoR32Btn.addEventListener("click", () => {
          if(!state.r32Generated) regenerateR32();
          autoRound(R32_MATCHES);
        });
      }

      if(autoR16Btn) autoR16Btn.addEventListener("click", () => autoRound(R16_MATCHES));
      if(autoQFBtn)  autoQFBtn.addEventListener("click", () => autoRound(QF_MATCHES));
      if(autoSFBtn)  autoSFBtn.addEventListener("click", () => autoRound(SF_MATCHES));
      if(autoThirdMatchBtn) autoThirdMatchBtn.addEventListener("click", () => autoRound(THIRD_MATCH));
      if(autoFinalBtn) autoFinalBtn.addEventListener("click", () => autoRound(FINAL_MATCH));

      /* ✅ Print result */
      if(printBtn){
        printBtn.addEventListener("click", () => {
          // Require final winner selected
          if(!state.winners[104]) return;
          openPrintModal();
        });
      }

      /* Modal controls */
      if(closeModalBtn) closeModalBtn.addEventListener("click", closePrintModal);
      if(viewBtn) viewBtn.addEventListener("click", viewPrintImage);
      if(dlBtn) dlBtn.addEventListener("click", downloadPrintImage);

      // click outside dialog to close
      if(backdrop){
        backdrop.addEventListener("click", (e) => {
          if(e.target === backdrop) closePrintModal();
        });
      }

      // ESC
      document.addEventListener("keydown", (e) => {
        const isOpen = backdrop?.classList.contains("show");
        if(isOpen && e.key === "Escape"){
          closePrintModal();
        }
      });
    }

    /* ==============================
       29) Render orchestrator
    ============================== */
    function render(){
      syncThirdRankingNames();
      renderStandardZones();
      renderAllKo();
      updateRegenerateR32Badge();

      const reformBtn = document.getElementById("reformPoolBtn");
      const placeBtn  = document.getElementById("placeQualifiersBtn");
      const printBtn  = document.getElementById("printResultsBtn");

      if(reformBtn) reformBtn.disabled = (editMode === "pools");
      if(placeBtn)  placeBtn.disabled  = (editMode !== "pools");

      // ✅ Enable print only after final winner
      if(printBtn){
        printBtn.disabled = !state.winners[104];
      }
    }

    /* ==============================
       30) Boot
    ============================== */
    document.addEventListener("DOMContentLoaded", () => {
      buildBoard();
      render();
      wireButtons();
    });
  </script>
</body>
</html>
